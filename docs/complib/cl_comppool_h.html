<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<link rel="stylesheet" href="../robodoc.css" type="text/css">
<title>./inc_docs/complib/cl_comppool_h.html</title>
<!-- Source: ./inc/complib/cl_comppool.h -->
<!-- Generated with ROBODoc Version 4.99.17 (Aug  2 2005) -->
</head>
<body bgcolor="#FFFFFF">
<a name="robo_top_of_doc">Generated from ./inc/complib/cl_comppool.h</a> with <a href="http://sourceforge.net/projects/robodoc/">ROBODoc</a> v4.99.17 on Sun Mar 04 2007 18:17:52
<br />
<hr />

<h2><a name="robo5">[Modules]<a name="Component20Library2fComposite20Pool">
Component Library/Composite Pool</a></h2>

<p>[<a href="#robo_top_of_doc">top</a>][<a href="./comp_lib_h.html#robo4">parent</a>][<a href="../robo_modules.html#top">index</a>]</p>
<p><strong>NAME</strong></p>
<span class="NAME"><pre>       Composite <a href="./cl_pool_h.html#robo18">Pool</a>
</pre>
</span><p><strong>DESCRIPTION</strong></p>
<span class="DESCRIPTION"><pre>       The Composite <a href="./cl_pool_h.html#robo18">Pool</a> provides a self-contained and self-sustaining pool of
       user defined composite objects.

       A composite object is an object that is composed of one or more
       sub-objects, each of which needs to be treated separately for
       initialization. Objects can be retrieved from the pool as long as there
       is memory in the system.

       To aid in object oriented design, the composite pool provides the user
       the ability to specify callbacks that are invoked for each object for
       construction, initialization, and destruction. Constructor and destructor
       callback functions may not fail.

       A composite pool does not return memory to the system as the user returns
       objects to the pool. The only method of returning memory to the system is
       to destroy the pool.

       The composite pool functions operates on a <a href="#robo303">cl_cpool_t</a> structure which
       should be treated as opaque and should be manipulated only through the
       provided functions.
</pre>
</span><p><strong>SEE ALSO</strong></p>
<span class="SEE_ALSO"><pre>       Structures:
               <a href="#robo303">cl_cpool_t</a>

       Callbacks:
               <a href="#robo306">cl_pfn_cpool_init_t</a>, <a href="#robo305">cl_pfn_cpool_dtor_t</a>

       Initialization/Destruction:
               <a href="#robo296">cl_cpool_construct</a>, <a href="#robo301">cl_cpool_init</a>, <a href="#robo298">cl_cpool_destroy</a>

       Manipulation:
               <a href="#robo299">cl_cpool_get</a>, <a href="#robo302">cl_cpool_put</a>, <a href="#robo300">cl_cpool_grow</a>

       Attributes:
               <a href="#robo304">cl_is_cpool_inited</a>, <a href="#robo297">cl_cpool_count</a>
</pre>
</span>
<hr />

<h2><a name="robo296">[Functions]<a name="Component20Library3a20Composite20Pool2fcl5fcpool5fconstruct">
Component Library: Composite Pool/cl_cpool_construct</a></h2>

<p>[<a href="#robo_top_of_doc">top</a>][<a href="../robo_functions.html#top">index</a>]</p>
<p><strong>NAME</strong></p>
<span class="NAME"><pre>       <strong>cl_cpool_construct</strong>
</pre>
</span><p><strong>DESCRIPTION</strong></p>
<span class="DESCRIPTION"><pre>       The <strong>cl_cpool_construct</strong> function constructs a composite pool.
</pre>
</span><p><strong>SYNOPSIS</strong></p>
<span class="SYNOPSIS"><pre>CL_EXPORT void CL_API
<strong>cl_cpool_construct</strong>(
        IN      <a href="#robo303">cl_cpool_t</a>* const       p_pool );
</pre>
</span><p><strong>PARAMETERS</strong></p>
<span class="PARAMETERS"><pre>       p_pool
               [in] Pointer to a <a href="#robo303">cl_cpool_t</a> structure whose state to initialize.
</pre>
</span><p><strong>RETURN VALUE</strong></p>
<span class="RETURN_VALUE"><pre>       This function does not return a value.
</pre>
</span><p><strong>NOTES</strong></p>
<span class="NOTES"><pre>       Allows calling <a href="./cl_pool_h.html#robo518">cl_pool_init</a>, <a href="#robo298">cl_cpool_destroy</a>, <a href="#robo304">cl_is_cpool_inited</a>.

       Calling <strong>cl_cpool_construct</strong> is a prerequisite to calling any other
       composite pool function except <a href="#robo301">cl_cpool_init</a>.
</pre>
</span><p><strong>SEE ALSO</strong></p>
<span class="SEE_ALSO"><pre>       Composite <a href="./cl_pool_h.html#robo18">Pool</a>, <a href="#robo301">cl_cpool_init</a>, <a href="#robo298">cl_cpool_destroy</a>, <a href="#robo304">cl_is_cpool_inited</a>
</pre>
</span>
<hr />

<h2><a name="robo297">[Functions]<a name="Component20Library3a20Composite20Pool2fcl5fcpool5fcount">
Component Library: Composite Pool/cl_cpool_count</a></h2>

<p>[<a href="#robo_top_of_doc">top</a>][<a href="../robo_functions.html#top">index</a>]</p>
<p><strong>NAME</strong></p>
<span class="NAME"><pre>       <strong>cl_cpool_count</strong>
</pre>
</span><p><strong>DESCRIPTION</strong></p>
<span class="DESCRIPTION"><pre>       The <strong>cl_cpool_count</strong> function returns the number of available objects
       in a composite pool.
</pre>
</span><p><strong>SYNOPSIS</strong></p>
<span class="SYNOPSIS"><pre>CL_INLINE size_t CL_API
<strong>cl_cpool_count</strong>(
        IN      <a href="#robo303">cl_cpool_t</a>* const       p_pool )
{
        CL_ASSERT( p_pool );
        return( <a href="./cl_qcomppool_h.html#robo526">cl_qcpool_count</a>( &amp;p_pool-&gt;qcpool ) );
}
</pre>
</span><p><strong>PARAMETERS</strong></p>
<span class="PARAMETERS"><pre>       p_pool
               [in] Pointer to a <a href="#robo303">cl_cpool_t</a> structure for which the number of
               available objects is requested.
</pre>
</span><p><strong>RETURN VALUE</strong></p>
<span class="RETURN_VALUE"><pre>       Returns the number of objects available in the specified
       composite pool.
</pre>
</span><p><strong>SEE ALSO</strong></p>
<span class="SEE_ALSO"><pre>       Composite <a href="./cl_pool_h.html#robo18">Pool</a>
</pre>
</span>
<hr />

<h2><a name="robo298">[Functions]<a name="Component20Library3a20Composite20Pool2fcl5fcpool5fdestroy">
Component Library: Composite Pool/cl_cpool_destroy</a></h2>

<p>[<a href="#robo_top_of_doc">top</a>][<a href="../robo_functions.html#top">index</a>]</p>
<p><strong>NAME</strong></p>
<span class="NAME"><pre>       <strong>cl_cpool_destroy</strong>
</pre>
</span><p><strong>DESCRIPTION</strong></p>
<span class="DESCRIPTION"><pre>       The <strong>cl_cpool_destroy</strong> function destroys a composite pool.
</pre>
</span><p><strong>SYNOPSIS</strong></p>
<span class="SYNOPSIS"><pre>CL_INLINE void CL_API
<strong>cl_cpool_destroy</strong>(
        IN      <a href="#robo303">cl_cpool_t</a>* const       p_pool )
{
        CL_ASSERT( p_pool );

        <a href="./cl_qcomppool_h.html#robo527">cl_qcpool_destroy</a>( &amp;p_pool-&gt;qcpool );
}
</pre>
</span><p><strong>PARAMETERS</strong></p>
<span class="PARAMETERS"><pre>       p_pool
               [in] Pointer to a <a href="#robo303">cl_cpool_t</a> structure to destroy.
</pre>
</span><p><strong>RETURN VALUE</strong></p>
<span class="RETURN_VALUE"><pre>       This function does not return a value.
</pre>
</span><p><strong>NOTES</strong></p>
<span class="NOTES"><pre>       All memory allocated for composite objects is freed. The destructor
       callback, if any, will be invoked for every allocated object. Further
       operations on the composite pool should not be attempted after
       <strong>cl_cpool_destroy</strong> is invoked.

       This function should only be called after a call to <a href="#robo296">cl_cpool_construct</a>.

       In a debug build, <strong>cl_cpool_destroy</strong> asserts that all objects are in
       the pool.
</pre>
</span><p><strong>SEE ALSO</strong></p>
<span class="SEE_ALSO"><pre>       Composite <a href="./cl_pool_h.html#robo18">Pool</a>, <a href="#robo296">cl_cpool_construct</a>, <a href="#robo301">cl_cpool_init</a>
</pre>
</span>
<hr />

<h2><a name="robo299">[Functions]<a name="Component20Library3a20Composite20Pool2fcl5fcpool5fget">
Component Library: Composite Pool/cl_cpool_get</a></h2>

<p>[<a href="#robo_top_of_doc">top</a>][<a href="../robo_functions.html#top">index</a>]</p>
<p><strong>NAME</strong></p>
<span class="NAME"><pre>       <strong>cl_cpool_get</strong>
</pre>
</span><p><strong>DESCRIPTION</strong></p>
<span class="DESCRIPTION"><pre>       The <strong>cl_cpool_get</strong> function retrieves an object from a
       composite pool.
</pre>
</span><p><strong>SYNOPSIS</strong></p>
<span class="SYNOPSIS"><pre>CL_INLINE void* CL_API
<strong>cl_cpool_get</strong>(
        IN      <a href="#robo303">cl_cpool_t</a>* const       p_pool )
{
        cl_pool_obj_t   *p_pool_obj;

        CL_ASSERT( p_pool );

        p_pool_obj = (cl_pool_obj_t*)<a href="./cl_qcomppool_h.html#robo528">cl_qcpool_get</a>( &amp;p_pool-&gt;qcpool );
        if( !p_pool_obj )
                return( NULL );

        CL_ASSERT( p_pool_obj-&gt;list_obj.p_object );
        return( (void*)p_pool_obj-&gt;list_obj.p_object );
}
</pre>
</span><p><strong>PARAMETERS</strong></p>
<span class="PARAMETERS"><pre>       p_pool
               [in] Pointer to a <a href="#robo303">cl_cpool_t</a> structure from which to retrieve
               an object.

 RETURN VALUES
       Returns a pointer to the first component of a composite object.

       Returns NULL if the pool is empty and can not be grown automatically.
</pre>
</span><p><strong>NOTES</strong></p>
<span class="NOTES"><pre>       <strong>cl_cpool_get</strong> returns the object at the head of the pool. If the pool is
       empty, it is automatically grown to accommodate this request unless the
       grow_size parameter passed to the <a href="#robo301">cl_cpool_init</a> function was zero.
</pre>
</span><p><strong>SEE ALSO</strong></p>
<span class="SEE_ALSO"><pre>       Composite <a href="./cl_pool_h.html#robo18">Pool</a>, cl_cpool_get_tail, <a href="#robo302">cl_cpool_put</a>, <a href="#robo300">cl_cpool_grow</a>,
       <a href="#robo297">cl_cpool_count</a>
</pre>
</span>
<hr />

<h2><a name="robo300">[Functions]<a name="Component20Library3a20Composite20Pool2fcl5fcpool5fgrow">
Component Library: Composite Pool/cl_cpool_grow</a></h2>

<p>[<a href="#robo_top_of_doc">top</a>][<a href="../robo_functions.html#top">index</a>]</p>
<p><strong>NAME</strong></p>
<span class="NAME"><pre>       <strong>cl_cpool_grow</strong>
</pre>
</span><p><strong>DESCRIPTION</strong></p>
<span class="DESCRIPTION"><pre>       The <strong>cl_cpool_grow</strong> function grows a composite pool by
       the specified number of objects.
</pre>
</span><p><strong>SYNOPSIS</strong></p>
<span class="SYNOPSIS"><pre>CL_INLINE <a href="./cl_types_h.html#robo308">cl_status_t</a> CL_API
<strong>cl_cpool_grow</strong>(
        IN      <a href="#robo303">cl_cpool_t</a>* const       p_pool,
        IN      const size_t            obj_count )
{
        CL_ASSERT( p_pool );
        return( <a href="./cl_qcomppool_h.html#robo529">cl_qcpool_grow</a>( &amp;p_pool-&gt;qcpool, obj_count ) );
}
</pre>
</span><p><strong>PARAMETERS</strong></p>
<span class="PARAMETERS"><pre>       p_pool
               [in] Pointer to a <a href="#robo303">cl_cpool_t</a> structure whose capacity to grow.

       obj_count
               [in] Number of objects by which to grow the pool.

 RETURN VALUES
       CL_SUCCESS if the composite pool grew successfully.

       CL_INSUFFICIENT_MEMORY if there was not enough memory to grow the
       composite pool.

       <a href="./cl_types_h.html#robo308">cl_status_t</a> value returned by optional initialization callback function
       specified by the pfn_initializer parameter passed to the
       <a href="#robo301">cl_cpool_init</a> function.
</pre>
</span><p><strong>NOTES</strong></p>
<span class="NOTES"><pre>       It is not necessary to call <strong>cl_cpool_grow</strong> if the pool is
       configured to grow automatically.
</pre>
</span><p><strong>SEE ALSO</strong></p>
<span class="SEE_ALSO"><pre>       Composite <a href="./cl_pool_h.html#robo18">Pool</a>
</pre>
</span>
<hr />

<h2><a name="robo301">[Functions]<a name="Component20Library3a20Composite20Pool2fcl5fcpool5finit">
Component Library: Composite Pool/cl_cpool_init</a></h2>

<p>[<a href="#robo_top_of_doc">top</a>][<a href="../robo_functions.html#top">index</a>]</p>
<p><strong>NAME</strong></p>
<span class="NAME"><pre>       <strong>cl_cpool_init</strong>
</pre>
</span><p><strong>DESCRIPTION</strong></p>
<span class="DESCRIPTION"><pre>       The <strong>cl_cpool_init</strong> function initializes a composite pool for use.
</pre>
</span><p><strong>SYNOPSIS</strong></p>
<span class="SYNOPSIS"><pre>CL_EXPORT <a href="./cl_types_h.html#robo308">cl_status_t</a> CL_API
<strong>cl_cpool_init</strong>(
        IN      <a href="#robo303">cl_cpool_t</a>* const               p_pool,
        IN      const size_t                    min_size,
        IN      const size_t                    max_size,
        IN      const size_t                    grow_size,
        IN      size_t* const                   component_sizes,
        IN      const uint32_t                  num_components,
        IN      <a href="#robo306">cl_pfn_cpool_init_t</a>             pfn_initializer OPTIONAL,
        IN      <a href="#robo305">cl_pfn_cpool_dtor_t</a>             pfn_destructor OPTIONAL,
        IN      const void* const               context );
</pre>
</span><p><strong>PARAMETERS</strong></p>
<span class="PARAMETERS"><pre>       p_pool
               [in] Pointer to a <a href="#robo303">cl_cpool_t</a> structure to initialize.

       min_size
               [in] Minimum number of objects that the pool should support. All
               necessary allocations to allow storing the minimum number of items
               are performed at initialization time, and all necessary callbacks
               successfully invoked.

       max_size
               [in] Maximum number of objects to which the pool is allowed to grow.
               A value of zero specifies no maximum.

       grow_size
               [in] Number of objects to allocate when incrementally growing the pool.
               A value of zero disables automatic growth.

       component_sizes
               [in] Pointer to the first entry in an array of sizes describing,
               in order, the sizes of the components that make up a composite object.

       num_components
               [in] Number of components that make up a composite object.

       pfn_initializer
               [in] Initialization callback to invoke for every new object when
               growing the pool. This parameter may be NULL only if the objects
               stored in the composite pool consist of only one component.
               See the cl_pfn_cpool_init function type declaration for details
               about the callback function.

       pfn_destructor
               [in] Destructor callback to invoke for every object before memory for
               that object is freed. This parameter is optional and may be NULL.
               See the cl_pfn_cpool_dtor function type declaration for details
               about the callback function.

       context
               [in] Value to pass to the callback functions to provide context.

 RETURN VALUES
       CL_SUCCESS if the composite pool was initialized successfully.

       CL_INSUFFICIENT_MEMORY if there was not enough memory to initialize the
       composite pool.

       CL_INVALID_SETTING if a NULL constructor was provided for composite objects
       consisting of more than one component.  Also returns CL_INVALID_SETTING if
       the maximum size is non-zero and less than the minimum size.

       Other <a href="./cl_types_h.html#robo308">cl_status_t</a> value returned by optional initialization callback function
       specified by the pfn_initializer parameter.
</pre>
</span><p><strong>NOTES</strong></p>
<span class="NOTES"><pre>       <strong>cl_cpool_init</strong> initializes, and if necessary, grows the pool to
       the capacity desired.
</pre>
</span><p><strong>SEE ALSO</strong></p>
<span class="SEE_ALSO"><pre>       Composite <a href="./cl_pool_h.html#robo18">Pool</a>, <a href="#robo296">cl_cpool_construct</a>, <a href="#robo298">cl_cpool_destroy</a>,
       <a href="#robo299">cl_cpool_get</a>, <a href="#robo302">cl_cpool_put</a>, <a href="#robo300">cl_cpool_grow</a>,
       <a href="#robo297">cl_cpool_count</a>, cl_pfn_cpool_ctor_t, <a href="#robo306">cl_pfn_cpool_init_t</a>,
       <a href="#robo305">cl_pfn_cpool_dtor_t</a>
</pre>
</span>
<hr />

<h2><a name="robo302">[Functions]<a name="Component20Library3a20Composite20Pool2fcl5fcpool5fput">
Component Library: Composite Pool/cl_cpool_put</a></h2>

<p>[<a href="#robo_top_of_doc">top</a>][<a href="../robo_functions.html#top">index</a>]</p>
<p><strong>NAME</strong></p>
<span class="NAME"><pre>       <strong>cl_cpool_put</strong>
</pre>
</span><p><strong>DESCRIPTION</strong></p>
<span class="DESCRIPTION"><pre>       The <strong>cl_cpool_put</strong> function returns an object to a composite pool.
</pre>
</span><p><strong>SYNOPSIS</strong></p>
<span class="SYNOPSIS"><pre>CL_INLINE void CL_API
<strong>cl_cpool_put</strong>(
        IN      <a href="#robo303">cl_cpool_t</a>* const       p_pool,
        IN      void* const                     p_object )
{
        cl_pool_obj_t   *p_pool_obj;

        CL_ASSERT( p_pool );
        CL_ASSERT( p_object );

        /* Calculate the offset to the list object representing this object. */
        p_pool_obj = (cl_pool_obj_t*)
                (((uint8_t*)p_object) - sizeof(cl_pool_obj_t));

        /* good sanity check */
        CL_ASSERT( p_pool_obj-&gt;list_obj.p_object == p_object );

        <a href="./cl_qcomppool_h.html#robo531">cl_qcpool_put</a>( &amp;p_pool-&gt;qcpool, (<a href="./cl_qcomppool_h.html#robo524">cl_pool_item_t</a>*)p_pool_obj );
}
</pre>
</span><p><strong>PARAMETERS</strong></p>
<span class="PARAMETERS"><pre>       p_pool
               [in] Pointer to a <a href="#robo303">cl_cpool_t</a> structure to which to return
               an object.

       p_object
               [in] Pointer to the first component of an object to return to the pool.
</pre>
</span><p><strong>RETURN VALUE</strong></p>
<span class="RETURN_VALUE"><pre>       This function does not return a value.
</pre>
</span><p><strong>NOTES</strong></p>
<span class="NOTES"><pre>       <strong>cl_cpool_put</strong> places the returned object at the head of the pool.

       The object specified by the p_object parameter must have been
       retrieved from the pool by a previous call to <a href="#robo299">cl_cpool_get</a>.
</pre>
</span><p><strong>SEE ALSO</strong></p>
<span class="SEE_ALSO"><pre>       Composite <a href="./cl_pool_h.html#robo18">Pool</a>, cl_cpool_put_tail, <a href="#robo299">cl_cpool_get</a>
</pre>
</span>
<hr />

<h2><a name="robo303">[Structures]<a name="Component20Library3a20Composite20Pool2fcl5fcpool5ft">
Component Library: Composite Pool/cl_cpool_t</a></h2>

<p>[<a href="#robo_top_of_doc">top</a>][<a href="../robo_strutures.html#top">index</a>]</p>
<p><strong>NAME</strong></p>
<span class="NAME"><pre>       <strong>cl_cpool_t</strong>
</pre>
</span><p><strong>DESCRIPTION</strong></p>
<span class="DESCRIPTION"><pre>       Composite pool structure.

       The <strong>cl_cpool_t</strong> structure should be treated as opaque and should be
       manipulated only through the provided functions.
</pre>
</span><p><strong>SYNOPSIS</strong></p>
<span class="SYNOPSIS"><pre>typedef struct _cl_cpool
{
        <a href="./cl_qcomppool_h.html#robo533">cl_qcpool_t</a>                             qcpool;
        <a href="#robo306">cl_pfn_cpool_init_t</a>             pfn_init;
        <a href="#robo305">cl_pfn_cpool_dtor_t</a>             pfn_dtor;
        const void                              *context;

} <strong>cl_cpool_t</strong>;
</pre>
</span><p><strong>FIELDS</strong></p>
<span class="FIELDS"><pre>       qcpool
               Quick composite pool that manages all objects.

       pfn_init
               Pointer to the user's initializer callback, used by the pool
               to translate the quick composite pool's initializer callback to
               a composite pool initializer callback.

       pfn_dtor
               Pointer to the user's destructor callback, used by the pool
               to translate the quick composite pool's destructor callback to
               a composite pool destructor callback.

       context
               User's provided context for callback functions, used by the pool
               to when invoking callbacks.
</pre>
</span><p><strong>SEE ALSO</strong></p>
<span class="SEE_ALSO"><pre>       Composite <a href="./cl_pool_h.html#robo18">Pool</a>
</pre>
</span>
<hr />

<h2><a name="robo304">[Functions]<a name="Component20Library3a20Composite20Pool2fcl5fis5fcpool5finited">
Component Library: Composite Pool/cl_is_cpool_inited</a></h2>

<p>[<a href="#robo_top_of_doc">top</a>][<a href="../robo_functions.html#top">index</a>]</p>
<p><strong>NAME</strong></p>
<span class="NAME"><pre>       <strong>cl_is_cpool_inited</strong>
</pre>
</span><p><strong>DESCRIPTION</strong></p>
<span class="DESCRIPTION"><pre>       The <strong>cl_is_cpool_inited</strong> function returns whether a composite pool was
       successfully initialized.
</pre>
</span><p><strong>SYNOPSIS</strong></p>
<span class="SYNOPSIS"><pre>CL_INLINE boolean_t CL_API
<strong>cl_is_cpool_inited</strong>(
        IN      const <a href="#robo303">cl_cpool_t</a>* const p_pool )
{
        /* CL_ASSERT that a non-null pointer is provided. */
        CL_ASSERT( p_pool );
        return( <a href="./cl_qcomppool_h.html#robo521">cl_is_qcpool_inited</a>( &amp;p_pool-&gt;qcpool ) );
}
</pre>
</span><p><strong>PARAMETERS</strong></p>
<span class="PARAMETERS"><pre>       p_pool
               [in] Pointer to a <a href="#robo303">cl_cpool_t</a> structure whose initialization state
               to check.

 RETURN VALUES
       TRUE if the composite pool was initialized successfully.

       FALSE otherwise.
</pre>
</span><p><strong>NOTES</strong></p>
<span class="NOTES"><pre>       Allows checking the state of a composite pool to determine if invoking
       member functions is appropriate.
</pre>
</span><p><strong>SEE ALSO</strong></p>
<span class="SEE_ALSO"><pre>       Composite <a href="./cl_pool_h.html#robo18">Pool</a>
</pre>
</span>
<hr />

<h2><a name="robo305">[Definitions]<a name="Component20Library3a20Composite20Pool2fcl5fpfn5fcpool5fdtor5ft">
Component Library: Composite Pool/cl_pfn_cpool_dtor_t</a></h2>

<p>[<a href="#robo_top_of_doc">top</a>][<a href="../robo_definitions.html#top">index</a>]</p>
<p><strong>NAME</strong></p>
<span class="NAME"><pre>       <strong>cl_pfn_cpool_dtor_t</strong>
</pre>
</span><p><strong>DESCRIPTION</strong></p>
<span class="DESCRIPTION"><pre>       The <strong>cl_pfn_cpool_dtor_t</strong> function type defines the prototype for
       functions used as destructor for objects being deallocated by a
       composite pool.
</pre>
</span><p><strong>SYNOPSIS</strong></p>
<span class="SYNOPSIS"><pre>typedef void
(CL_API *<strong>cl_pfn_cpool_dtor_t</strong>)(
        IN      void* const                     p_object,
        IN      void*                           context );
</pre>
</span><p><strong>PARAMETERS</strong></p>
<span class="PARAMETERS"><pre>       p_object
               [in] Pointer to an object to destruct.

       context
               [in] Context provided in the call to <a href="#robo301">cl_cpool_init</a>.
</pre>
</span><p><strong>RETURN VALUE</strong></p>
<span class="RETURN_VALUE"><pre>       This function does not return a value.
</pre>
</span><p><strong>NOTES</strong></p>
<span class="NOTES"><pre>       This function type is provided as function prototype reference for
       the function provided by the user as an optional parameter to the
       <a href="#robo301">cl_cpool_init</a> function.

       The destructor is invoked once per allocated object, allowing the user
       to perform any necessary cleanup. Users should not attempt to deallocate
       the memory for the composite object, as the composite pool manages
       object allocation and deallocation.
</pre>
</span><p><strong>SEE ALSO</strong></p>
<span class="SEE_ALSO"><pre>       Composite <a href="./cl_pool_h.html#robo18">Pool</a>, <a href="#robo301">cl_cpool_init</a>
</pre>
</span>
<hr />

<h2><a name="robo306">[Definitions]<a name="Component20Library3a20Composite20Pool2fcl5fpfn5fcpool5finit5ft">
Component Library: Composite Pool/cl_pfn_cpool_init_t</a></h2>

<p>[<a href="#robo_top_of_doc">top</a>][<a href="../robo_definitions.html#top">index</a>]</p>
<p><strong>NAME</strong></p>
<span class="NAME"><pre>       <strong>cl_pfn_cpool_init_t</strong>
</pre>
</span><p><strong>DESCRIPTION</strong></p>
<span class="DESCRIPTION"><pre>       The <strong>cl_pfn_cpool_init_t</strong> function type defines the prototype for
       functions used as initializers for objects being allocated by a
       composite pool.
</pre>
</span><p><strong>SYNOPSIS</strong></p>
<span class="SYNOPSIS"><pre>typedef <a href="./cl_types_h.html#robo308">cl_status_t</a>
(CL_API *<strong>cl_pfn_cpool_init_t</strong>)(
        IN      void** const            p_comp_array,
        IN      const uint32_t          num_components,
        IN      void*                           context );
</pre>
</span><p><strong>PARAMETERS</strong></p>
<span class="PARAMETERS"><pre>       p_object
               [in] Pointer to an object to initialize.

       context
               [in] Context provided in a call to <a href="#robo301">cl_cpool_init</a>.

 RETURN VALUES
       Return CL_SUCCESS to indicates that initialization of the object
       was successful and that initialization of further objects may continue.

       Other <a href="./cl_types_h.html#robo308">cl_status_t</a> values will be returned by <a href="#robo301">cl_cpool_init</a>
       and <a href="#robo300">cl_cpool_grow</a>.
</pre>
</span><p><strong>NOTES</strong></p>
<span class="NOTES"><pre>       This function type is provided as function prototype reference for
       the function provided by the user as an optional parameter to the
       <a href="#robo301">cl_cpool_init</a> function.

       The initializer is invoked once per allocated object, allowing the user
       to chain components to form a composite object and perform any necessary
       initialization.  Returning a status other than CL_SUCCESS aborts a grow
       operation, initiated either through <a href="#robo301">cl_cpool_init</a> or <a href="#robo300">cl_cpool_grow</a>, and
       causes the initiating function to fail.  Any non-CL_SUCCESS status will
       be returned by the function that initiated the grow operation.

       All memory for the requested number of components is pre-allocated.

       When later performing a <a href="#robo299">cl_cpool_get</a> call, the return value is a pointer
       to the first component.
</pre>
</span><p><strong>SEE ALSO</strong></p>
<span class="SEE_ALSO"><pre>       Composite <a href="./cl_pool_h.html#robo18">Pool</a>, <a href="#robo301">cl_cpool_init</a>, <a href="#robo300">cl_cpool_grow</a>
</pre>
</span>
</body>
</html>
