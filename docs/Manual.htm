
<head>
<style>
<!--
div.Section1
	{page:Section1;}
span.GramE
	{}
-->
</style>
</head>

<h1 align="left">
<img border="0" src="openfabrics.gif" width="107" height="93">&nbsp; 
<a href="#TOP"></a> </h1>
<h1 align="center">OpenFabrics Enterprise Distribution (for Windows) </h1>
<h1 align="center">User's Manual</h1>
<h2 align="center">Release 3.2</h2>
<h3 align="center">
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%m/%d/%Y" startspan -->04/16/2013<!--webbot bot="Timestamp" endspan i-checksum="12595" --></h3>
<h2 align="left"><u>Overview</u></h2>
<p align="left"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 'Times New Roman'">
The OpenFabrics Enterprise Distribution for Windows package is composed of software modules intended 
for use on Microsoft Windows based computer systems connected via an InfiniBand 
fabric.</span></p>
<p align="left">The OpenFabrics <span style="FONT-SIZE: 12pt; FONT-FAMILY: 'Times New Roman'">
Enterprise Distribution for Windows </span>software package contains the 
following:<br>
<br>
OpenFabrics Infiniband core drivers and Upper Level Protocols (ULPs):</p>
<ul>
	<li>
	<p align="left">HCA (Host Channel Adapter) driver </li>
	<li>
	<p style="text-indent: -.25in; margin-left: .5in">
	<span style="background-position: 0% 0%">MLX4 - Mellanox 
	ConnectX{1,2,3,4} low level driver.</span><span
style='background-position: 0% 0%; mso-highlight:yellow; background-image:none; background-repeat:repeat; background-attachment:scroll'>
	</span>
	<span style='background-position: 0% 0%; mso-highlight:yellow; background-image:none; background-repeat:repeat; background-attachment:scroll'>
	See Release_notes.htm for a list of supported devices.</span></li>
	<li>
	<p align="left">Infiniband Core modules: IB verbs and IB access layer</li>
	<li>
	<p align="left">Upper Layer Protocols: IPoIB, WSD, NetworkDirect-v2, VNIC, 
	SRP Initiator, uDat/uDAPL and Rsockets.</li>
</ul>
<p align="left">OpenFabrics Tools:</p>
<ul>
	<li>
	<p align="left">OpenSM: InfiniBand Subnet Manager</li>
<li>
<p align="left">Performance tests</li>
<li>
<p align="left">Diagnostic tools</li>
</ul>
<p align="left">Documentation</p>
<ul>
	<li>
	<p align="left">User's manual</li>
<li>
<p align="left">Release Notes</li>
</ul>
<p align="left">&nbsp;</p>
<h2 align="left"><u><a name="TOP"></a>OFED Features</u></h2>
<ul>
	<li>
	<h3 align="left"><a href="#Tools">Tools &amp; Diagnostics</a></h3></li>
</ul>
<ul>
	<li>
	<h3 align="left"><a href="#IPoIB">IPoIB - Internet Protocols over InfiniBand</a></h3>
	</li>
	<li>
	<h3 align="left"><a href="#winsockdirect">Winsock Direct Service Provider</a></h3>
	</li>
	<li>
	<h3 align="left"><a href="#Network_Direct_Service_Provider">NetworkDirect 
	Service Provider</a></h3>
	</li>
	<li>
	<h3 align="left"><a href="#DAT">DAT and uDAPL</a></h3>
<ul>
	<li>
	<h4 align="left"><a href="#DAPLTEST">DAPLtest</a></h4></li>
	<li>
	<h4 align="left"><a href="#DAPLtest-examples">DAPLtest Examples</a></h4></li>
	<li>
	<p align="left"><b><a href="#DAT_App_Build">DAT Application Build</a></b><br>
	<br>&nbsp;</li>
</ul></li>
	<li>
	<h3 align="left"><a href="#SRP">SRP (SCSI over RDMA) Protocol Driver</a></h3></li>
	<li>
	<h3 align="left"><u><font color="#0000FF"><a href="#QLOGICVNIC">QLogic VNIC_Driver</a></font></u></h3></li>
	<li>
	<h3 align="left"><u><a href="#InfiniBand_Software_Development_Kit">
	OFED Software Development Kit</a></u></h3>
<ul>
	<li>
	<p align="left"><b><a href="#OFED_InfiniBand_Verbs">OFED InfiniBand Verbs</a></b></li>
	<li>
	<p align="left"><b><a href="#RDMA_CM_-_Communications_Manager">RDMA CM - Communications Manager</a></b><br>
&nbsp;</li>
</ul>
</li>
	<li>
	<h3 align="left"><a href="#RSockets">RSockets</a></h3></li>
	<li>
	<h3 align="left"><a href="#WinVerbs">WinVerbs</a></h3></li>
</ul>
<h3 align="left">&nbsp;</h3>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<BLOCKQUOTE></BLOCKQUOTE>
<h2 align="left"><a name="verbs_benchmarks0"></a><a name="Tools">Tools</a></h2>
<hr>
<blockquote>
	<blockquote>
		<p align="left">The OpenFabrics Alliance Enterprise for Windows release contains a set of 
	user mode tools which are designed to faciliate the smooth operation of an OpenFabrics 
		Enterprise Distribution installation. These tools are available from a command 
		window (cmd.exe) as the installation path '%SystemDrive%\Program 
		Files\OFED' is appended to the system wide search path registry entry. 
		A start menu short-cut 'OFED Cmd Window' is provided to faciliate 
		correction tool operation.</p>
		<h4 align="left"><u>IPoIB Partition Management</u></h4>
		<ul>
			<li>
			<p align="left"><a href="#InfiniBand_Partition_Management">part_man</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			Manage (add/remove/show) IPoIB partitions.</li>
	</ul>
	<h4 align="left"><u>Infiniband Subnet Management</u></h4>
		<ul>
			<li>
			<p align="left"><a href="#opensm">opensm</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Open Subnet 
	Management - configure and manage an InfiniBand subnet</li>
			<li>
			<p align="left"><a href="#osmtest">osmtest</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Subnet management tests</li>
			<li>
			<p align="left"><a href="#ibtrapgen">ib_trapgen</a>&nbsp;&nbsp;&nbsp;&nbsp; Generate Infiniband Subnet 
	Management Traps for testing purposes</li>
		</ul>
	<h4 align="left"><u>QLogic VNIC Child Device Management</u></h4>
		<ul>
			<li>
			<p align="left"><a href="#qlgcvnicconfig">qlgcvnic_config</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Configuration 
			utility used to configure IB Stack to create VNIC child devices as per user's requirement.</li>
		</ul>
		<h4 align="left"><a href="#verbs_benchmarks"><font color="#000000">Performance</font></a></h4>
		<ul>
			<li>
			<p align="left"><a href="#ibsend_lat">ib_send_lat</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Infiniband send 
latency measurement</li>
			<li>
			<p align="left"><a href="#ibsend_bw">ib_send_bw</a>&nbsp;&nbsp;&nbsp;&nbsp;Infiniband send bandwidth 
	measurement</li>
			<li>
			<p align="left"><a href="#ibwrite_lat">ib_write_lat</a>&nbsp;&nbsp;&nbsp;&nbsp; Infiniband RDMA write 
latency measurement</li>
			<li>
			<p align="left">i<a href="#ibwrite_bw">b_write_bw</a>&nbsp;&nbsp;&nbsp; Infiniband RDMA write bandwidth 
measurement</li>
			<li>
			<p align="left"><a href="#ttcp">ttcp</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
TCP performance measurements</li>
		</ul>
		<h4 align="left"><a href="#diags"><font color="#000000">Diagnostics</font></a></h4>
		<ul>
			<li>
			<p align="left"><a href="#cmtest">cmtest&nbsp;</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Connection Manager tests</li>
			<li>
			<p align="left"><a href="#iblimits">ib_limits</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InfiniBand verb tests</li>
			<li>
			<p align="left"><a href="#printip">printIP</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Display 
an Internet Protocol address associated with an IB GUID.</li>
			<li>
			<p align="left"><a href="#vstat">vstat</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Display HCA attributes (lids), statistics and error counters.</li>
			<li>
			<p align="left"><a href="#IBADDR">ibaddr</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Query InfiniBand address(es)</li>
			<li>
			<p align="left"><a href="#IBCACHEEDIT">ibcacheedit</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			Edit the ibnetdiscover cache database</li>
			<li>
			<p align="left"><a href="#IBLINKINFO">iblinkinfo</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			Report link info for all links in the fabric</li>
			<li>
			<p align="left"><a href="#IBNETDISCOVER">ibnetdiscover&nbsp;</a>&nbsp;&nbsp; Generate a fabric 
			topology.</li>
			<li>
			<p align="left"><a href="#IBPING">ibping</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			Ping an InfiniBand address</li>
			<li>
			<p align="left"><a href="#IBPORTSTATE">ibportstate</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			Display InfiniBand port specific information.</li>
			<li>
			<p align="left"><a href="#IBQUERYERRORS">ibqueryerrors</a>&nbsp;&nbsp;&nbsp; Query and report 
			non-zero IB port counters</li>
			<li>
			<p align="left"><a href="#IBROUTE">ibroute</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			Query InfiniBand switch forwarding tables</li>
			<li>
			<p align="left"><a href="#ibstat">ibstat</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Display HCA stats.</li>
			<li>
			<p align="left"><a href="#IBSYSSTAT">ibsysstat</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			System status for an InfiniBand address</li>
			<li>
			<p align="left"><a href="#IBTRACERT">ibtracert</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			Trace InfiniBand path</li>
			<li>
			<p align="left"><a href="#ibv_devinfo">ibv_devinfo</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			Display HCA device information.</li>
			<li>
			<p align="left"><a href="#PERFQUERY">perfquery </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			Query InfiniBand performance counters</li>
			<li>
			<p align="left"><a href="#SAQUERY">saquery</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SA (Subnet Administrator) query test</li>
			<li>
			<p align="left"><a href="#SMINFO">sminfo</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			Query InfiniBand SMInfo attributes</li>
			<li>
			<p align="left"><a href="#SMPDUMP">smpdump</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			Dump InfiniBand subnet management attributes</li>
			<li>
			<p align="left"><a href="#SMPQUERY">smpquery</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			Query InfiniBand subnet management attributes</li>
			<li>
			<p align="left"><a href="#VENDSTAT">vendstat&nbsp;</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Query InfiniBand vendor specific functions</li>
		</ul>
	</blockquote>
</blockquote>
<h4 align="left"><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></h4>
<p align="left">&nbsp;</p>
<h2 align="left"><a name="verbs_benchmarks"></a>User mode micro-benchmarks</h2>
<hr>
<p align="left">The following user-mode test programs are intended as useful 
micro-benchmarks for HW or SW 
tuning and/or functional testing.</p>
<blockquote>
	<p align="left">Tests use CPU cycle counters to get time stamps without 
	context switch.<br>
	<br>Tests measure round-trip time but report half of that as one-way latency<br>
	(i.e.. May not be sufficiently accurate for 
	asymmetrical configurations).<br>
	<br>Min/Median/Max result is reported.<br>The median (vs. average) is less sensitive to extreme scores.<br>Typically the &quot;Max&quot; value is the first value measured.<br>
	<br>larger samples only marginally help. The default (1000) is pretty good.<br>Note that an array of cycles_t (typically unsigned long) is allocated<br>once to collect samples and again to store the difference between them.<br>Really big sample sizes (e.g. 1 million) might expose other problems<br>with the program.<br>
	<br>&quot;-H&quot; option will dump the histogram for additional statistical analysis.<br>See xgraph, ygraph, r-base (http://www.r-project.org/), pspp, or other
	<br>statistical math programs.<br><br>Architectures tested: x86, x86_64, ia64</p>
	<p align="left">Also see <a href="#WinVerbs">winverbs</a> performance tools.</p>
</blockquote>
<h4 align="left"><a name="ibsend_lat"></a><br>
ib_send_lat.exe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - latency test with 
send transactions</h4>
<blockquote>
	<p align="left">Usage:</p>
	<blockquote>
		<p align="left">ib_send_lat start a server and wait for connection<br>
		ib_send_lat &lt;host&gt; connect to server at &lt;host&gt;</p>
	</blockquote>
	<p align="left">Options:</p>
	<blockquote>
		<p align="left">-p, --port=&lt;port&gt; listen on/connect to port &lt;port&gt; 
		(default 18515)<br>
		-c, --connection=&lt;RC/UC&gt; connection type RC/UC (default RC)<br>
		-m, --mtu=&lt;mtu&gt; mtu size (default 2048)<br>
		-d, --ib-dev=&lt;dev&gt; use IB device &lt;dev&gt; (default first device found)<br>
		-i, --ib-port=&lt;port&gt; use port &lt;port&gt; of IB device (default 1)<br>
		-s, --size=&lt;size&gt; size of message to exchange (default 1)<br>
		-t, --tx-depth=&lt;dep&gt; size of tx queue (default 50)<br>
		-l, --signal signal completion on each msg<br>
		-a, --all Run sizes from 2 till 2^23<br>
		-n, --iters=&lt;iters&gt; number of exchanges (at least 2, default 1000)<br>
		-C, --report-cycles report times in cpu cycle units (default 
		microseconds)<br>
		-H, --report-histogram print out all results (default print summary 
		only)<br>
		-U, --report-unsorted (implies -H) print out unsorted results (default 
		sorted)<br>
		-V, --version display version number<br>
		-e, --events sleep on CQ events (default poll)</p>
	</blockquote>
</blockquote>
<h4 align="left"><a name="ibsend_bw"></a><br>
ib_send_bw.exe&nbsp;&nbsp;&nbsp;&nbsp; - BW (BandWidth) test with send transactions</h4>
<blockquote>
	<p align="left">Usage:</p>
	<blockquote>
		<p align="left">ib_send_bw start a server and wait for connection<br>
		ib_send_bw &lt;host&gt; connect to server at 'host'</p>
	</blockquote>
	<p align="left">Options:</p>
	<blockquote>
		<p align="left">-p, --port=&lt;port&gt; listen on/connect to port &lt;port&gt; 
		(default 18515)<br>
		-d, --ib-dev=&lt;dev&gt; use IB device &lt;dev&gt; (default first device found)<br>
		-i, --ib-port=&lt;port&gt; use port &lt;port&gt; of IB device (default 1)<br>
		-c, --connection=&lt;RC/UC&gt; connection type RC/UC/UD (default RC)<br>
		-m, --mtu=&lt;mtu&gt; mtu size (default 1024)<br>
		-s, --size=&lt;size&gt; size of message to exchange (default 65536)<br>
		-a, --all Run sizes from 2 till 2^23<br>
		-t, --tx-depth=&lt;dep&gt; size of tx queue (default 300)<br>
		-n, --iters=&lt;iters&gt; number of exchanges (at least 2, default 1000)<br>
		-b, --bidirectional measure bidirectional bandwidth (default 
		unidirectional)<br>
		-V, --version display version number<br>
		-e, --events sleep on CQ events (default poll)</p>
	</blockquote>
</blockquote>
<h4 align="left"><a name="ibwrite_lat"></a><br>
ib_write_lat.exe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - latency test with RDMA write 
transactions</h4>
<blockquote>
	<p align="left">Usage:</p>
	<blockquote>
		<p align="left">ib_write_lat start a server and wait for connection<br>
		ib_write_lat &lt;host&gt; connect to server at &lt;host&gt;</p>
	</blockquote>
	<p align="left">Options:</p>
	<blockquote>
		<p align="left">-p, --port=&lt;port&gt; listen on/connect to port &lt;port&gt; 
		(default 18515)<br>
		-c, --connection=&lt;RC/UC&gt; connection type RC/UC (default RC)<br>
		-m, --mtu=&lt;mtu&gt; mtu size (default 1024)<br>
		-d, --ib-dev=&lt;dev&gt; use IB device &lt;dev&gt; (default first device found)<br>
		-i, --ib-port=&lt;port&gt; use port &lt;port&gt; of IB device (default 1)<br>
		-s, --size=&lt;size&gt; size of message to exchange (default 1)<br>
		-a, --all Run sizes from 2 till 2^23<br>
		-t, --tx-depth=&lt;dep&gt; size of tx queue (default 50)<br>
		-n, --iters=&lt;iters&gt; number of exchanges (at least 2, default 1000)<br>
		-C, --report-cycles report times in cpu cycle units (default 
		microseconds)<br>
		-H, --report-histogram print out all results (default print summary 
		only)<br>
		-U, --report-unsorted (implies -H) print out unsorted results (default 
		sorted)<br>
		-V, --version display version number</p>
	</blockquote>
</blockquote>
<h4 align="left"><a name="ibwrite_bw"></a><br>
ib_write_bw.exe&nbsp;&nbsp;&nbsp;&nbsp; - BW test with RDMA write transactions</h4>
<blockquote>
	<p align="left">Usage:</p>
	<blockquote>
		<p align="left">ib_write_bw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		# start a server and wait for connection<br>
		ib_write_bw &lt;host&gt;&nbsp;&nbsp;&nbsp; # connect to server at &lt;host&gt;</p>
	</blockquote>
	<p align="left">Options:</p>
	<blockquote>
		<p align="left">-p, --port=&lt;port&gt; listen on/connect to port &lt;port&gt; 
		(default 18515)<br>
		-d, --ib-dev=&lt;dev&gt; use IB device &lt;dev&gt; (default first device found)<br>
		-i, --ib-port=&lt;port&gt; use port &lt;port&gt; of IB device (default 1)<br>
		-c, --connection=&lt;RC/UC&gt; connection type RC/UC (default RC)<br>
		-m, --mtu=&lt;mtu&gt; mtu size (default 1024)<br>
		-g, --post=&lt;num of posts&gt; number of posts for each qp in the chain 
		(default tx_depth)<br>
		-q, --qp=&lt;num of qp's&gt; Num of qp's(default 1)<br>
		-s, --size=&lt;size&gt; size of message to exchange (default 65536)<br>
		-a, --all Run sizes from 2 till 2^23<br>
		-t, --tx-depth=&lt;dep&gt; size of tx queue (default 100)<br>
		-n, --iters=&lt;iters&gt; number of exchanges (at least 2, default 5000)<br>
		-b, --bidirectional measure bidirectional bandwidth (default 
		unidirectional)<br>
		-V, --version display version number</p>
	</blockquote>
</blockquote>
<h4 align="left"><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></h4>
<p align="left"><br>
&nbsp;</p>
<h4 align="left"><a name="ttcp"></a><br>
ttcp - Test TCP performance</h4>
<p align="left">TTCP accesses the Windows socket layer, hence it does not access 
IB verbs directly. IPoIB or WSD layers are invoked beneath the socket layer 
depending on configuration. TTCP is included as a quick baseline performance 
check.</p>
<blockquote>
	<pre>Usage: ttcp -t [-options] host 
       ttcp -r [-options]
Common options:
	-l ##	length of bufs read from or written to network (default 8192)
	-u	use UDP instead of TCP
	-p ##	port number to send to or listen at (default 5001)
	-A	align the start of buffers to this modulus (default 16384)
	-O	start buffers at this offset from the modulus (default 0)
	-d	set SO_DEBUG socket option
	-b ##	set socket buffer size (if supported)
	-f X	format for rate: k,K = kilo{bit,byte}; m,M = mega; g,G = giga
Options specific to -t:
	-n##	number of source bufs written to network (default 2048)
	-D	don't buffer TCP writes (sets TCP_NODELAY socket option)
Options specific to -r:
	-B	for -s, only output full blocks as specified by -l (for TAR)
	-T	&quot;touch&quot;: access each byte as it's read</pre>
	<p align="left">Requires a receiver (server) side and a transmitter (client) 
	side, host1 and host2 are IPoIB connected hosts.</p>
	<p align="left">at host1 (receiver)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	ttcp -r -f M -l 4096</p>
	<p align="left">at host2 (transmitter)&nbsp;&nbsp;&nbsp; ttcp -t -f M -l 
	4096 -n1000 host1</p>
</blockquote>
<h4 align="left"><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></h4>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<h2 align="left"><a name="diags"></a>Diagnostics</h2>
<hr>
<BLOCKQUOTE></BLOCKQUOTE>
<h3 align="left"><a name="IBADDR">IBADDR</a>(8) OFED Diagnostics</h3>
<p align="left">NAME<br>
ibaddr - query InfiniBand address(es)<br>
<br>
SYNOPSIS<br>
ibaddr [-d(ebug)] [-D(irect)] [-G(uid)] [-l(id_show)] [-g(id_show)] [-C
ca_name] [-P ca_port] [-t(imeout) timeout_ms] [-V(ersion)] [-h(elp)]
[&lt;lid | dr_path | guid&gt;]<br>
<br>
DESCRIPTION<br>
Display the lid (and range) as well as the GID address of the port<br>
specified (by DR path, lid, or GUID) or the local port by default.<br>
<br>
Note: this utility can be used as simple address resolver.<br>
<br>
OPTIONS<br>
-G, --Guid<br>
show lid range and gid for GUID address<br>
<br>
-l, --lid_show<br>
show lid range only<br>
<br>
-L, --Lid_show<br>
show lid range (in decimal) only<br>
<br>
-g, --gid_show<br>
show gid address only<br>
<br>
<br>
COMMON OPTIONS<br>
Most OFED diagnostics take the following common flags. The exact list<br>
of supported flags per utility can be found in the usage message and<br>
can be shown using the util_name -h syntax.<br>
<br>
# Debugging flags<br>
<br>
-d raise the IB debugging level.<br>
May be used several times (-ddd or -d -d -d).<br>
<br>
-e show send and receive errors (timeouts and others)<br>
<br>
-h show the usage message<br>
<br>
-v increase the application verbosity level.<br>
May be used several times (-vv or -v -v -v)<br>
<br>
-V show the version info.<br>
<br>
# Addressing flags<br>
<br>
-D use directed path address arguments. The path<br>
is a comma separated list of out ports.<br>
Examples:<br>
&quot;0&quot; # self port<br>
&quot;0,1,2,1,4&quot; # out via port 1, then 2, ...<br>
<br>
-G use GUID address argument. In most cases, it is the Port GUID.<br>
Example:<br>
&quot;0x08f1040023&quot;<br>
<br>
-s &lt;smlid&gt; use ’smlid’ as the target lid for SM/SA queries.<br>
<br>
# Other common flags:<br>
<br>
-C &lt;ca_name&gt; use the specified ca_name.<br>
<br>
-P &lt;ca_port&gt; use the specified ca_port.<br>
<br>
-t &lt;timeout_ms&gt; override the default timeout for the solicited mads.<br>
<br>
Multiple CA/Multiple Port Support<br>
<br>
When no IB device or port is specified, the port to use is selected by<br>
the following criteria:<br>
<br>
1. the first port that is ACTIVE.<br>
<br>
2. if not found, the first port that is UP (physical link up).<br>
<br>
If a port and/or CA name is specified, the user request is attempted to<br>
be fulfilled, and will fail if it is not possible.<br>
<br>
<br>
EXAMPLES<br>
ibaddr # local port´s address<br>
<br>
ibaddr 32 # show lid range and gid of lid 32<br>
<br>
ibaddr -G 0x8f1040023 # same but using guid address<br>
<br>
ibaddr -l 32 # show lid range only<br>
<br>
ibaddr -L 32 # show decimal lid range only<br>
<br>
ibaddr -g 32 # show gid address only<br>
<br>
<br>
SEE ALSO<br>
ibroute(8), ibtracert(8)<br>
<br>
AUTHOR<br>
Hal Rosenstock<br>
&lt;halr@voltaire.com&gt;<br>
<br>
<br>
OFED June 18, 2007 IBADDR(8)<br>
&nbsp;</p>
<h3 align="left">&nbsp;</h3>
<h3 align="left"><a name="IBLINKINFO">IBLINKINFO</a>(8) OFED Diagnostics<br>
&nbsp;</h3>
<p align="left">NAME<br>
iblinkinfo - report link info for all links in the fabric<br>
<br>
<br>
SYNOPSIS<br>
iblinkinfo
[-Rhcdl -C &lt;ca_name&gt; -P &lt;ca_port&gt; -v &lt;lt,hoq,vlstall&gt; -S &lt;guid&gt; -D&lt;direct_route&gt;]<br>
<br>
<br>
DESCRIPTION<br>
iblinkinfo reports the link info for each port of each switch active<br>
in the IB fabric.<br>
<br>
<br>
OPTIONS<br>
-R Recalculate the ibnetdiscover information, ie do not use the<br>
cached information. This option is slower but should be used if<br>
the diag tools have not been used for some time or if there are<br>
other reasons to believe the fabric has changed.<br>
<br>
-S &lt;guid&gt;<br>
Output only the switch specified by &lt;guid&gt; (hex format)<br>
<br>
-D &lt;direct_route&gt;<br>
Output only the switch specified by the direct route path.<br>
<br>
-l Print all information for each link on one line. Default is to<br>
print a header with the switch information and then a list for<br>
each port (useful for grep´ing output).<br>
<br>
-d Print only switches which have a port in the &quot;Down&quot; state.<br>
<br>
-v &lt;lt,hoq,vlstall&gt;<br>
Verify additional switch settings (&lt;Life-<br>
Time&gt;,&lt;HoqLife&gt;,&lt;VLStallCount&gt;)<br>
<br>
-c Print port capabilities (enabled and supported values)<br>
<br>
-C &lt;ca_name&gt; use the specified ca_name for the search.<br>
<br>
-P &lt;ca_port&gt; use the specified ca_port for the search.<br>
<br>
<br>
<br>
AUTHOR<br>
Ira Weiny &lt;weiny2@llnl.gov&gt;<br>
<br>
<br>
OFED Jan 24, 2008 IBLINKINFO(8)</p>
<p align="left"><font color="#000000"><a href="#TOP">&lt;return-to-top&gt;</a></font><br>
&nbsp;</p>
<p align="left">&nbsp;</p>
<h3 align="left"><a name="IBNETDISCOVER">IBNETDISCOVER</a>(8) OFED Diagnostics<br>
&nbsp;</h3>
<p align="left">NAME<br>
ibnetdiscover - discover InfiniBand topology<br>
<br>
SYNOPSIS<br>
ibnetdiscover [-d(ebug)] [-e(rr_show)] [-v(erbose)] [-s(how)] [-l(ist)]<br>
[-g(rouping)] [-H(ca_list)] [-S(witch_list)] [-R(outer_list)] [-C<br>
ca_name] [-P ca_port] [-t(imeout) timeout_ms] [-V(ersion)]<br>
[--node-name-map &lt;node-name-map&gt;] [-p(orts)] [-h(elp)] [&lt;topology-file&gt;]<br>
<br>
DESCRIPTION<br>
ibnetdiscover performs IB subnet discovery and outputs a human readable<br>
topology file. GUIDs, node types, and port numbers are displayed as<br>
well as port LIDs and NodeDescriptions. All nodes (and links) are dis-<br>
played (full topology). Optionally, this utility can be used to list<br>
the current connected nodes by nodetype. The output is printed to<br>
standard output unless a topology file is specified.<br>
<br>
OPTIONS<br>
-l, --list<br>
List of connected nodes<br>
<br>
-g, --grouping<br>
Show grouping. Grouping correlates IB nodes by different vendor<br>
specific schemes. It may also show the switch external ports<br>
correspondence.<br>
<br>
-H, --Hca_list<br>
List of connected CAs<br>
<br>
-S, --Switch_list<br>
List of connected switches<br>
<br>
-R, --Router_list<br>
List of connected routers<br>
<br>
-s, --show<br>
Show progress information during discovery.<br>
<br>
--node-name-map &lt;node-name-map&gt;<br>
Specify a node name map. The node name map file maps GUIDs to<br>
more user friendly names. See <a href="#NODE_NAME_MAP_FILE_FORMAT">file format</a> below.<br>
<br>
-p, --ports<br>
Obtain a ports report which is a list of connected ports with<br>
relevant information (like LID, portnum, GUID, width, speed, and<br>
NodeDescription).<br>
<br>
<br>
COMMON OPTIONS<br>
Most OpenIB diagnostics take the following common flags. The exact list<br>
of supported flags per utility can be found in the usage message and<br>
can be shown using the util_name -h syntax.<br>
<br>
# Debugging flags<br>
<br>
-d raise the IB debugging level.<br>
May be used several times (-ddd or -d -d -d).<br>
<br>
-e show send and receive errors (timeouts and others)<br>
<br>
-h show the usage message<br>
<br>
-v increase the application verbosity level.<br>
May be used several times (-vv or -v -v -v)<br>
<br>
-V show the version info.<br>
<br>
# Other common flags:<br>
<br>
-C &lt;ca_name&gt; use the specified ca_name.<br>
<br>
-P &lt;ca_port&gt; use the specified ca_port.<br>
<br>
-t &lt;timeout_ms&gt; override the default timeout for the solicited mads.<br>
<br>
Multiple CA/Multiple Port Support<br>
<br>
When no IB device or port is specified, the port to use is selected by<br>
the following criteria:<br>
<br>
1. the first port that is ACTIVE.<br>
<br>
2. if not found, the first port that is UP (physical link up).<br>
<br>
If a port and/or CA name is specified, the user request is attempted to<br>
be fulfilled, and will fail if it is not possible.<br>
<br>
<br>
TOPOLOGY FILE FORMAT<br>
The topology file format is human readable and largely intuitive. Most<br>
identifiers are given textual names like vendor ID (vendid), device ID<br>
(device ID), GUIDs of various types (sysimgguid, caguid, switchguid,<br>
etc.). PortGUIDs are shown in parentheses (). For switches, this is<br>
shown on the switchguid line. For CA and router ports, it is shown on<br>
the connectivity lines. The IB node is identified followed by the num-<br>
ber of ports and a quoted the node GUID. On the right of this line is<br>
a comment (#) followed by the NodeDescription in quotes. If the node<br>
is a switch, this line also contains whether switch port 0 is base or<br>
enhanced, and the LID and LMC of port 0. Subsequent lines pertaining<br>
to this node show the connectivity. On the left is the port number of<br>
the current node. On the right is the peer node (node at other end of<br>
link). It is identified in quotes with nodetype followed by - followed<br>
by NodeGUID with the port number in square brackets. Further on the<br>
right is a comment (#). What follows the comment is dependent on the<br>
node type. If it it a switch node, it is followed by the NodeDescrip-<br>
tion in quotes and the LID of the peer node. If it is a CA or router<br>
node, it is followed by the local LID and LMC and then followed by the<br>
NodeDescription in quotes and the LID of the peer node. The active<br>
link width and speed are then appended to the end of this output line.<br>
<br>
An example of this is:<br>
#<br>
# Topology file: generated on Tue Jun 5 14:15:10 2007<br>
#<br>
# Max of 3 hops discovered<br>
# Initiated from node 0008f10403960558 port 0008f10403960559<br>
<br>
Non-Chassis Nodes<br>
<br>
vendid=0x8f1<br>
devid=0x5a06<br>
sysimgguid=0x5442ba00003000<br>
switchguid=0x5442ba00003080(5442ba00003080)<br>
Switch 24 &quot;S-005442ba00003080&quot; # &quot;ISR9024 Voltaire&quot; base port 0 lid 6 lmc 0<br>
[22] &quot;H-0008f10403961354&quot;[1](8f10403961355) # &quot;MT23108 InfiniHost Mellanox 
Technologies&quot; lid 4 4xSDR<br>
[10] &quot;S-0008f10400410015&quot;[1] # &quot;SW-6IB4 Voltaire&quot; lid 3 4xSDR<br>
[8] &quot;H-0008f10403960558&quot;[2](8f1040396055a) # &quot;MT23108 InfiniHost Mellanox 
Technologies&quot; lid 14 4xSDR<br>
[6] &quot;S-0008f10400410015&quot;[3] # &quot;SW-6IB4 Voltaire&quot; lid 3 4xSDR<br>
[12] &quot;H-0008f10403960558&quot;[1](8f10403960559) # &quot;MT23108 InfiniHost Mellanox 
Technologies&quot; lid 10 4xSDR<br>
<br>
vendid=0x8f1<br>
devid=0x5a05<br>
switchguid=0x8f10400410015(8f10400410015)<br>
Switch 8 &quot;S-0008f10400410015&quot; # &quot;SW-6IB4 Voltaire&quot; base port 0 lid 3 lmc 0<br>
[6] &quot;H-0008f10403960984&quot;[1](8f10403960985) # &quot;MT23108 InfiniHost Mellanox 
Technologies&quot; lid 16 4xSDR<br>
[4] &quot;H-005442b100004900&quot;[1](5442b100004901) # &quot;MT23108 InfiniHost Mellanox 
Technologies&quot; lid 12 4xSDR<br>
[1] &quot;S-005442ba00003080&quot;[10] # &quot;ISR9024 Voltaire&quot; lid 6 1xSDR<br>
[3] &quot;S-005442ba00003080&quot;[6] # &quot;ISR9024 Voltaire&quot; lid 6 4xSDR<br>
<br>
vendid=0x2c9<br>
devid=0x5a44<br>
caguid=0x8f10403960984<br>
Ca 2 &quot;H-0008f10403960984&quot; # &quot;MT23108 InfiniHost Mellanox Technologies&quot;<br>
[1](8f10403960985) &quot;S-0008f10400410015&quot;[6] # lid 16 lmc 1 &quot;SW-6IB4 Voltaire&quot; lid 
3 4xSDR<br>
<br>
vendid=0x2c9<br>
devid=0x5a44<br>
caguid=0x5442b100004900<br>
Ca 2 &quot;H-005442b100004900&quot; # &quot;MT23108 InfiniHost Mellanox Technologies&quot;<br>
[1](5442b100004901) &quot;S-0008f10400410015&quot;[4] # lid 12 lmc 1 &quot;SW-6IB4 Voltaire&quot; 
lid 3 4xSDR<br>
<br>
vendid=0x2c9<br>
devid=0x5a44<br>
caguid=0x8f10403961354<br>
Ca 2 &quot;H-0008f10403961354&quot; # &quot;MT23108 InfiniHost Mellanox Technologies&quot;<br>
[1](8f10403961355) &quot;S-005442ba00003080&quot;[22] # lid 4 lmc 1 &quot;ISR9024 Voltaire&quot; lid 
6 4xSDR<br>
<br>
vendid=0x2c9<br>
devid=0x5a44<br>
caguid=0x8f10403960558<br>
Ca 2 &quot;H-0008f10403960558&quot; # &quot;MT23108 InfiniHost Mellanox Technologies&quot;<br>
[2](8f1040396055a) &quot;S-005442ba00003080&quot;[8] # lid 14 lmc 1 &quot;ISR9024 Voltaire&quot; lid 
6 4xSDR<br>
[1](8f10403960559) &quot;S-005442ba00003080&quot;[12] # lid 10 lmc 1 &quot;ISR9024 Voltaire&quot; 
lid 6 1xSDR<br>
<br>
When grouping is used, IB nodes are organized into chasses which are<br>
numbered. Nodes which cannot be determined to be in a chassis are dis-<br>
played as &quot;Non-Chassis Nodes&quot;. External ports are also shown on the<br>
connectivity lines.<br>
<br>
<br>
<a name="NODE_NAME_MAP_FILE_FORMAT">NODE NAME MAP FILE FORMAT</a><br>
The node name map is used to specify user friendly names for nodes in<br>
the output. GUIDs are used to perform the lookup.<br>
<br>
Generically:<br>
<br>
# comment<br>
0x&lt;guid&gt; &quot;&lt;name&gt;&quot;<br>
<br>
Example:<br>
<br>
# IB1<br>
# Line cards<br>
0x0008f104003f125c &quot;IB1 (Rack 11 slot 1 ) ISR9288/ISR9096
Voltaire sLB-24D&quot;<br>
0x0008f104003f125d &quot;IB1 (Rack 11 slot 1 ) ISR9288/ISR9096
Voltaire sLB-24D&quot;<br>
0x0008f104003f10d2 &quot;IB1 (Rack 11 slot 2 ) ISR9288/ISR9096
Voltaire sLB-24D&quot;<br>
0x0008f104003f10d3 &quot;IB1 (Rack 11 slot 2 ) ISR9288/ISR9096
Voltaire sLB-24D&quot;<br>
0x0008f104003f10bf &quot;IB1 (Rack 11 slot 12 ) ISR9288/ISR9096
Voltaire sLB-24D&quot;<br>
# Spines<br>
0x0008f10400400e2d &quot;IB1 (Rack 11 spine 1 ) ISR9288 Voltaire
sFB-12D&quot;<br>
0x0008f10400400e2e &quot;IB1 (Rack 11 spine 1 ) ISR9288 Voltaire
sFB-12D&quot;<br>
0x0008f10400400e2f &quot;IB1 (Rack 11 spine 1 ) ISR9288 Voltaire
sFB-12D&quot;<br>
0x0008f10400400e31 &quot;IB1 (Rack 11 spine 2 ) ISR9288 Voltaire
sFB-12D&quot;<br>
0x0008f10400400e32 &quot;IB1 (Rack 11 spine 2 ) ISR9288 Voltaire
sFB-12D&quot;<br>
# GUID Node Name<br>
0x0008f10400411a08 &quot;SW1 (Rack 3) ISR9024 Voltaire 9024D&quot;<br>
0x0008f10400411a28 &quot;SW2 (Rack 3) ISR9024 Voltaire 9024D&quot;<br>
0x0008f10400411a34 &quot;SW3 (Rack 3) ISR9024 Voltaire 9024D&quot;<br>
0x0008f104004119d0 &quot;SW4 (Rack 3) ISR9024 Voltaire 9024D&quot;<br>
<br>
<br>
AUTHORS<br>
Hal Rosenstock&nbsp;&nbsp;&nbsp; &lt;halr@voltaire.com&gt;<br>
Ira Weiny&nbsp;&nbsp;&nbsp; &lt;weiny2@llnl.gov&gt;<br>
<br>
<br>
OFED January 3, 2008 IBNETDISCOVER(8)<br>
<br>
<font color="#000000"><a href="#TOP">&lt;return-to-top&gt;</a></font><br>
&nbsp;</p>
<p align="left">&nbsp;</p>
<H2><a name="IBCACHEEDIT">IBCACHEEDIT</a>(8) OFED Diagnostics</H2>

NAME<p>ibcacheedit - edit an ibnetdiscover cache </p>
<p>&nbsp;</p>
<p>SYNOPSIS</p>

<B>ibcacheedit</B>

[--switchguid BEFOREGUID:AFTERGUID] [--caguid BEFORE:AFTER]
[--sysimgguid BEFOREGUID:AFTERGUID] [--portguid NODEGUID:BEFOREGUID:AFTERGUID]
[-h(elp)] &lt;orig.cache&gt; &lt;new.cache&gt;
<p>&nbsp;</p>
<p>DESCRIPTION</p>

<P>

ibcacheedit allows users to edit an ibnetdiscover cache created through the
<B>--cache</B> option in
<B><a href="#IBNETDISCOVER">ibnetdiscover</a>.</B>

<P>

&nbsp;<p>OPTIONS</p>

<P>
<P>

<DL COMPACT>
<DT><B>--switchguid</B> BEFOREGUID:AFTERGUID<DD>
Specify a switchguid that should be changed.  The before and after guid
should be separated by a colon.  On switches, port guids are identical
to the switch guid, so port guids will be adjusted as well on switches.
<DT><B>--caguid</B> BEFOREGUID:AFTERGUID<DD>
Specify a caguid that should be changed.  The before and after guid
should be separated by a colon.
<DT><B>--sysimgguid</B> BEFOREGUID:AFTERGUID<DD>
Specify a sysimgguid that should be changed.  The before and after guid
should be spearated by a colon.
<DT><B>--portguid</B> NODEGUID:BEFOREGUID:AFTERGUID<DD>
Specify a portguid that should be changed.  The nodeguid of the port
(e.g. switchguid or caguid) should be specified first, followed by a
colon, the before port guid, another colon, then the after port guid.
On switches, port guids are identical to the switch guid, so the
switch guid will be adjusted as well on switches.
<P>
</DL>
&nbsp;<p>COMMON OPTIONS</p>

<P>
Most OpenIB diagnostics take the following common flags. The exact list of
supported flags per utility can be found in the usage message and can be shown
using the util_name -h syntax.
<P>
# Debugging flags
<P>

-h      show the usage message
<P>

-V      show the version info.<P>

&nbsp;<p>AUTHORS</p>

<DL COMPACT>
<DT>Albert Chu<DD>
&lt;<I><A HREF="mailto:chu11@llnl.gov">chu11@llnl.gov</A></I>&gt;

</DL>

<p align="left">&nbsp;</p>
<p align="left">
<font color="#000000"><a href="#TOP">&lt;return-to-top&gt;</a></font></p>
<p align="left">&nbsp;</p>
<h3 align="left"><a name="IBPING">IBPING</a>(8) OFED Diagnostics<br>
&nbsp;</h3>
<p align="left">NAME<br>
ibping - ping an InfiniBand address<br>
<br>
<br>
SYNOPSIS<br>
ibping [-d(ebug)] [-e(rr_show)] [-v(erbose)] [-G(uid)] [-C ca_name] [-P<br>
ca_port] [-s smlid] [-t(imeout) timeout_ms] [-V(ersion)] [-c<br>
ping_count] [-f(lood)] [-o oui] [-S(erver)] [-h(elp)] &lt;dest lid | guid&gt;<br>
<br>
<br>
DESCRIPTION<br>
ibping uses vendor mads to validate connectivity between IB nodes. On<br>
exit, (IP) ping like output is show. ibping is run as client/server.<br>
Default is to run as client. Note also that a default ping server is<br>
implemented within the kernel.<br>
<br>
<br>
OPTIONS<br>
-c stop after count packets<br>
<br>
-f, --flood<br>
flood destination: send packets back to back without delay<br>
<br>
-o, --oui<br>
use specified OUI number to multiplex vendor mads<br>
<br>
-S, --Server<br>
start in server mode (do not return)<br>
<br>
<br>
COMMON OPTIONS<br>
Most OFED diagnostics take the following common flags. The exact list<br>
of supported flags per utility can be found in the usage message and<br>
can be shown using the util_name -h syntax.<br>
<br>
# Debugging flags<br>
<br>
-d raise the IB debugging level.<br>
May be used several times (-ddd or -d -d -d).<br>
<br>
-e show send and receive errors (timeouts and others)<br>
<br>
-h show the usage message<br>
<br>
-v increase the application verbosity level.<br>
May be used several times (-vv or -v -v -v)<br>
<br>
-V show the version info.<br>
<br>
# Addressing flags<br>
<br>
-G use GUID address argument. In most cases, it is the Port GUID.<br>
Example:<br>
&quot;0x08f1040023&quot;<br>
<br>
-s &lt;smlid&gt; use ’smlid’ as the target lid for SM/SA queries.<br>
<br>
# Other common flags:<br>
<br>
-C &lt;ca_name&gt; use the specified ca_name.<br>
<br>
-P &lt;ca_port&gt; use the specified ca_port.<br>
<br>
-t &lt;timeout_ms&gt; override the default timeout for the solicited mads.<br>
<br>
Multiple CA/Multiple Port Support<br>
<br>
When no IB device or port is specified, the port to use is selected by<br>
the following criteria:<br>
<br>
1. the first port that is ACTIVE.<br>
<br>
2. if not found, the first port that is UP (physical link up).<br>
<br>
If a port and/or CA name is specified, the user request is attempted to<br>
be fulfilled, and will fail if it is not possible.<br>
<br>
<br>
AUTHOR<br>
Hal Rosenstock &lt;halr@voltaire.com&gt;<br>
<br>
<br>
OFED August 11, 2006 IBPING(8)</p>
<p align="left"><br>
<font color="#000000"><a href="#TOP">&lt;return-to-top&gt;</a></font></p>
<h3 align="left">&nbsp;</h3>
<h3 align="left"><a name="IBPORTSTATE">IBPORTSTATE</a>(8) OFED Diagnostics</h3>
<p align="left"><br>
NAME<br>
ibportstate - handle port (physical) state and link speed of an Infini-<br>
Band port<br>
<br>
<br>
SYNOPSIS<br>
ibportstate [-d(ebug)] [-e(rr_show)] [-v(erbose)] [-D(irect)] [-G(uid)] [-s 
smlid] [-V(ersion)] [-C ca_name] [-P ca_port] [-t(imeout) time-out_ms] [-h(elp)] 
&lt;dest dr_path|lid|guid&gt; &lt;portnum&gt; [&lt;op&gt;]<br>
<br>
<br>
DESCRIPTION<br>
ibportstate allows the port state and port physical state of an IB port<br>
to be queried (in addition to link width and speed being validated rel-<br>
ative to the peer port when the port queried is a switch port), or a<br>
switch port to be disabled, enabled, or reset. It also allows the link<br>
speed enabled on any IB port to be adjusted.<br>
<br>
<br>
OPTIONS<br>
op Port operations allowed<br>
supported ops: enable, disable, reset, speed, query<br>
Default is query<br>
<br>
ops enable, disable, and reset are only allowed on switch ports<br>
(An error is indicated if attempted on CA or router ports)<br>
speed op is allowed on any port<br>
speed values are legal values for PortInfo:LinkSpeedEnabled<br>
(An error is indicated if PortInfo:LinkSpeedSupported does not support<br>
this setting)<br>
(NOTE: Speed changes are not effected until the port goes through<br>
link renegotiation)<br>
query also validates port characteristics (link width and speed)<br>
based on the peer port. This checking is done when the port<br>
queried is a switch port as it relies on combined routing<br>
(an initial LID route with directed routing to the peer) which<br>
can only be done on a switch. This peer port validation feature<br>
of query op requires LID routing to be functioning in the subnet.<br>
<br>
<br>
COMMON OPTIONS<br>
Most OFED diagnostics take the following common flags. The exact list<br>
of supported flags per utility can be found in the usage message and<br>
can be shown using the util_name -h syntax.<br>
<br>
# Debugging flags<br>
<br>
-d raise the IB debugging level.<br>
May be used several times (-ddd or -d -d -d).<br>
<br>
-e show send and receive errors (timeouts and others)<br>
<br>
-h show the usage message<br>
<br>
-v increase the application verbosity level.<br>
May be used several times (-vv or -v -v -v)<br>
<br>
-V show the version info.<br>
<br>
# Addressing flags<br>
<br>
-D use directed path address arguments. The path<br>
is a comma separated list of out ports.<br>
Examples:<br>
&quot;0&quot; # self port<br>
&quot;0,1,2,1,4&quot; # out via port 1, then 2, ...<br>
<br>
-G use GUID address argument. In most cases, it is the Port GUID.<br>
Example:<br>
&quot;0x08f1040023&quot;<br>
<br>
-s &lt;smlid&gt; use ’smlid’ as the target lid for SM/SA queries.<br>
<br>
# Other common flags:<br>
<br>
-C &lt;ca_name&gt; use the specified ca_name.<br>
<br>
-P &lt;ca_port&gt; use the specified ca_port.<br>
<br>
-t &lt;timeout_ms&gt; override the default timeout for the solicited mads.<br>
<br>
Multiple CA/Multiple Port Support<br>
<br>
When no IB device or port is specified, the port to use is selected by<br>
the following criteria:<br>
<br>
1. the first port that is ACTIVE.<br>
<br>
2. if not found, the first port that is UP (physical link up).<br>
<br>
If a port and/or CA name is specified, the user request is attempted to<br>
be fulfilled, and will fail if it is not possible.<br>
<br>
<br>
EXAMPLES<br>
ibportstate 3 1 disable # by lid<br>
<br>
ibportstate -G 0x2C9000100D051 1 enable # by guid<br>
<br>
ibportstate -D 0 1 # (query) by direct route<br>
<br>
ibportstate 3 1 reset # by lid<br>
<br>
ibportstate 3 1 speed 1 # by lid<br>
<br>
<br>
AUTHOR<br>
Hal Rosenstock &lt;halr@voltaire.com&gt;<br>
<br>
<br>
OFED October 19, 2006 IBPORTSTATE(8)</p>
<p align="left"><br>
<font color="#000000"><a href="#TOP">&lt;return-to-top&gt;</a></font></p>
<h3 align="left">&nbsp;</h3>
<h3 align="left"><a name="IBQUERYERRORS">IBQUERYERRORS</a>(8) OFED Diagnostics<br>
&nbsp;</h3>
<p align="left">NAME<br>
ibqueryerrors - query and report non-zero IB port counters<br>
<br>
<br>
SYNOPSIS<br>
ibqueryerrors [-a -c -r -R -C &lt;ca_name&gt; -P &lt;ca_port&gt; -s<br>
&lt;err1,err2,...&gt; -S &lt;switch_guid&gt; -D &lt;direct_route&gt; -d]<br>
<br>
<br>
DESCRIPTION<br>
ibqueryerrors reports the port counters of switches. This is simi-<br>
lar to ibcheckerrors with the additional ability to filter out selected<br>
errors, include the optional transmit and receive data counters, report<br>
actions to remedy a non-zero count, and report full link information<br>
for the link reported.<br>
<br>
<br>
OPTIONS<br>
-a Report an action to take. Some of the counters are not errors<br>
in and of themselves. This reports some more information on<br>
what the counters mean and what actions can/should be taken if<br>
they are non-zero.<br>
<br>
-c Suppress some of the common &quot;side effect&quot; counters. These coun-<br>
ters usually do not indicate an error condition and can be usu-<br>
ally be safely ignored.<br>
<br>
-r Report the port information. This includes LID, port, external<br>
port (if applicable), link speed setting, remote GUID, remote<br>
port, remote external port (if applicable), and remote node<br>
description information.<br>
<br>
-R Recalculate the ibnetdiscover information, ie do not use the<br>
cached information. This option is slower but should be used if<br>
the diag tools have not been used for some time or if there are<br>
other reasons to believe that the fabric has changed.<br>
<br>
-s &lt;err1,err2,...&gt;<br>
Suppress the errors listed in the comma separated list provided.<br>
<br>
-S &lt;switch_guid&gt;<br>
Report results only for the switch specified. (hex format)<br>
<br>
-D &lt;direct_route&gt;<br>
Report results only for the switch specified by the direct route<br>
path.<br>
<br>
-d Include the optional transmit and receive data counters.<br>
<br>
-C &lt;ca_name&gt; use the specified ca_name for the search.<br>
<br>
-P &lt;ca_port&gt; use the specified ca_port for the search.<br>
<br>
AUTHOR<br>
Ira Weiny &lt;weiny2@llnl.gov&gt;<br>
<br>
<br>
OFED Jan 24, 2008 IBQUERYERRORS(8)</p>
<p align="left"><br>
<font color="#000000"><a href="#TOP">&lt;return-to-top&gt;</a></font></p>
<h3 align="left">&nbsp;</h3>
<h3 align="left"><a name="IBROUTE">IBROUTE</a>(8) OFED Diagnostics<br>
&nbsp;</h3>
<p align="left">NAME<br>
ibroute - query InfiniBand switch forwarding tables<br>
<br>
<br>
SYNOPSIS<br>
ibroute [-d(ebug)] [-a(ll)] [-n(o_dests)] [-v(erbose)] [-D(irect)]<br>
[-G(uid)] [-M(ulticast)] [-s smlid] [-C ca_name] [-P ca_port] [-t(ime-<br>
out) timeout_ms] [-V(ersion)] [-h(elp)] [&lt;dest dr_path|lid|guid&gt;<br>
[&lt;startlid&gt; [&lt;endlid&gt;]]]<br>
<br>
<br>
DESCRIPTION<br>
ibroute uses SMPs to display the forwarding tables (unicast (LinearFor-<br>
wardingTable or LFT) or multicast (MulticastForwardingTable or MFT))<br>
for the specified switch LID and the optional lid (mlid) range. The<br>
default range is all valid entries in the range 1...FDBTop.<br>
<br>
<br>
OPTIONS<br>
-a, --all<br>
show all lids in range, even invalid entries<br>
<br>
-n, --no_dests<br>
do not try to resolve destinations<br>
<br>
-M, --Multicast<br>
show multicast forwarding tables In this case, the range parame-<br>
ters are specifying the mlid range.<br>
<br>
<br>
COMMON OPTIONS<br>
Most OFED diagnostics take the following common flags. The exact list<br>
of supported flags per utility can be found in the usage message and<br>
can be shown using the util_name -h syntax.<br>
<br>
# Debugging flags<br>
<br>
-d raise the IB debugging level.<br>
May be used several times (-ddd or -d -d -d).<br>
<br>
-e show send and receive errors (timeouts and others)<br>
<br>
-h show the usage message<br>
<br>
-v increase the application verbosity level.<br>
May be used several times (-vv or -v -v -v)<br>
<br>
-V show the version info.<br>
<br>
# Addressing flags<br>
<br>
-D use directed path address arguments. The path<br>
is a comma separated list of out ports.<br>
Examples:<br>
&quot;0&quot; # self port<br>
&quot;0,1,2,1,4&quot; # out via port 1, then 2, ...<br>
<br>
-G use GUID address argument. In most cases, it is the Port GUID.<br>
Example:<br>
&quot;0x08f1040023&quot;<br>
<br>
-s &lt;smlid&gt; use ’smlid’ as the target lid for SM/SA queries.<br>
<br>
# Other common flags:<br>
<br>
-C &lt;ca_name&gt; use the specified ca_name.<br>
<br>
-P &lt;ca_port&gt; use the specified ca_port.<br>
<br>
-t &lt;timeout_ms&gt; override the default timeout for the solicited mads.<br>
<br>
Multiple CA/Multiple Port Support<br>
<br>
When no IB device or port is specified, the port to use is selected by<br>
the following criteria:<br>
<br>
1. the first port that is ACTIVE.<br>
<br>
2. if not found, the first port that is UP (physical link up).<br>
<br>
If a port and/or CA name is specified, the user request is attempted to<br>
be fulfilled, and will fail if it is not possible.<br>
<br>
<br>
EXAMPLES<br>
Unicast examples<br>
<br>
ibroute 4 # dump all lids with valid out ports of switch with lid 4<br>
<br>
ibroute -a 4 # same, but dump all lids, even with invalid out ports<br>
<br>
ibroute -n 4 # simple dump format - no destination resolution<br>
<br>
ibroute 4 10 # dump lids starting from 10 (up to FDBTop)<br>
<br>
ibroute 4 0x10 0x20 # dump lid range<br>
<br>
ibroute -G 0x08f1040023 # resolve switch by GUID<br>
<br>
ibroute -D 0,1 # resolve switch by direct path<br>
<br>
<br>
Multicast examples<br>
<br>
ibroute -M 4 # dump all non empty mlids of switch with lid 4<br>
<br>
ibroute -M 4 0xc010 0xc020 # same, but with range<br>
<br>
ibroute -M -n 4 # simple dump format<br>
<br>
<br>
SEE ALSO<br>
ibtracert(8)<br>
<br>
AUTHOR<br>
Hal Rosenstock &lt;halr@voltaire.com&gt;<br>
<br>
<br>
OFED July 25, 2006 IBROUTE(8)</p>
<p align="left"><br>
<font color="#000000"><a href="#TOP">&lt;return-to-top&gt;</a></font><br>
&nbsp;</p>
<p align="left">&nbsp;</p>
<BLOCKQUOTE></BLOCKQUOTE>
<h3 align="left"><a name="ibv_devinfo"></a><br>
ibv_devinfo - print CA (Channel Adapter) attributes</h3>
<p align="left">usage: ibv_devinfo&nbsp; [options]<br>
<br>
Options:<br>
&nbsp;&nbsp; -d, --ib-dev=&lt;dev&gt; use IB device &lt;dev&gt; (default: first device 
found)<br>
&nbsp;&nbsp;&nbsp; -i, --ib-port=&lt;port&gt; use port &lt;port&gt; of IB device (default: 
all ports)<br>
&nbsp;&nbsp;&nbsp; -l, --list print only the IB devices names<br>
&nbsp;&nbsp;&nbsp; -v, --verbose print all the attributes of the IB device(s)<br>
<br>
<font color="#000000"><a href="#TOP">&lt;return-to-top&gt;</a></font><br>
&nbsp;</p>
<BLOCKQUOTE></BLOCKQUOTE>
<h3 align="left"><a name="ibstat"></a><br>
IBSTAT(8) OFED Diagnostics</h3>
<p align="left">NAME<br>
ibstat - query basic status of InfiniBand device(s)<br>
<br>
<br>
SYNOPSIS<br>
ibstat [-d(ebug)] [-l(ist_of_cas)] [-s(hort)] [-p(ort_list)] [-V(ersion)] [-h] &lt;ca_name&gt; 
[portnum]<br>
<br>
<br>
DESCRIPTION<br>
ibstat is a binary which displays basic information obtained from the<br>
local IB driver. Output includes LID, SMLID, port state, link width<br>
active, and port physical state.<br>
<br>
It is similar to the ibstatus utility but implemented as a binary<br>
rather than a script. It has options to list CAs and/or ports and dis-<br>
plays more information than ibstatus.<br>
<br>
<br>
OPTIONS<br>
-l, --list_of_cas<br>
list all IB devices<br>
<br>
-s, --short<br>
short output<br>
<br>
-p, --port_list<br>
show port list<br>
<br>
ca_name<br>
InfiniBand device name<br>
<br>
portnum<br>
port number of InfiniBand device<br>
<br>
<br>
COMMON OPTIONS<br>
Most OFED diagnostics take the following common flags. The exact list<br>
of supported flags per utility can be found in the usage message and<br>
can be shown using the util_name -h syntax.<br>
<br>
# Debugging flags<br>
<br>
-d raise the IB debugging level.<br>
May be used several times (-ddd or -d -d -d).<br>
<br>
-e show send and receive errors (timeouts and others)<br>
<br>
-h show the usage message<br>
<br>
-v increase the application verbosity level.<br>
May be used several times (-vv or -v -v -v)<br>
<br>
-V show the version info.<br>
<br>
# Addressing flags<br>
<br>
-D use directed path address arguments. The path<br>
is a comma separated list of out ports.<br>
Examples:<br>
&quot;0&quot; # self port<br>
&quot;0,1,2,1,4&quot; # out via port 1, then 2, ...<br>
<br>
-G use GUID address argument. In most cases, it is the Port GUID.<br>
Example:<br>
&quot;0x08f1040023&quot;<br>
<br>
-s &lt;smlid&gt; use ’smlid’ as the target lid for SM/SA queries.<br>
<br>
# Other common flags:<br>
<br>
-C &lt;ca_name&gt; use the specified ca_name.<br>
<br>
-P &lt;ca_port&gt; use the specified ca_port.<br>
<br>
-t &lt;timeout_ms&gt; override the default timeout for the solicited mads.<br>
<br>
Multiple CA/Multiple Port Support<br>
<br>
When no IB device or port is specified, the port to use is selected by<br>
the following criteria:<br>
<br>
1. the first port that is ACTIVE.<br>
<br>
2. if not found, the first port that is UP (physical link up).<br>
<br>
If a port and/or CA name is specified, the user request is attempted to<br>
be fulfilled, and will fail if it is not possible.<br>
<br>
<br>
EXAMPLES<br>
ibstat # display status of all ports on all IB devices<br>
<br>
ibstat -l # list all IB devices<br>
<br>
ibstat -p # show port guids<br>
<br>
ibstat ibv_device0 2 # show status of port 2 of ’hca0’<br>
<br>
<br>
SEE ALSO<br>
ibstatus(8)<br>
<br>
<br>
AUTHOR<br>
Hal Rosenstock &lt;halr@voltaire.com&gt;<br>
<br>
<br>
OFED July 25, 2006 IBSTAT(8)<br>
<br>
<font color="#000000"><a href="#TOP">&lt;return-to-top&gt;</a></font><br>
&nbsp;</p>
<p align="left">&nbsp;</p>
<h3 align="left"><a name="IBSYSSTAT">IBSYSSTAT</a>(8) OFED Diagnostics<br>
&nbsp;</h3>
<p align="left">NAME<br>
ibsysstat - system status on an InfiniBand address<br>
<br>
<br>
SYNOPSIS<br>
ibsysstat [-d(ebug)] [-e(rr_show)] [-v(erbose)] [-G(uid)] [-C ca_name]<br>
[-P ca_port] [-s smlid] [-t(imeout) timeout_ms] [-V(ersion)] [-o oui]<br>
[-S(erver)] [-h(elp)] &lt;dest lid | guid&gt; [&lt;op&gt;]<br>
<br>
<br>
DESCRIPTION<br>
ibsysstat uses vendor mads to validate connectivity between IB nodes<br>
and obtain other information about the IB node. ibsysstat is run as<br>
client/server. Default is to run as client.<br>
<br>
<br>
OPTIONS<br>
Current supported operations:<br>
ping - verify connectivity to server (default)<br>
host - obtain host information from server<br>
cpu - obtain cpu information from server<br>
<br>
-o, --oui<br>
use specified OUI number to multiplex vendor mads<br>
<br>
-S, --Server<br>
start in server mode (do not return)<br>
<br>
<br>
<br>
COMMON OPTIONS<br>
Most OFED diagnostics take the following common flags. The exact list<br>
of supported flags per utility can be found in the usage message and<br>
can be shown using the util_name -h syntax.<br>
<br>
# Debugging flags<br>
<br>
-d raise the IB debugging level.<br>
May be used several times (-ddd or -d -d -d).<br>
<br>
-e show send and receive errors (timeouts and others)<br>
<br>
-h show the usage message<br>
<br>
-v increase the application verbosity level.<br>
May be used several times (-vv or -v -v -v)<br>
<br>
-V show the version info.<br>
<br>
# Addressing flags<br>
<br>
-G use GUID address argument. In most cases, it is the Port GUID.<br>
Example:<br>
&quot;0x08f1040023&quot;<br>
<br>
-s &lt;smlid&gt; use ’smlid’ as the target lid for SM/SA queries.<br>
<br>
# Other common flags:<br>
<br>
-C &lt;ca_name&gt; use the specified ca_name.<br>
<br>
-P &lt;ca_port&gt; use the specified ca_port.<br>
<br>
-t &lt;timeout_ms&gt; override the default timeout for the solicited mads.<br>
<br>
Multiple CA/Multiple Port Support<br>
<br>
When no IB device or port is specified, the port to use is selected by<br>
the following criteria:<br>
<br>
1. the first port that is ACTIVE.<br>
<br>
2. if not found, the first port that is UP (physical link up).<br>
<br>
If a port and/or CA name is specified, the user request is attempted to<br>
be fulfilled, and will fail if it is not possible.<br>
<br>
<br>
AUTHOR<br>
Hal Rosenstock&nbsp;&nbsp;&nbsp; &lt;halr@voltaire.com&gt;<br>
<br>
<br>
OFED August 11, 2006 IBSYSSTAT(8)</p>
<p align="left"><br>
<a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></p>
<h3 align="left">&nbsp;</h3>
<h3 align="left"><a name="IBTRACERT">IBTRACERT</a>(8) OFED Diagnostics</h3>
<p align="left"><br>
NAME<br>
ibtracert- trace InfiniBand path<br>
<br>
<br>
SYNOPSIS<br>
ibtracert [-d(ebug)] [-v(erbose)] [-D(irect)] [-G(uids)] [-n(o_info)]<br>
[-m mlid] [-s smlid] [-C ca_name] [-P ca_port] [-t(imeout) timeout_ms]<br>
[-V(ersion)] [--node-name--map &lt;node-name-map&gt;] [-h(elp)] [&lt;dest<br>
dr_path|lid|guid&gt; [&lt;startlid&gt; [&lt;endlid&gt;]]]<br>
<br>
<br>
DESCRIPTION<br>
ibtracert uses SMPs to trace the path from a source GID/LID to a desti-<br>
nation GID/LID. Each hop along the path is displayed until the destina-<br>
tion is reached or a hop does not respond. By using the -m option, mul-<br>
ticast path tracing can be performed between source and destination<br>
nodes.<br>
<br>
<br>
OPTIONS<br>
-n, --no_info<br>
simple format; don’t show additional information<br>
<br>
-m show the multicast trace of the specified mlid<br>
<br>
--node-name-map &lt;node-name-map&gt;<br>
Specify a node name map. The node name map file maps GUIDs to<br>
more user friendly names. See <a href="#IBNETDISCOVER">ibnetdiscover</a>(8) for node name<br>
map file format.<br>
<br>
<br>
COMMON OPTIONS<br>
Most OFED diagnostics take the following common flags. The exact list<br>
of supported flags per utility can be found in the usage message and<br>
can be shown using the util_name -h syntax.<br>
<br>
# Debugging flags<br>
<br>
-d raise the IB debugging level.<br>
May be used several times (-ddd or -d -d -d).<br>
<br>
-h show the usage message<br>
<br>
-v increase the application verbosity level.<br>
May be used several times (-vv or -v -v -v)<br>
<br>
-V show the version info.<br>
<br>
# Addressing flags<br>
<br>
-D use directed path address arguments. The path<br>
is a comma separated list of out ports.<br>
Examples:<br>
&quot;0&quot; # self port<br>
&quot;0,1,2,1,4&quot; # out via port 1, then 2, ...<br>
<br>
-G use GUID address argument. In most cases, it is the Port GUID.<br>
Example:<br>
&quot;0x08f1040023&quot;<br>
<br>
-s &lt;smlid&gt; use ’smlid’ as the target lid for SM/SA queries.<br>
<br>
# Other common flags:<br>
<br>
-C &lt;ca_name&gt; use the specified ca_name.<br>
<br>
-P &lt;ca_port&gt; use the specified ca_port.<br>
<br>
-t &lt;timeout_ms&gt; override the default timeout for the solicited mads.<br>
<br>
Multiple CA/Multiple Port Support<br>
<br>
When no IB device or port is specified, the port to use is selected by<br>
the following criteria:<br>
<br>
1. the first port that is ACTIVE.<br>
<br>
2. if not found, the first port that is UP (physical link up).<br>
<br>
If a port and/or CA name is specified, the user request is attempted to<br>
be fulfilled, and will fail if it is not possible.<br>
<br>
<br>
EXAMPLES<br>
Unicast examples<br>
<br>
ibtracert 4 16 # show path between lids 4 and 16<br>
<br>
ibtracert -n 4 16 # same, but using simple output format<br>
<br>
ibtracert -G 0x8f1040396522d 0x002c9000100d051 # use guid addresses<br>
<br>
<br>
Multicast example<br>
<br>
ibtracert -m 0xc000 4 16 # show multicast path of mlid 0xc000<br>
between lids 4 and 16<br>
<br>
<br>
SEE ALSO<br>
ibroute(8)<br>
<br>
<br>
AUTHOR<br>
&nbsp;&nbsp;&nbsp; Hal Rosenstock&nbsp;&nbsp;&nbsp; &lt;<a href="mailto:halr@voltaire.com">halr@voltaire.com</a>&gt;<br>
<br>
&nbsp;&nbsp;&nbsp; Ira Weiny&nbsp;&nbsp;&nbsp; &lt;weiny2@llnl.gov&gt;<br>
<br>
OFED April 14, 2007 IBTRACERT(8)</p>
<p align="left"><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></p>
<h3 align="left">&nbsp;</h3>
<h3 align="left"><a name="PERFQUERY">PERFQUERY</a>(8) OFED Diagnostics</h3>
<p align="left"><br>
NAME<br>
perfquery - query InfiniBand port counters<br>
<br>
<br>
SYNOPSIS<br>
perfquery [-d(ebug)] [-G(uid)] [-x|--extended] [-X|--xmtsl]<br>
[-S|--rcvsl] [-a(ll_ports)] [-l(oop_ports)] [-r(eset_after_read)]<br>
[-R(eset_only)] [-C ca_name] [-P ca_port] [-t(imeout) timeout_ms]<br>
[-V(ersion)] [-h(elp)] [&lt;lid|guid&gt; [[port] [reset_mask]]]<br>
<br>
<br>
DESCRIPTION<br>
perfquery uses PerfMgt GMPs to obtain the PortCounters (basic perfor-<br>
mance and error counters), PortExtendedCounters, PortXmitDataSL, or<br>
PortRcvDataSL from the PMA at the node/port specified. Optionally shows<br>
aggregated counters for all ports of node. Also, optionally, reset<br>
after read, or only reset counters.<br>
<br>
Note: In PortCounters, PortCountersExtended, PortXmitDataSL, and PortR-<br>
cvDataSL, components that represent Data (e.g. PortXmitData and PortR-<br>
cvData) indicate octets divided by 4 rather than just octets.<br>
<br>
Note: Inputting a port of 255 indicates an operation be performed on<br>
all ports.<br>
<br>
<br>
OPTIONS<br>
-x, --extended<br>
show extended port counters rather than (basic) port counters.<br>
Note that extended port counters attribute is optional.<br>
<br>
-X, --xmtsl<br>
show transmit data SL counter. This is an optional counter for<br>
QoS.<br>
<br>
-S, --rcvsl<br>
show receive data SL counter. This is an optional counter for<br>
QoS.<br>
<br>
-a, --all_ports<br>
show aggregated counters for all ports of the destination lid or<br>
reset all counters for all ports. If the destination lid does<br>
not support the AllPortSelect flag, all ports will be iterated<br>
through to emulate AllPortSelect behavior.<br>
<br>
-l, --loop_ports<br>
If all ports are selected by the user (either through the -a<br>
option or port 255) iterate through each port rather than doing<br>
than aggregate operation.<br>
<br>
-r, --reset_after_read<br>
reset counters after read<br>
<br>
-R, --Reset_only<br>
only reset counters<br>
<br>
<br>
COMMON OPTIONS<br>
Most OFED diagnostics take the following common flags. The exact list<br>
of supported flags per utility can be found in the usage message and<br>
can be shown using the util_name -h syntax.<br>
<br>
# Debugging flags<br>
<br>
-d raise the IB debugging level.<br>
May be used several times (-ddd or -d -d -d).<br>
<br>
-e show send and receive errors (timeouts and others)<br>
<br>
-h show the usage message<br>
<br>
-v increase the application verbosity level.<br>
May be used several times (-vv or -v -v -v)<br>
<br>
-V show the version info.<br>
<br>
# Addressing flags<br>
<br>
-G use GUID address argument. In most cases, it is the Port GUID.<br>
Example:<br>
&quot;0x08f1040023&quot;<br>
<br>
-s &lt;smlid&gt; use ’smlid’ as the target lid for SM/SA queries.<br>
<br>
# Other common flags:<br>
<br>
-C &lt;ca_name&gt; use the specified ca_name.<br>
<br>
-P &lt;ca_port&gt; use the specified ca_port.<br>
<br>
-t &lt;timeout_ms&gt; override the default timeout for the solicited mads.<br>
<br>
Multiple CA/Multiple Port Support<br>
<br>
When no IB device or port is specified, the port to use is selected by<br>
the following criteria:<br>
<br>
1. the first port that is ACTIVE.<br>
<br>
2. if not found, the first port that is UP (physical link up).<br>
<br>
If a port and/or CA name is specified, the user request is attempted to<br>
be fulfilled, and will fail if it is not possible.<br>
<br>
<br>
EXAMPLES<br>
perfquery # read local port performance counters<br>
<br>
perfquery 32 1 # read performance counters from lid 32, port 1<br>
<br>
perfquery -x 32 1 # read extended performance counters from lid 32, port 1<br>
<br>
perfquery -a 32 # read perf counters from lid 32, all ports<br>
<br>
perfquery -r 32 1 # read performance counters and reset<br>
<br>
perfquery -x -r 32 1 # read extended performance counters and reset<br>
<br>
perfquery -R 0x20 1 # reset performance counters of port 1 only<br>
<br>
perfquery -x -R 0x20 1 # reset extended performance counters of port 1 only<br>
<br>
perfquery -R -a 32 # reset performance counters of all ports<br>
<br>
perfquery -R 32 2 0x0fff # reset only error counters of port 2<br>
<br>
perfquery -R 32 2 0xf000 # reset only non-error counters of port 2<br>
<br>
<br>
AUTHOR<br>
Hal Rosenstock&nbsp;&nbsp;&nbsp; &lt;halr@voltaire.com&gt;<br>
<br>
<br>
OFED March 10, 2009 PERFQUERY(8)</p>
<p align="left"><br>
<a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></p>
<h3 align="left">&nbsp;</h3>
<h3 align="left"><a name="SAQUERY">SAQUERY</a>(8) OFED Diagnostics</h3>
<p align="left"><br>
NAME<br>
saquery - query InfiniBand subnet administration attributes<br>
<br>
<br>
SYNOPSIS<br>
saquery [-h] [-d] [-p] [-N] [--list | -D] [-S] [-I] [-L] [-l] [-G] [-O]<br>
[-U] [-c] [-s] [-g] [-m] [-x] [-C ca_name] [-P ca_port] [--smkey val]<br>
[-t(imeout) &lt;msec&gt;] [--src-to-dst &lt;src:dst&gt;] [--sgid-to-dgid<br>
&lt;sgid-dgid&gt;] [--node-name-map &lt;node-name-map&gt;] [&lt;name&gt; | &lt;lid&gt; |<br>
&lt;guid&gt;]<br>
<br>
<br>
DESCRIPTION<br>
saquery issues the selected SA query. Node records are queried by<br>
default.<br>
<br>
<br>
OPTIONS<br>
-p get PathRecord info<br>
<br>
-N get NodeRecord info<br>
<br>
--list | -D<br>
get NodeDescriptions of CAs only<br>
<br>
-S get ServiceRecord info<br>
<br>
-I get InformInfoRecord (subscription) info<br>
<br>
-L return the Lids of the name specified<br>
<br>
-l return the unique Lid of the name specified<br>
<br>
-G return the Guids of the name specified<br>
<br>
-O return the name for the Lid specified<br>
<br>
-U return the name for the Guid specified<br>
<br>
-c get the SA’s class port info<br>
<br>
-s return the PortInfoRecords with isSM or isSMdisabled capability<br>
mask bit on<br>
<br>
-g get multicast group info<br>
<br>
-m get multicast member info. If a group is specified, limit the
output to the group specified and print one line containing only
the GUID and node description for each entry. Example: saquery
-m 0xc000<br>
<br>
-x get LinkRecord info<br>
<br>
--src-to-dst<br>
get a PathRecord for &lt;src:dst&gt; where src and dst are either node
names or LIDs<br>
<br>
--sgid-to-dgid<br>
get a PathRecord for sgid to dgid where both GIDs are in an IPv6 format 
acceptable to inet_pton.<br>
<br>
-C &lt;ca_name&gt;<br>
use the specified ca_name.<br>
<br>
-P &lt;ca_port&gt;<br>
use the specified ca_port.<br>
<br>
--smkey &lt;val&gt;<br>
use SM_Key value for the query. Will be used only with &quot;trusted&quot;<br>
queries. If non-numeric value (like ’x’) is specified then<br>
saquery will prompt for a value.<br>
<br>
-t, -timeout &lt;msec&gt;<br>
Specify SA query response timeout in milliseconds. Default is<br>
100 milliseconds. You may want to use this option if IB_TIMEOUT<br>
is indicated.<br>
<br>
--node-name-map &lt;node-name-map&gt;<br>
Specify a node name map. The node name map file maps GUIDs to<br>
more user friendly names. See ibnetdiscover(8) for 
<a href="#NODE_NAME_MAP_FILE_FORMAT">node name<br>
map file format</a>. Only used with the -O and -U options.<br>
<br>
Supported query names (and aliases):<br>
ClassPortInfo (CPI)<br>
NodeRecord (NR) [lid]<br>
PortInfoRecord (PIR) [[lid]/[port]]<br>
SL2VLTableRecord (SL2VL) [[lid]/[in_port]/[out_port]]<br>
PKeyTableRecord (PKTR) [[lid]/[port]/[block]]<br>
VLArbitrationTableRecord (VLAR) [[lid]/[port]/[block]]<br>
InformInfoRecord (IIR)<br>
LinkRecord (LR) [[from_lid]/[from_port]] [[to_lid]/[to_port]]<br>
ServiceRecord (SR)<br>
PathRecord (PR)<br>
MCMemberRecord (MCMR)<br>
LFTRecord (LFTR) [[lid]/[block]]<br>
MFTRecord (MFTR) [[mlid]/[position]/[block]]<br>
<br>
-d enable debugging<br>
<br>
-h show help<br>
<br>
<br>
AUTHORS<br>
Ira Weiny &lt;weiny2@llnl.gov&gt;<br>
<br>
Hal Rosenstock &lt;halr@voltaire.com&gt;<br>
<br>
<br>
OFED October 19, 2008 SAQUERY(8)</p>
<p align="left"><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></p>
<p align="left">&nbsp;</p>
<h3 align="left"><a name="SMINFO">SMINFO</a>(8) OFED Diagnostics</h3>
<p align="left"><br>
NAME<br>
sminfo - query InfiniBand SMInfo attribute<br>
<br>
<br>
SYNOPSIS<br>
sminfo [-d(ebug)] [-e(rr_show)] -s state -p prio -a activity<br>
[-D(irect)] [-G(uid)] [-C ca_name] [-P ca_port] [-t(imeout) time-<br>
out_ms] [-V(ersion)] [-h(elp)] sm_lid | sm_dr_path [modifier]<br>
<br>
<br>
DESCRIPTION<br>
Optionally set and display the output of a sminfo query in human read-<br>
able format. The target SM is the one listed in the local port info, or<br>
the SM specified by the optional SM lid or by the SM direct routed<br>
path.<br>
<br>
Note: using sminfo for any purposes other then simple query may be very<br>
dangerous, and may result in a malfunction of the target SM.<br>
<br>
<br>
OPTIONS<br>
-s set SM state<br>
0 - not active<br>
1 - discovering<br>
2 - standby<br>
3 - master<br>
<br>
-p set priority (0-15)<br>
<br>
-a set activity count<br>
<br>
COMMON OPTIONS<br>
<br>
Most OFED diagnostics take the following common flags. The exact list<br>
of supported flags per utility can be found in the usage message and<br>
can be shown using the util_name -h syntax.<br>
<br>
# Debugging flags<br>
<br>
-d raise the IB debugging level.<br>
May be used several times (-ddd or -d -d -d).<br>
<br>
-e show send and receive errors (timeouts and others)<br>
<br>
-h show the usage message<br>
<br>
-v increase the application verbosity level.<br>
May be used several times (-vv or -v -v -v)<br>
<br>
-V show the version info.<br>
<br>
# Addressing flags<br>
<br>
-D use directed path address arguments. The path<br>
is a comma separated list of out ports.<br>
Examples:<br>
&quot;0&quot; # self port<br>
&quot;0,1,2,1,4&quot; # out via port 1, then 2, ...<br>
<br>
-G use GUID address argument. In most cases, it is the Port GUID.<br>
Example:<br>
&quot;0x08f1040023&quot;<br>
<br>
-s &lt;smlid&gt; use ’smlid’ as the target lid for SM/SA queries.<br>
<br>
# Other common flags:<br>
<br>
-C &lt;ca_name&gt; use the specified ca_name.<br>
<br>
-P &lt;ca_port&gt; use the specified ca_port.<br>
<br>
-t &lt;timeout_ms&gt; override the default timeout for the solicited mads.<br>
<br>
Multiple CA/Multiple Port Support<br>
<br>
When no IB device or port is specified, the port to use is selected by<br>
the following criteria:<br>
<br>
1. the first port that is ACTIVE.<br>
<br>
2. if not found, the first port that is UP (physical link up).<br>
<br>
If a port and/or CA name is specified, the user request is attempted to<br>
be fulfilled, and will fail if it is not possible.<br>
<br>
<br>
EXAMPLES<br>
sminfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # local port´s sminfo<br>
<br>
sminfo 32&nbsp;&nbsp;&nbsp;&nbsp; # show sminfo of lid 32<br>
<br>
sminfo -G 0x8f1040023&nbsp;&nbsp;&nbsp;&nbsp; # same but using guid address<br>
<br>
<br>
SEE ALSO<br>
smpdump(8)<br>
<br>
<br>
AUTHOR<br>
Hal Rosenstock&nbsp;&nbsp;&nbsp; &lt;halr@voltaire.com&gt;<br>
<br>
OFED July 25, 2006 SMINFO(8)</p>
<p align="left"><br>
<a href="#TOP"><font color="#000000">&lt;<b>return-to-top</b>&gt;</font></a></p>
<h3 align="left">&nbsp;</h3>
<h3 align="left"><a name="SMPDUMP">SMPDUMP</a>(8) OFED Diagnostics</h3>
<p align="left"><br>
NAME<br>
smpdump - dump InfiniBand subnet management attributes<br>
<br>
<br>
SYNOPSIS<br>
smpdump [-s(ring)] [-D(irect)] [-C ca_name] [-P ca_port] [-t(imeout)<br>
timeout_ms] [-V(ersion)] [-h(elp)] &lt;dlid|dr_path&gt; &lt;attr&gt; [mod]<br>
<br>
<br>
DESCRIPTION<br>
smpdump is a general purpose SMP utility which gets SM attributes from<br>
a specified SMA. The result is dumped in hex by default.<br>
<br>
<br>
OPTIONS<br>
attr IBA attribute ID for SM attribute<br>
<br>
mod IBA modifier for SM attribute<br>
<br>
<br>
COMMON OPTIONS<br>
Most OFED diagnostics take the following common flags. The exact list<br>
of supported flags per utility can be found in the usage message and<br>
can be shown using the util_name -h syntax.<br>
<br>
# Debugging flags<br>
<br>
-d raise the IB debugging level.<br>
May be used several times (-ddd or -d -d -d).<br>
<br>
-e show send and receive errors (timeouts and others)<br>
<br>
-h show the usage message<br>
<br>
-v increase the application verbosity level.<br>
May be used several times (-vv or -v -v -v)<br>
<br>
-V show the version info.<br>
<br>
# Addressing flags<br>
<br>
-D use directed path address arguments. The path<br>
is a comma separated list of out ports.<br>
Examples:<br>
&quot;0&quot; # self port<br>
&quot;0,1,2,1,4&quot; # out via port 1, then 2, ...<br>
<br>
-G use GUID address argument. In most cases, it is the Port GUID.<br>
Example:<br>
&quot;0x08f1040023&quot;<br>
<br>
-s &lt;smlid&gt; use ’smlid’ as the target lid for SM/SA queries.<br>
<br>
# Other common flags:<br>
<br>
-C &lt;ca_name&gt; use the specified ca_name.<br>
<br>
-P &lt;ca_port&gt; use the specified ca_port.<br>
<br>
-t &lt;timeout_ms&gt; override the default timeout for the solicited mads.<br>
<br>
Multiple CA/Multiple Port Support<br>
<br>
When no IB device or port is specified, the port to use is selected by<br>
the following criteria:<br>
<br>
1. the first port that is ACTIVE.<br>
<br>
2. if not found, the first port that is UP (physical link up).<br>
<br>
If a port and/or CA name is specified, the user request is attempted to<br>
be fulfilled, and will fail if it is not possible.<br>
<br>
<br>
EXAMPLES<br>
Direct Routed Examples<br>
<br>
smpdump -D 0,1,2,3,5 16 # NODE DESC<br>
<br>
smpdump -D 0,1,2 0x15 2 # PORT INFO, port 2<br>
<br>
LID Routed Examples<br>
<br>
smpdump 3 0x15 2 # PORT INFO, lid 3 port 2<br>
<br>
smpdump 0xa0 0x11 # NODE INFO, lid 0xa0<br>
<br>
<br>
SEE ALSO<br>
smpquery(8)<br>
<br>
<br>
AUTHOR<br>
Hal Rosenstock&nbsp;&nbsp;&nbsp; &lt;halr@voltaire.com&gt;<br>
<br>
<br>
OFED July 25, 2006 SMPDUMP(8)</p>
<p align="left"><br>
<a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></p>
<h3 align="left">&nbsp;</h3>
<h3 align="left"><a name="SMPQUERY">SMPQUERY</a>(8) OFED Diagnostics</h3>
<p align="left"><br>
NAME<br>
smpquery - query InfiniBand subnet management attributes<br>
<br>
<br>
SYNOPSIS<br>
smpquery [-d(ebug)] [-e(rr_show)] [-v(erbose)] [-D(irect)] [-G(uid)]<br>
[-C ca_name] [-P ca_port] [-t(imeout) timeout_ms]<br>
[--node-name-map
node-name-map-file]<br>
[-V(ersion)] [-h(elp)] &lt;op&gt; &lt;dest dr_path|lid|guid&gt; [op
params]<br>
<br>
<br>
DESCRIPTION<br>
smpquery allows a basic subset of standard SMP queries including the<br>
following: node info, node description, switch info, port info. Fields<br>
are displayed in human readable format.<br>
<br>
<br>
OPTIONS<br>
Current supported operations and their parameters:<br>
nodeinfo &lt;addr&gt;<br>
nodedesc &lt;addr&gt;<br>
portinfo &lt;addr&gt; [&lt;portnum&gt;] # default port is zero<br>
switchinfo &lt;addr&gt;<br>
pkeys &lt;addr&gt; [&lt;portnum&gt;]<br>
sl2vl &lt;addr&gt; [&lt;portnum&gt;]<br>
vlarb &lt;addr&gt; [&lt;portnum&gt;]<br>
guids &lt;addr&gt;<br>
<br>
<br>
--node-name-map &lt;node-name-map&gt;<br>
Specify a node name map. The node name map file maps GUIDs to<br>
more user friendly names. See ibnetdiscover(8) for 
<a href="#NODE_NAME_MAP_FILE_FORMAT">node name<br>
map file format</a>.<br>
<br>
<br>
COMMON OPTIONS<br>
Most OFED diagnostics take the following common flags. The exact list<br>
of supported flags per utility can be found in the usage message and<br>
can be shown using the util_name -h syntax.<br>
<br>
# Debugging flags<br>
<br>
-d raise the IB debugging level.<br>
May be used several times (-ddd or -d -d -d).<br>
<br>
-e show send and receive errors (timeouts and others)<br>
<br>
-h show the usage message<br>
<br>
-v increase the application verbosity level.<br>
May be used several times (-vv or -v -v -v)<br>
<br>
-V show the version info.<br>
<br>
# Addressing flags<br>
<br>
-D use directed path address arguments. The path<br>
is a comma separated list of out ports.<br>
Examples:<br>
&quot;0&quot; # self port<br>
&quot;0,1,2,1,4&quot; # out via port 1, then 2, ...<br>
<br>
-c use combined route address arguments. The<br>
address is a combination of a LID and a direct route path.<br>
The LID specified is the DLID and the local LID is used<br>
as the DrSLID.<br>
<br>
-G use GUID address argument. In most cases, it is the Port GUID.<br>
Example:<br>
&quot;0x08f1040023&quot;<br>
<br>
-s &lt;smlid&gt; use ’smlid’ as the target lid for SM/SA queries.<br>
<br>
# Other common flags:<br>
<br>
-C &lt;ca_name&gt; use the specified ca_name.<br>
<br>
-P &lt;ca_port&gt; use the specified ca_port.<br>
<br>
-t &lt;timeout_ms&gt; override the default timeout for the solicited mads.<br>
<br>
Multiple CA/Multiple Port Support<br>
<br>
When no IB device or port is specified, the port to use is selected by<br>
the following criteria:<br>
<br>
1. the first port that is ACTIVE.<br>
<br>
2. if not found, the first port that is UP (physical link up).<br>
<br>
If a port and/or CA name is specified, the user request is attempted to<br>
be fulfilled, and will fail if it is not possible.<br>
<br>
<br>
EXAMPLES<br>
smpquery portinfo 3 1 # portinfo by lid, with port modifier<br>
<br>
smpquery -G switchinfo 0x2C9000100D051 1 # switchinfo by guid<br>
<br>
smpquery -D nodeinfo 0 # nodeinfo by direct route<br>
<br>
smpquery -c nodeinfo 6 0,12 # nodeinfo by combined route<br>
<br>
<br>
SEE ALSO<br>
smpdump(8)<br>
<br>
<br>
AUTHOR<br>
Hal Rosenstock &lt;halr@voltaire.com&gt;<br>
<br>
<br>
OFED March 14, 2007 SMPQUERY(8)</p>
<p align="left"><a href="#TOP"><font color="#000000">&lt;<b><font size="4">return-to-top</font></b>&gt;</font></a></p>
<h3 align="left">&nbsp;</h3>
<h3 align="left"><a name="VENDSTAT">VENDSTAT</a>(8) OFED Diagnostics</h3>
<p align="left">NAME<br>
vendstat - query InfiniBand vendor specific functions<br>
<br>
<br>
SYNOPSIS<br>
vendstat [-d(ebug)] [-G(uid)] [-N] [-w] [-i] [-c &lt;num,num&gt;] [-C ca_name] [-P 
ca_port] [-t(imeout) timeout_ms] [-V(ersion)] [-h(elp)] &lt;lid|guid&gt;<br>
<br>
<br>
DESCRIPTION<br>
vendstat uses vendor specific MADs to access beyond the IB spec vendor<br>
specific functionality. Currently, there is support for Mellanox InfiniSwitch-III 
(IS3) and InfiniSwitch-IV (IS4).<br>
<br>
<br>
OPTIONS<br>
-N show IS3 general information.<br>
<br>
-w show IS3 port xmit wait counters.<br>
<br>
-i show IS4 counter group info.<br>
<br>
-c &lt;num,num&gt;<br>
configure IS4 counter groups.<br>
<br>
Configure IS4 counter groups 0 and 1. Such configuration is not<br>
persistent across IS4 reboot. First number is for counter group<br>
0 and second is for counter group 1.<br>
<br>
Group 0 counter config values:<br>
0 - PortXmitDataSL0-7<br>
1 - PortXmitDataSL8-15<br>
2 - PortRcvDataSL0-7<br>
<br>
Group 1 counter config values:<br>
1 - PortXmitDataSL8-15<br>
2 - PortRcvDataSL0-7<br>
8 - PortRcvDataSL8-15<br>
<br>
<br>
COMMON OPTIONS<br>
Most OFED diagnostics take the following common flags. The exact list<br>
of supported flags per utility can be found in the usage message and<br>
can be shown using the util_name -h syntax.<br>
<br>
# Debugging flags<br>
<br>
-d raise the IB debugging level.<br>
May be used several times (-ddd or -d -d -d).<br>
<br>
-e show send and receive errors (timeouts and others)<br>
<br>
-h show the usage message<br>
<br>
-v increase the application verbosity level.<br>
May be used several times (-vv or -v -v -v)<br>
<br>
-V show the version info.<br>
<br>
# Addressing flags<br>
<br>
-G use GUID address argument. In most cases, it is the Port GUID.<br>
Example:<br>
&quot;0x08f1040023&quot;<br>
<br>
-s &lt;smlid&gt; use ’smlid’ as the target lid for SM/SA queries.<br>
<br>
# Other common flags:<br>
<br>
-C &lt;ca_name&gt; use the specified ca_name.<br>
<br>
-P &lt;ca_port&gt; use the specified ca_port.<br>
<br>
-t &lt;timeout_ms&gt; override the default timeout for the solicited mads.<br>
<br>
Multiple CA/Multiple Port Support<br>
<br>
When no IB device or port is specified, the port to use is selected by<br>
the following criteria:<br>
<br>
1. the first port that is ACTIVE.<br>
<br>
2. if not found, the first port that is UP (physical link up).<br>
<br>
If a port and/or CA name is specified, the user request is attempted to<br>
be fulfilled, and will fail if it is not possible.<br>
<br>
<br>
EXAMPLES<br>
vendstat -N 6 # read IS3 general information<br>
<br>
vendstat -w 6 # read IS3 port xmit wait counters<br>
<br>
vendstat -i 6 12 # read IS4 port 12 counter group info<br>
<br>
vendstat -c 0,1 6 12 # configure IS4 port 12 counter groups for PortXmitDataSL<br>
<br>
vendstat -c 2,8 6 12 # configure IS4 port 12 counter groups for PortRcvDataSL<br>
<br>
<br>
AUTHOR<br>
Hal Rosenstock&nbsp;&nbsp;&nbsp; &lt;halr@voltaire.com&gt;<br>
<br>
<br>
OFED April 16, 2009 VENDSTAT(8)</p>
<p align="left"><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a><br>
&nbsp;</p>
<h3 align="left"><a name="iblimits"></a><br>
ib_limits - Infiniband verbs tests</h3>
<p align="left">Usage: ib_limits [options]</p>
<blockquote>
	<p align="left">Options:<br>-m or --memory<br>&nbsp;&nbsp;&nbsp; Direct ib_limits to test memory registration<br>-c or --cq<br>&nbsp;&nbsp;&nbsp; Direct ib_limits to test CQ creation<br>-r or --resize_cq<br>&nbsp;&nbsp;&nbsp; direct ib_limits to test CQ resize<br>-q or --qp<br>&nbsp;&nbsp;&nbsp; Directs ib_limits to test QP creation<br>-v or --verbose<br>&nbsp;&nbsp;&nbsp; Enable verbosity level to debug console.<br>-h or --help<br>&nbsp;&nbsp;&nbsp; Display this usage info then exit.</p>
</blockquote>
<h4 align="left"><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></h4>
<p align="left">&nbsp;</p>
<h3 align="left"><a name="cmtest"></a><br>
cmtest - Connection Manager Tests</h3>
<p>Usage: cmtest [options]</p>
<p>&nbsp;&nbsp;&nbsp; Options:</p>
<blockquote>
	<p>&nbsp;-s --server This option directs cmtest to act as a Server<br>
&nbsp;-l
	<lid>--local
	<lid>This option specifies the local endpoint.<br>
&nbsp;-r
	<lid>--remote
	<lid>This option specifies the remote endpoint LID as a hex integer 0x; see 
	vstat command for active port LID hex integer.<br>
&nbsp;-c
	<number>--connect
	<number>This option specifies the number of connections to open. Default of 
	1.<br>
&nbsp;-m
	<bytes>--msize
	<bytes>This option specifies the byte size of each message. Default is 100 
	bytes.<br>
&nbsp;-n
	<number>--nmsgs
	<number>This option specifies the number of messages to send at a time.<br>
&nbsp;-p --permsg This option indicates if a separate buffer should be used per 
	message. Default is one buffer for all messages.<br>
&nbsp;-i
	<number>--iterate
	<number>This option specifies the number of times to loop through 'nmsgs'. 
	Default of 1.<br>
&nbsp;-v --verbose This option enables verbosity level to debug console.<br>
&nbsp;-h --help Display this usage info then exit.</p>
</blockquote>
<h4 align="left"><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></h4>
<p align="left">&nbsp;</p>
<BLOCKQUOTE></BLOCKQUOTE>
<h3 align="left"><a name="InfiniBand_Partition_Management">InfiniBand Partition 
Management</a></h3>
<p align="left"><font face="Times New Roman">The part</font><font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">_man.exe 
application allows creating, deleting and viewing existing </span><span style="FONT-SIZE: 12pt">
host partitions</span><span style="FONT-SIZE: 12pt">.</span></font></p>
<p align="left">Usage : part_man.exe &lt;show|add|rem&gt; &lt;port_guid&gt; &lt;pkey1 pkey2 
...&gt;</p>
        <b><font face="Times New Roman" size="4">
	<span style="font-weight: bold">show - </span></font></b>
<font face="Times New Roman" size="3">
	<span style="FONT-SIZE: 12pt">– shows existing partitions</span></font><p style="MARGIN-LEFT: 0.5in"><font face="Times New Roman" size="3">
	<span style="FONT-SIZE: 12pt">Expected results after execution <b>
	<span style="FONT-WEIGHT: bold">part_man.exe show</span></b></span></font></p>
	<p style="MARGIN-LEFT: 0.75in; TEXT-INDENT: -0.25in">
	<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">1.</span></font><font size="1"><span style="FONT-SIZE: 7pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></font>Output has a format<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">&nbsp;</span></font></p>
	<p style="MARGIN-LEFT: 0.5in"><b><font face="Times New Roman" size="3">
	<span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt">port_guid1&nbsp;&nbsp; pkey1&nbsp; pkey2&nbsp; 
	pkey3&nbsp; pkey4&nbsp; pkey5&nbsp; pkey6&nbsp; pkey7&nbsp; pkey8</span></font></b></p>
	<p style="MARGIN-LEFT: 0.5in"><b><font face="Times New Roman" size="3">
	<span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt">port_guid2&nbsp;&nbsp; 
	pkey1&nbsp;&nbsp;pkey2&nbsp; pkey3&nbsp; pkey4&nbsp; pkey5&nbsp; pkey6&nbsp; pkey7&nbsp; pkey8</span></font></b></p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.5in">
	<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">where <b>
	<span style="FONT-WEIGHT: bold">port_guid</span></b> is a port guid in 
	hexadecimal format, <b><span style="FONT-WEIGHT: bold">pkey</span></b> – 
	values of partition key (in hex format) for this port.</span></font></p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.5in">
	<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">Default 
	partition key (0xFFFF) is not shown and can not be created by the 
	part_man.exe.</span></font></p>
<p class="MsoNormal" style="MARGIN-LEFT: 0.5in">
	&nbsp;</p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.0in"><b>
	<font face="Times New Roman" size="4">
	<span style="FONT-WEIGHT: bold; ">add - </span></font></b>create new partition(s) 
	on specified port </p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.5in"><b>
	<font face="Times New Roman" size="3">
	<span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt">port_guid</span></font></b>&nbsp;
	<b><span style="FONT-WEIGHT: bold">add</span></b>&nbsp;&nbsp; &lt;<b><span style="FONT-WEIGHT: bold">port_guid</span></b>&gt; 
	&nbsp;&lt;<b><span style="FONT-WEIGHT: bold">pkey1</span></b>&gt; &nbsp;&nbsp;&lt;<b><span style="FONT-WEIGHT: bold">pkey2</span></b>&gt; 
	</p>
<p class="MsoNormal" style="MARGIN-LEFT: 0.5in">creates new partition(s) on port specified by port_guid parameter (in 
	hexadecimal format) and pkey – new partition key value in hexadecimal 
	format (e.g. 0xABCD or ABCD).</p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.5in">
	<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">Port 
	guid is taken form vstat output and has a following format:</span></font></p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.5in"><b>
	<font face="Times New Roman" size="3">
	<span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt">XXXX:XXXX:XXXX:XXXX.</span></font></b></p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.5in">
	<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">Vstat 
	prints node guid, so user has to add 1 to node guid value to obtain port 
	guid. For example, if node guid is <b><span style="FONT-WEIGHT: bold">
	0008:f104:0397:7ccc</span></b>, port guid will be</span></font></p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.5in"><b>
	<font face="Times New Roman" size="3">
	<span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt">0008:f104:0397:7ccd</span></font></b> 
	– for the first port,</p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.5in"><b>
	<font face="Times New Roman" size="3">
	<span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt">0008:f104:0397:7cce</span></font></b> 
	– for the second port.</p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.5in">
	<font face="Courier New" color="green" size="2">
	<span style="FONT-SIZE: 10pt; COLOR: green; FONT-FAMILY: 'Courier New'">&nbsp;</span></font></p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.5in">
	<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">Expected 
	results of execution <b><span style="FONT-WEIGHT: bold">part_man.exe add 
	0x0D99:9703:04f1:0800 0xABCD</span></b></span></font></p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.75in; TEXT-INDENT: -0.25in">
	<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">1.</span></font><font size="1"><span style="FONT-SIZE: 7pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></font>part_man.exe output ends up with <b>
	<span style="FONT-WEIGHT: bold">…Done </span></b>message.</p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.75in; TEXT-INDENT: -0.25in">
	<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">2.</span></font><font size="1"><span style="FONT-SIZE: 7pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></font>A new instance of a Network Adapter named “OpenFabrics IPoIB 
	Adapter Partition” will appear in Device manager 
	window.&nbsp; <br>
	If the new adapter appears with yellow label, manual device driver installation is 
	required.</p>
<ul>
	<li>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.75in; TEXT-INDENT: -0.25in">In 
	the device manager view, right click “OpenFabrics IPoIB Adapter Partition”</p>
	</li>
	<li>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.75in; TEXT-INDENT: -0.25in">
	select 'update driver' and follow the instructions.</p></li>
	<li>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.75in; TEXT-INDENT: -0.25in">don't 
	allow Windows Update to search the Internet</p></li>
	<li>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.75in; TEXT-INDENT: -0.25in">
	select install software automatically.</p></li>
</ul>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.75in; TEXT-INDENT: -0.25in">
	<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">3.</span></font><font size="1"><span style="FONT-SIZE: 7pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></font>New adapter name ends with “Partition”, e.g. “OpenFabrics IPoIB 
	Adapter Partition”.</p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.5in">
	<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">&nbsp;</span></font></p>
	<b>
	<font face="Times New Roman" size="4">
	<span style="FONT-WEIGHT: bold; ">rem </span></font></b>
	<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">– 
	removes partition key on specified 
	port.</span></font></p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.5in"><b>
	<font face="Times New Roman" size="3">
	<span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt">part_man.exe rem &lt;port_guid&gt; 
	&lt;pkey1&gt;&nbsp; &lt;pkey2&gt;</span></font></b></p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.5in">
	<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">
	Port_guid – in hexadecimal format (same as for <b>
	<span style="FONT-WEIGHT: bold">add</span></b> command), identifies port for 
	operation. </span></font></p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.5in">
	<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">Expected 
	results after execution <b><span style="FONT-WEIGHT: bold">part_man rem &lt;port_guid&gt; 
	&nbsp;&lt;pkey&gt;</span></b></span></font></p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.75in; TEXT-INDENT: -0.25in">
	<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">1.</span></font><font size="1"><span style="FONT-SIZE: 7pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></font>Application prints <b><span style="FONT-WEIGHT: bold">…Done
	</span></b>message.</p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.75in; TEXT-INDENT: -0.25in">
	<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">2.</span></font><font size="1"><span style="FONT-SIZE: 7pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></font>In device manager window IPoIB network adapter will disappear.</p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.75in; TEXT-INDENT: -0.25in">
	<font face="Times New Roman" size="3"><span style="FONT-SIZE: 12pt">3.</span></font><font size="1"><span style="FONT-SIZE: 7pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</span></font>Execution of&nbsp; <b><span style="FONT-WEIGHT: bold">part_man.exe 
	show </span></b>will not show removed adapter.</p>
	<p class="MsoNormal" style="MARGIN-LEFT: 0.75in; TEXT-INDENT: -0.25in">&nbsp;</div>
	
<p align="left"><b><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></b></p>
<p align="left">&nbsp;</p>
<h3 align="left"><a name="printip"></a><br>
PrintIP - print ip adapters and their addresses</h3>
<blockquote>
	<p align="left">PrintIP is used to print IP adapters and their addresses, or 
	ARP (Address Resolution Protocol) and IP address.<br>
	<br>
	Usage:<br>
&nbsp;&nbsp;&nbsp; printip &lt;print_ips&gt;<br>
&nbsp;&nbsp;&nbsp; printip &lt;remoteip&gt; &lt;ip&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	(example printip remoteip 10.10.2.20)</p>
</blockquote>
<h3 align="left"><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></h3>
<p align="left">&nbsp;</p>
<h3 align="left">
<br>
<a name="vstat"></a><br>
vstat - HCA Stats and Counters</h3>
<blockquote>
	<p align="left">Display HCA (Host channel Adapter) attributes.</p>
	<p align="left">Usage: vstat [-v] [-c]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -v - verbose mode<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -c - HCA error/statistic 
	counters<br>
	<br>
	Includes Node GUID, Subnet Manager and port LIDs.</p>
</blockquote>
<h4 align="left"><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></h4>
<p align="left">&nbsp;</p>
<BLOCKQUOTE></BLOCKQUOTE>
<h2 align="left"><a name="opensm"></a>Subnet Management with OpenSM version 
3.3.13</h2>
<hr>
<p align="left">A single running process (opensm.exe) is required to configure 
and thus make an Infiniband subnet useable.&nbsp; For most cases, InfiniBand 
Subnet Management as a Windows service is sufficient to correctly configure most 
InfiniBand fabrics.</p>
<p align="left">The Infiniband subnet management process (opensm) may exist on a 
Windows (OFED) node or a Linux (OFED) node.<br>
<br>
Limit the number of OpenSM processes per IB fabric; one SM is sufficient 
although redundant SMs are supported. You do not need a Subnet Manager per 
node/system.</p>
<h3>OpenIB Subnet Management as a Windows Service</h3>
<p>InfiniBand subnet management (OpenSM), as a Windows service, is installed by default, although it is NOT 
started by default. There are two ways to enable the InfiniBand Subnet 
Management service.</p>
<ol style="margin-bottom: 0in">
	<li>Reset the installed OpenSM service &quot;InfiniBand Subnet Management&quot; 
	to start automatically; From a command window type 'services.msc'.<br>
	Locate the InfiniBand Subnet Management view and select the start option; 
	additionally select the startup option 'Automatic' to start the OpenSM 
	service on system startup.<br>&nbsp;</li>
	<li>Install OpenSM as a 'running' Windows service:<br>
	Select the OpenSM_service_Started install feature. 
	Once the installation has completed, check the running InfiniBand Subnet 
	Management service status via the Windows service manager (see #1).<br>&nbsp;</li>
	<li>Consult the OpenSM log files to see what 
	OpenSM thinks is happening.<br>
&nbsp;&nbsp;&nbsp; %windir%\osm.log<br>
&nbsp;&nbsp;&nbsp; %windir%\osm.syslog<br>&nbsp;</li>
</ol>
<h3 align="left">InfiniBand Subnet Management from a command window</h3>

opensm - InfiniBand subnet manager and administration (SM/SA)
<h3>SYNOPSIS</h3>

<p><b>opensm</b> [--version]] [-F | --config &lt;file_name&gt;] [-c(reate-config) &lt;file_name&gt;] 
[-g(uid) &lt;GUID in hex&gt;] [-l(mc) &lt;LMC&gt;] [-p(riority) &lt;PRIORITY&gt;] [-smkey &lt;SM_Key&gt;] 
[--sm_sl &lt;SL number&gt;] [-r(eassign_lids)] [-R &lt;engine name(s)&gt; | --routing_engine 
&lt;engine name(s)&gt;] [--do_mesh_analysis] [--lash_start_vl &lt;vl number&gt;] [-A | --ucast_cache] 
[-z | --connect_roots] [-M &lt;file name&gt; | --lid_matrix_file &lt;file name&gt;] [-U 
&lt;file name&gt; | --lfts_file &lt;file name&gt;] [-S | --sadb_file &lt;file name&gt;] [-a | --root_guid_file 
&lt;path to file&gt;] [-u | --cn_guid_file &lt;path to file&gt;] [-G | --io_guid_file &lt;path 
to file&gt;] [--port-shifting] [--scatter-ports] [-H | --max_reverse_hops &lt;max 
reverse hops allowed&gt;] [-X | --guid_routing_order_file &lt;path to file&gt;] [-m | --ids_guid_file 
&lt;path to file&gt;] [-o(nce)] [-s(weep) &lt;interval&gt;] [-t(imeout) &lt;milliseconds&gt;] 
[--retries &lt;number&gt;] [-maxsmps &lt;number&gt;] [-console [off | local | socket | 
loopback]] [-console-port &lt;port&gt;] [-i(gnore-guids) &lt;equalize-ignore-guids-file&gt;] 
[-w | --hop_weights_file &lt;path to file&gt;] [-O | --port_search_ordering_file &lt;path 
to file&gt;] [-O | --dimn_ports_file &lt;path to file&gt;] (DEPRECATED) [-f &lt;log file 
path&gt; | --log_file &lt;log file path&gt; ] [-L | --log_limit &lt;size in MB&gt;] [-e(rase_log_file)] 
[-P(config) &lt;partition config file&gt; ] [-N | --no_part_enforce] [-Q | --qos [-Y | 
--qos_policy_file &lt;file name&gt;]] [-y | --stay_on_fatal] [-service | -B | 
--daemon] [-I | --inactive] [--perfmgr] [--perfmgr_sweep_time_s &lt;seconds&gt;] [--prefix_routes_file 
&lt;path&gt;] [--consolidate_ipv6_snm_req] [--log_prefix &lt;prefix text&gt;] [--torus_config 
&lt;path to file&gt;] [-v(erbose)] [-V] [-D &lt;flags&gt;] [-d(ebug) &lt;number&gt;] [-h(elp)] 
[-?] </p>
<h3>DESCRIPTION</h3>

<P>

opensm is the InfiniBand compliant Subnet Manager and Administrator,
running on top of OFED for Windows.<br>
Such a software entity is required
to initialize the InfiniBand hardware (at least one SM per each InfiniBand subnet).&nbsp;
<P>
opensm defaults were designed to meet the common case usage on clusters with up to a few hundred nodes. Thus, in this default mode, opensm will scan the IB
fabric, initialize it, and sweep occasionally for changes.
<P>
opensm attaches to a specific IB port on the local machine and configures only
the fabric connected to it. (If the local machine has other IB ports,
opensm will ignore the fabrics connected to those other ports). If no port is
specified, it will select the first &quot;best&quot; available port.
<P>
opensm can present the available ports and prompt for a port number to
attach to.
<P>
By default, the run is logged to two files: %windir%\osm.syslog and %windir%\temp\opensm.log.
The first file will register only general major events, whereas the second
will include details of reported errors. All errors reported in this second
file should be treated as indicators of Infiniband fabric health issues; note that when a fatal and non-recoverable error occurs, opensm will exit.&nbsp;
Both log files should include the message &quot;SUBNET UP&quot; if opensm was able to
setup the subnet correctly.<h3>OPTIONS</h3>

<P>
<P>

<DL COMPACT>
<DT><B>--version</B><DD>
Prints OpenSM version and exits.
<DT><B>-F</B>, <B>--config</B> &lt;config file&gt;<DD>
The name of the OpenSM config file. When not specified
<B> %ProgramFiles%\OFED\opensm\opensm.conf</B> will be used (if exists).
<DT><B>-c</B>, <B>--create-config</B> &lt;file name&gt;<DD>
OpenSM will dump its configuration to the specified file and exit.
This is a way to generate OpenSM configuration file template.
<DT><B>-g</B>, <B>--guid</B> &lt;GUID in hex&gt;<DD>
This option specifies the local port GUID value
with which OpenSM should bind.  OpenSM may be
bound to 1 port at a time.
If GUID given is 0, OpenSM displays a list
of possible port GUIDs and waits for user input.
Without -g, OpenSM tries to use the default port.
<DT><B>-l</B>, <B>--lmc</B> &lt;LMC value&gt;<DD>
This option specifies the subnet's LMC value.
The number of LIDs assigned to each port is 2^LMC.
The LMC value must be in the range 0-7.
LMC values &gt; 0 allow multiple paths between ports.
LMC values &gt; 0 should only be used if the subnet
topology actually provides multiple paths between
ports, i.e. multiple interconnects between switches.
Without -l, OpenSM defaults to LMC = 0, which allows
one path between any two ports.
<DT><B>-p</B>, <B>--priority</B> &lt;Priority value&gt;<DD>
This option specifies the SM's PRIORITY.
This will effect the handover cases, where master
is chosen by priority and GUID.  Range goes from 0
(default and lowest priority) to 15 (highest).
<DT><B>-smkey</B> &lt;SM_Key value&gt;<DD>
This option specifies the SM's SM_Key (64 bits).
This will effect SM authentication.
Note that OpenSM version 3.2.1 and below used the default value '1'
in a host byte order, it is fixed now but you may need this option to
interoperate with old OpenSM running on a little endian machine.
<DT><B>--sm_sl</B> &lt;SL number&gt;<DD>
This option sets the SL to use for communication with the SM/SA.
Defaults to 0.
<DT><B>-r</B>, <B>--reassign_lids</B><DD>
This option causes OpenSM to reassign LIDs to all
end nodes. Specifying -r on a running subnet
may disrupt subnet traffic.
Without -r, OpenSM attempts to preserve existing
LID assignments resolving multiple use of same LID.
<DT><B>-R</B>, <B>--routing_engine</B> &lt;Routing engine names&gt;<DD>
This option chooses routing engine(s) to use instead of Min Hop
algorithm (default).  Multiple routing engines can be specified
separated by commas so that specific ordering of routing algorithms
will be tried if earlier routing engines fail.
Supported engines: minhop, updn, file, ftree, lash, dor
<DT><B>--do_mesh_analysis</B><DD>
This option enables additional analysis for the lash routing engine to
precondition switch port assignments in regular cartesian meshes which
may reduce the number of SLs required to give a deadlock free routing.
<DT><B>--lash_start_vl</B> &lt;vl number&gt;<DD>
This option sets the starting VL to use for the lash routing algorithm.
Defaults to 0.
<DT><B>-A</B>, <B>--ucast_cache</B><DD>
This option enables unicast routing cache and prevents routing
recalculation (which is a heavy task in a large cluster) when
there was no topology change detected during the heavy sweep, or
when the topology change does not require new routing calculation,
e.g. when one or more CAs/RTRs/leaf switches going down, or one or
more of these nodes coming back after being down.
A very common case that is handled by the unicast routing cache
is host reboot, which otherwise would cause two full routing
recalculations: one when the host goes down, and the other when
the host comes back online.
<DT><B>-z</B>, <B>--connect_roots</B><DD>
This option enforces routing engines (up/down and
fat-tree) to make connectivity between root switches and in
this way to be fully IBA complaint. In many cases this can
violate &quot;pure&quot; deadlock free algorithm, so use it carefully.
<DT><B>-M</B>, <B>--lid_matrix_file</B> &lt;file name&gt;<DD>
This option specifies the name of the lid matrix dump file
from where switch lid matrices (min hops tables will be
loaded.
<DT><B>-U</B>, <B>--lfts_file</B> &lt;file name&gt;<DD>
This option specifies the name of the LFTs file
from where switch forwarding tables will be loaded.
<DT><B>-S</B>, <B>--sadb_file</B> &lt;file name&gt;<DD>
This option specifies the name of the SA DB dump file
from where SA database will be loaded.
<DT><B>-a</B>, <B>--root_guid_file</B> &lt;file name&gt;<DD>
Set the root nodes for the Up/Down or Fat-Tree routing
algorithm to the guids provided in the given file (one to a line).
<DT><B>-u</B>, <B>--cn_guid_file</B> &lt;file name&gt;<DD>
Set the compute nodes for the Fat-Tree routing algorithm
to the guids provided in the given file (one to a line).
<DT><B>-G</B>, <B>--io_guid_file</B> &lt;file name&gt;<DD>
Set the I/O nodes for the Fat-Tree routing algorithm
to the guids provided in the given file (one to a line).
I/O nodes are non-CN nodes allowed to use up to max_reverse_hops switches
the wrong way around to improve connectivity.
<dl compact>
	<dt><b>--port-shifting</b> </dt>
	<dd>This option enables a feature called <b>port shifting</b>. In some 
	fabrics, particularly cluster environments, routes commonly align and 
	congest with other routes due to algorithmically unchanging traffic 
	patterns. This routing option will &quot;shift&quot; routing around in an attempt to 
	alleviate this problem. 
	</dd>
	<dt><b>--scatter-ports</b> </dt>
	<dd>This option will randomize port selecting in routing.</dd>
</dl>
<DT><B>-H</B>, <B>--max_reverse_hops</B> &lt;file name&gt;<DD>
Set the maximum number of reverse hops an I/O node is allowed
to make. A reverse hop is the use of a switch the wrong way around.
<DT><B>-m</B>, <B>--ids_guid_file</B> &lt;file name&gt;<DD>
Name of the map file with set of the IDs which will be used
by Up/Down routing algorithm instead of node GUIDs
(format: &lt;guid&gt; &lt;id&gt; per line).
<DT><B>-X</B>, <B>--guid_routing_order_file</B> &lt;file name&gt;<DD>
Set the order port guids will be routed for the MinHop
and Up/Down routing algorithms to the guids provided in the
given file (one to a line).
<DT><B>-o</B>, <B>--once</B><DD>
This option causes OpenSM to configure the subnet
once, then exit.  Ports remain in the ACTIVE state.
<DT><B>-s</B>, <B>--sweep</B> &lt;interval value&gt;<DD>
This option specifies the number of seconds between
subnet sweeps.  Specifying -s 0 disables sweeping.
Without -s, OpenSM defaults to a sweep interval of
10 seconds.
<DT><B>-t</B>, <B>--timeout</B> &lt;value&gt;<DD>
This option specifies the time in milliseconds
used for transaction timeouts.
Specifying -t 0 disables timeouts.
Without -t, OpenSM defaults to a timeout value of
200 milliseconds.
<DT><B>--retries</B> &lt;number&gt;<DD>
This option specifies the number of retries used
for transactions.
Without --retries, OpenSM defaults to 3 retries
for transactions.
<DT><B>-maxsmps</B> &lt;number&gt;<DD>
This option specifies the number of VL15 SMP MADs
allowed on the wire at any one time.
Specifying -maxsmps 0 allows unlimited outstanding
SMPs.
Without -maxsmps, OpenSM defaults to a maximum of
4 outstanding SMPs.
<DT><B>-console [off | local | socket | loopback]</B><DD>
This option brings up the OpenSM console (default off).
Note that the socket and loopback options will only be available
if OpenSM was built with --enable-console-socket.
<DT><B>-console-port</B> &lt;port&gt;<DD>
Specify an alternate telnet port for the socket console (default 10000).
Note that this option only appears if OpenSM was built with
--enable-console-socket.
<DT><B>-i</B>, <B>-ignore-guids</B> &lt;equalize-ignore-guids-file&gt;<DD>
This option provides the means to define a set of ports
(by node guid and port number) that will be ignored by the link load
equalization algorithm.
<DT><B>-w</B>, <B>--hop_weights_file</B> &lt;path to file&gt;<DD>
This option provides weighting factors per port representing a hop cost in
computing the lid matrix.  The file consists of lines containing a switch port
GUID (specified as a 64 bit hex number, with leading 0x), output port number,
and weighting factor.  Any port not listed in the file defaults to a weighting
factor of 1.  Lines starting with # are comments.  Weights affect only the
output route from the port, so many useful configurations will require weights
to be specified in pairs.
<dl compact>
	<dt><b>-O</b>, <b>--port_search_ordering_file</b> &lt;path to file&gt; </dt>
	<dd>This option tweaks the routing. It suitable for two cases: 1. While 
	using DOR routing algorithm. This option provides a mapping between 
	hypercube dimensions and ports on a per switch basis for the DOR routing 
	engine. The file consists of lines containing a switch node GUID (specified 
	as a 64 bit hex number, with leading 0x) followed by a list of non-zero port 
	numbers, separated by spaces, one switch per line. The order for the port 
	numbers is in one to one correspondence to the dimensions. Ports not listed 
	on a line are assigned to the remaining dimensions, in port order. Anything 
	after a # is a comment. 2. While using general routing algorithm. This 
	option provides the order of the ports that would be chosen for routing, 
	from each switch rather than searching for an appropriate port from port 1 
	to N. The file consists of lines containing a switch node GUID (specified as 
	a 64 bit hex number, with leading 0x) followed by a list of non-zero port 
	numbers, separated by spaces, one switch per line. In case of DOR, the order 
	for the port numbers is in one to one correspondence to the dimensions. 
	Ports not listed on a line are assigned to the remaining dimensions, in port 
	order. Anything after a # is a comment. </dd>
</dl>
<DT><b>-O, --dimn_ports_file &lt;path to file&gt;(DEPRECATED)</b><dd>This option provides a 
mapping between hypercube dimensions and ports on a per switch basis for the DOR 
routing engine. The file consists of lines containing a switch node GUID 
(specified as a 64 bit hex number, with leading 0x) followed by a list of 
non-zero port numbers, separated by spaces, one switch per line. The order for 
the port numbers is in one to one correspondence to the dimensions. Ports not 
listed on a line are assigned to the remaining dimensions, in port order. 
Anything after a # is a comment.</dd>
<DT><B>-x</B>, <B>--honor_guid2lid</B><DD>
This option forces OpenSM to honor the guid2lid file,
when it comes out of Standby state, if such file exists
under OSM_CACHE_DIR, and is valid.
By default, this is FALSE.
<DT><B>-f</B>, <B>--log_file</B> &lt;file name&gt;<DD>
This option defines the log to be the given file. By default, the log goes to 
%windir%\temp\opensm.log.
For the log to go to standard output use -f stdout.
<DT><B>-L</B>, <B>--log_limit</B> &lt;size in MB&gt;<DD>
This option defines maximal log file size in MB. When
specified the log file will be truncated upon reaching
this limit.
<DT><B>-e</B>, <B>--erase_log_file</B><DD>
This option will cause deletion of the log file
(if it previously exists). By default, the log file
is accumulative.
<DT><B>-P</B>, <B>--Pconfig</B> &lt;partition config file&gt;<DD>
This option defines the optional partition configuration file.
The default name is <B>%ProgramFiles%\OFED\opensm\partitions.conf</B>.
<DT><B>--prefix_routes_file</B> &lt;file name&gt;<DD>
Prefix routes control how the SA responds to path record queries for
off-subnet DGIDs.  By default, the SA fails such queries. The
<B>PREFIX ROUTES</B>

section below describes the format of the configuration file.
The default path is <B>%ProgramFiles%\OFED\opensm\prefix-routes.conf</B>.
<DT><B>-Q</B>, <B>--qos</B><DD>
This option enables QoS setup. It is disabled by default.
<DT><B>-Y</B>, <B>--qos_policy_file</B> &lt;file name&gt;<DD>
This option defines the optional QoS policy file. The default
name is <B>%ProgramFiles%\OFED\opensm\qos-policy.conf</B>. See
QoS_management_in_OpenSM.txt in opensm doc for more information on
configuring QoS policy via this file.
<DT><B>-N</B>, <B>--no_part_enforce</B><DD>
This option disables partition enforcement on switch external ports.
<DT><B>-y</B>, <B>--stay_on_fatal</B><DD>
This option will cause SM not to exit on fatal initialization
issues: if SM discovers duplicated guids or a 12x link with
lane reversal badly configured.
By default, the SM will exit on these errors.
<DT><B>-B</B>, <B>--service</B><DD>
OpenSM will run in the background (without a console window) as a Windows system 
service (the default Windows mode).
<DT><B>-I</B>, <B>--inactive</B><DD>
Start SM in inactive rather than init SM state.  This
option can be used in conjunction with the perfmgr so as to
run a standalone performance manager without SM/SA.  However,
this is NOT currently implemented in the performance manager.
<DT><B>-perfmgr</B><DD>
Enable the perfmgr.  Only takes effect if --enable-perfmgr was specified at
configure time.  See performance-manager-HOWTO.txt in opensm doc for
more information on running perfmgr.
<DT><B>-perfmgr_sweep_time_s</B> &lt;seconds&gt;<DD>
Specify the sweep time for the performance manager in seconds
(default is 180 seconds).  Only takes
effect if --enable-perfmgr was specified at configure time.
<DT><B>--consolidate_ipv6_snm_req</B><DD>
Use shared MLID for IPv6 Solicited Node Multicast groups per MGID scope
and P_Key.
<DT><B>-log_prefix &lt;prefix text&gt;</B><DD>
This option specifies the prefix to the syslog messages from OpenSM. A suitable 
prefix can be used to identify the IB subnet in syslog messages when two or more 
instances of OpenSM run in a single node to manage multiple fabrics. For 
example, in a dual-fabric (or dual-rail) IB cluster, the prefix for the first 
fabric could be &quot;mpi&quot; and the other fabric could be &quot;storage&quot;.
<dl compact>
	<dt><b>--torus_config</b> &lt;path to torus-2QoS config file&gt; </dt>
	<dd>This option defines the file name for the extra configuration 
	information needed for the torus-2QoS routing engine. The default name is<br>
	<b>%ProgramFiles%\OFED\opensm\torus-2QoS.conf</b> </dd>
</dl>
<DT><B>-v</B>, <B>--verbose</B><DD>
This option increases the log verbosity level.
The -v option may be specified multiple times
to further increase the verbosity level.
See the -D option for more information about
log verbosity.
<DT><B>-V</B><DD>
This option sets the maximum verbosity level and
forces log flushing.
The -V option is equivalent to '-D 0xFF -d 2'.
See the -D option for more information about
log verbosity.
<DT><B>-D</B> &lt;value&gt;<DD>
This option sets the log verbosity level.
A flags field must follow the -D option.
A bit set/clear in the flags enables/disables a
specific log level as follows:
<P>
&nbsp;BIT&nbsp;&nbsp;&nbsp;&nbsp;LOG&nbsp;LEVEL&nbsp;ENABLED
<BR>&nbsp;----&nbsp;&nbsp;&nbsp;-----------------
<BR>&nbsp;0x01&nbsp;-&nbsp;ERROR&nbsp;(error&nbsp;messages)
<BR>&nbsp;0x02&nbsp;-&nbsp;INFO&nbsp;(basic&nbsp;messages,&nbsp;low&nbsp;volume)
<BR>&nbsp;0x04&nbsp;-&nbsp;VERBOSE&nbsp;(interesting&nbsp;stuff,&nbsp;moderate&nbsp;volume)
<BR>&nbsp;0x08&nbsp;-&nbsp;DEBUG&nbsp;(diagnostic,&nbsp;high&nbsp;volume)
<BR>&nbsp;0x10&nbsp;-&nbsp;FUNCS&nbsp;(function&nbsp;entry/exit,&nbsp;very&nbsp;high&nbsp;volume)
<BR>&nbsp;0x20&nbsp;-&nbsp;FRAMES&nbsp;(dumps&nbsp;all&nbsp;SMP&nbsp;and&nbsp;GMP&nbsp;frames)
<BR>&nbsp;0x40&nbsp;-&nbsp;ROUTING&nbsp;(dump&nbsp;FDB&nbsp;routing&nbsp;information)
<BR>&nbsp;0x80&nbsp;-&nbsp;currently&nbsp;unused.
<P>
Without -D, OpenSM defaults to ERROR + INFO (0x3).
Specifying -D 0 disables all messages.
Specifying -D 0xFF enables all messages (see -V).
High verbosity levels may require increasing
the transaction timeout with the -t option.
<DT><B>-d</B>, <B>--debug</B> &lt;value&gt;<DD>
This option specifies a debug option.
These options are not normally needed.
The number following -d selects the debug
option to enable as follows:
<br>
<BR>&nbsp;OPT&nbsp;&nbsp;&nbsp;Description
<BR>&nbsp;---&nbsp;&nbsp;&nbsp;&nbsp;-----------------
<BR>&nbsp;-d0&nbsp;&nbsp;-&nbsp;Ignore&nbsp;other&nbsp;SM&nbsp;nodes
<BR>&nbsp;-d1&nbsp;&nbsp;-&nbsp;Force&nbsp;single&nbsp;threaded&nbsp;dispatching
<BR>&nbsp;-d2&nbsp;&nbsp;-&nbsp;Force&nbsp;log&nbsp;flushing&nbsp;after&nbsp;each&nbsp;log&nbsp;message
<BR>&nbsp;-d3&nbsp;&nbsp;-&nbsp;Disable&nbsp;multicast&nbsp;support
<DT><B>-h</B>, <B>--help</B><DD>
Display this usage info then exit.
<DT><B>-?</B><DD>
Display this usage info then exit.
<P>
</DL>
<h3>ENVIRONMENT VARIABLES</h3>

<P>

The following environment variables control opensm behavior:<ul>
	<li>OSM_TMP_DIR - controls the directory in which the temporary files generated by
opensm are created.<br>
	These files are: opensm-subnet.lst, opensm.fdbs, and
opensm.mcfdbs. By default, this directory is %ProgramFiles%\OFED\OpenSM\.</li>
	<li>OSM_CACHE_DIR - opensm stores certain data to the disk such that 
	subsequent runs are consistent. The default directory used is<br>
	%ProgramFiles%\OFED\OpenSM\.<BR>&nbsp;&nbsp;&nbsp;&nbsp; guid2lid&nbsp;-&nbsp;stores&nbsp;the&nbsp;LID&nbsp;range&nbsp;assigned&nbsp;to&nbsp;each&nbsp;GUID<br>
&nbsp;</li>
	</ul>
<h3>NOTES</h3>

<P>

When opensm running as a windows service, if the opensm process receives a service control code of 
129, it starts a new heavy sweep as if a trap was received or a topology change was found.<P>

Also, service control code 128 can be used to trigger a reopen of %windir%\temp\osm.log for
logrotate purposes.<br>
&nbsp;<P>

Examples:<P>

&nbsp;&nbsp;&nbsp; sc.exe control OpenSM 128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
# will clear the contents of %windir%\temp\osm.log, logrotate.<br>
&nbsp;&nbsp;&nbsp; sc.exe control OpenSM 129&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
# start a new heavy sweep<P>

&nbsp;<h3>PARTITION CONFIGURATION</h3>

<P>

The default name of OpenSM partitions configuration file is
<B>%ProgramFiles\OFED\OpenSM\partitions.conf</B>. The default may be changed
by using the --Pconfig (-P) option with OpenSM.
<P>
The default partition will be created by OpenSM unconditionally even
when partition configuration file does not exist or cannot be accessed.
<P>
The default partition has P_Key value 0x7fff. OpenSM's port will always
have full membership in default partition. All other end ports will have
full membership if the partition configuration file is not found or cannot
be accessed, or limited membership if the file exists and can be accessed
but there is no rule for the Default partition.
<P>
Effectively, this amounts to the same as if one of the following rules
below appear in the partition configuration file.
<P>
In the case of no rule for the Default partition:
<P>
Default=0x7fff : ALL=limited, SELF=full ;
<P>
In the case of no partition configuration file or file cannot be accessed:
<P>
Default=0x7fff : ALL=full ;
<P>
<P>
File Format
<P>
Comments:
<P>
Line content followed after '#' character is comment and ignored by
parser.
<P>
General file format:
<P>
&lt;Partition Definition&gt;:[&lt;newline&gt;]&lt;Partition Properties&gt;;<br>
<br>
&nbsp;&nbsp;&nbsp; Partition Definition:<blockquote>
	<P>[PartitionName][=PKey][,ipoib_bc_flags][,defmember=full|limited]<br>
	<br>
	PartitionName - string, will be used with logging. When omitted empty string 
	will be used.<br>
	PKey - P_Key value for this partition. Only low 15 bits will be used. When 
	omitted will be autogenerated.<P>ipoib_bc_flags - used to indicate/specify 
	IPoIB capability of this partition.<br>
	<br>
	defmember=full|limited - specifies default membership for port guid list. 
	Default is limited.<br>
	<br>
	ipoib_bc_flags:<br>
&nbsp;&nbsp;&nbsp; ipoib_flag|[mgroup_flag]*<br>
	<br>
&nbsp;&nbsp;&nbsp; ipoib_flag - indicates that this partition may be used for 
	IPoIB, as a result the IPoIB broadcast group will be created with the flags 
	given, if any.<br>
	<br>
	Partition Properties:<br>
&nbsp;&nbsp;&nbsp; [&lt;Port list&gt;|&lt;MCast Group&gt;]* | &lt;Port list&gt;<br>
	<br>
	Port list:<br>
&nbsp;&nbsp;&nbsp; &lt;Port Specifier&gt;[,&lt;Port Specifier&gt;]<br>
	<br>
	Port Specifier:<br>
&nbsp;&nbsp;&nbsp; &lt;PortGUID&gt;[=[full|limited]]<br>
	<br>
	PortGUID - GUID of partition member EndPort. Hexadecimal numbers should 
	start from 0x, decimal numbers<br>
	are accepted too.<br>
	full or limited - indicates full or limited membership for this port. When 
	omitted (or unrecognized) limited<br>
	membership is assumed.<br>
	<br>
	MCast Group:<br>
&nbsp;&nbsp;&nbsp; mgid=gid[,mgroup_flag]*&lt;newline&gt;<br>
	<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - gid specified is verified to be a 
	Multicast address<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IP groups are verified to match the 
	rate and mtu of the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; broadcast group. The P_Key bits of 
	the mgid for IP<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; groups are verified to either match 
	the P_Key specified<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in by &quot;Partition Definition&quot; or if 
	they are 0x0000 the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P_Key will be copied into those bits.<br>
	<br>
	mgroup_flag:<br>
&nbsp;&nbsp;&nbsp; rate=&lt;val&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	- specifies rate for this MC group (default is 3 (10GBps))<br>
&nbsp;&nbsp;&nbsp; mtu=&lt;val&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	- specifies MTU for this MC group (default is 4 (2048))<br>
&nbsp;&nbsp;&nbsp; sl=&lt;val&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	- specifies SL for this MC group (default is 0)<br>
&nbsp;&nbsp;&nbsp; scope=&lt;val&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 
	specifies scope for this MC group (default is 2 (link local)). Multiple 
	scope settings<br>
&nbsp;&nbsp;&nbsp; are permitted for a partition.<br>
&nbsp;&nbsp;&nbsp; NOTE: This overwrites the scope nibble of the specified mgid. 
	Furthermore specifying multiple scope<br>
&nbsp;&nbsp;&nbsp; settings will result in multiple MC groups being created.<br>
&nbsp;&nbsp;&nbsp; qkey=&lt;val&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	- specifies the Q_Key for this MC group (default: 0x0b1b for IP groups, 0 
	for other groups)<br>
&nbsp;&nbsp;&nbsp; tclass=&lt;val&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	- specifies tclass for this MC group (default is 0)<br>
&nbsp;&nbsp;&nbsp; FlowLabel=&lt;val&gt; - specifies FlowLabel for this MC group 
	(default is 0)<br>
	<br>
	newline: '\n'<br>
	<br>
	Note that values for rate, mtu, and scope, for both partitions and multicast<br>
	groups, should be specified as defined in the IBTA specification (for 
	example, mtu=4 for 2048).</blockquote>
<P>
There are two useful keywords for PortGUID definition:
<P>
&nbsp;-&nbsp;'ALL'&nbsp;means&nbsp;all&nbsp;end&nbsp;ports&nbsp;in&nbsp;this&nbsp;subnet.
<BR>&nbsp;-&nbsp;'ALL_CAS'&nbsp;means&nbsp;all&nbsp;Channel&nbsp;Adapter&nbsp;end&nbsp;ports&nbsp;in&nbsp;this&nbsp;subnet.
<BR>&nbsp;-&nbsp;'ALL_SWITCHES'&nbsp;means&nbsp;all&nbsp;Switch&nbsp;end&nbsp;ports&nbsp;in&nbsp;this&nbsp;subnet.
<BR>&nbsp;-&nbsp;'ALL_ROUTERS'&nbsp;means&nbsp;all&nbsp;Router&nbsp;end&nbsp;ports&nbsp;in&nbsp;this&nbsp;subnet.
<BR>&nbsp;-&nbsp;'SELF'&nbsp;means&nbsp;subnet&nbsp;manager's&nbsp;port.
<P>
Empty list means no ports in this partition.
<P>
Notes:
<P>
White space is permitted between delimiters ('=', ',',':',';').
<P>
PartitionName does not need to be unique, PKey does need to be unique.
If PKey is repeated then those partition configurations will be merged
and first PartitionName will be used (see also next note).
<P>
It is possible to split partition configuration in more than one
definition, but then PKey should be explicitly specified (otherwise
different PKey values will be generated for those definitions).
<P>
Examples:
<P>
&nbsp;Default=0x7fff&nbsp;:&nbsp;ALL,&nbsp;SELF=full&nbsp;;
<BR>&nbsp;Default=0x7fff&nbsp;:&nbsp;ALL,&nbsp;ALL_SWITCHES=full,&nbsp;SELF=full&nbsp;;
<P>
&nbsp;NewPartition&nbsp;,&nbsp;ipoib&nbsp;:&nbsp;0x123456=full,&nbsp;0x3456789034=limi,&nbsp;0x2134af2306&nbsp;;
<P>
&nbsp;YetAnotherOne&nbsp;=&nbsp;0x300&nbsp;:&nbsp;SELF=full&nbsp;;
<BR>&nbsp;YetAnotherOne&nbsp;=&nbsp;0x300&nbsp;:&nbsp;ALL=limited&nbsp;;
<P>
&nbsp;ShareIO&nbsp;=&nbsp;0x80&nbsp;,&nbsp;defmember=full&nbsp;:&nbsp;0x123451,&nbsp;0x123452;
<BR>&nbsp;#&nbsp;0x123453,&nbsp;0x123454&nbsp;will&nbsp;be&nbsp;limited
<BR>&nbsp;ShareIO&nbsp;=&nbsp;0x80&nbsp;:&nbsp;0x123453,&nbsp;0x123454,&nbsp;0x123455=full;
<BR>&nbsp;#&nbsp;0x123456,&nbsp;0x123457&nbsp;will&nbsp;be&nbsp;limited
<BR>&nbsp;ShareIO&nbsp;=&nbsp;0x80&nbsp;:&nbsp;defmember=limited&nbsp;:&nbsp;0x123456,&nbsp;0x123457,&nbsp;0x123458=full;
<BR>&nbsp;ShareIO&nbsp;=&nbsp;0x80&nbsp;,&nbsp;defmember=full&nbsp;:&nbsp;0x123459,&nbsp;0x12345a;
<BR>&nbsp;ShareIO&nbsp;=&nbsp;0x80&nbsp;,&nbsp;defmember=full&nbsp;:&nbsp;0x12345b,&nbsp;0x12345c=limited,&nbsp;0x12345d;
<P>
&nbsp;# multicast groups added to default<br>
Default=0x7fff,ipoib:<br>
&nbsp;&nbsp;&nbsp; mgid=ff12:401b::0707,sl=1 # random IPv4 group<br>
&nbsp;&nbsp;&nbsp; mgid=ff12:601b::16 # MLDv2-capable routers<br>
&nbsp;&nbsp;&nbsp; mgid=ff12:401b::16 # IGMP<br>
&nbsp;&nbsp;&nbsp; mgid=ff12:601b::2 # All routers<br>
&nbsp;&nbsp;&nbsp; mgid=ff12::1,sl=1,Q_Key=0xDEADBEEF,rate=3,mtu=2 # random 
group<br>
&nbsp;&nbsp;&nbsp; ALL=full;<br>
<br>
Note:
<P>
The following rule is equivalent to how OpenSM used to run prior to the
partition manager:
<P>
&nbsp;Default=0x7fff,ipoib:ALL=full;

<A NAME="lbAI">&nbsp;</A>
<h3>QOS CONFIGURATION</h3>

<P>

There are a set of QoS related low-level configuration parameters.
All these parameter names are prefixed by &quot;qos_&quot; string. Here is a full
list of these parameters:
<P>
&nbsp;qos_max_vls&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;The&nbsp;maximum&nbsp;number&nbsp;of&nbsp;VLs&nbsp;that&nbsp;will&nbsp;be&nbsp;on&nbsp;the&nbsp;subnet
<BR>&nbsp;qos_high_limit&nbsp;-&nbsp;The&nbsp;limit&nbsp;of&nbsp;High&nbsp;Priority&nbsp;component&nbsp;of&nbsp;VL
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arbitration&nbsp;table&nbsp;(IBA&nbsp;7.6.9)
<BR>&nbsp;qos_vlarb_low&nbsp;&nbsp;-&nbsp;Low&nbsp;priority&nbsp;VL&nbsp;Arbitration&nbsp;table&nbsp;(IBA&nbsp;7.6.9)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;template
<BR>&nbsp;qos_vlarb_high&nbsp;-&nbsp;High&nbsp;priority&nbsp;VL&nbsp;Arbitration&nbsp;table&nbsp;(IBA&nbsp;7.6.9)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;template
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Both&nbsp;VL&nbsp;arbitration&nbsp;templates&nbsp;are&nbsp;pairs&nbsp;of
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VL&nbsp;and&nbsp;weight
<BR>&nbsp;qos_sl2vl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;SL2VL&nbsp;Mapping&nbsp;table&nbsp;(IBA&nbsp;7.6.6)&nbsp;template.&nbsp;It&nbsp;is
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;list&nbsp;of&nbsp;VLs&nbsp;corresponding&nbsp;to&nbsp;SLs&nbsp;0-15&nbsp;(Note
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that&nbsp;VL15&nbsp;used&nbsp;here&nbsp;means&nbsp;drop&nbsp;this&nbsp;SL)
<P>
Typical default values (hard-coded in OpenSM initialization) are:
<P>
&nbsp;qos_max_vls&nbsp;15
<BR>&nbsp;qos_high_limit&nbsp;0
<BR>&nbsp;qos_vlarb_low&nbsp;0:0,1:4,2:4,3:4,4:4,5:4,6:4,7:4,8:4,9:4,10:4,11:4,12:4,13:4,14:4
<BR>&nbsp;qos_vlarb_high&nbsp;0:4,1:0,2:0,3:0,4:0,5:0,6:0,7:0,8:0,9:0,10:0,11:0,12:0,13:0,14:0
<BR>&nbsp;qos_sl2vl&nbsp;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,7
<P>
The syntax is compatible with rest of OpenSM configuration options and
values may be stored in OpenSM config file (cached options file).
<P>
In addition to the above, we may define separate QoS configuration
parameters sets for various target types. As targets, we currently support
CAs, routers, switch external ports, and switch's enhanced port 0. The
names of such specialized parameters are prefixed by &quot;qos_&lt;type&gt;_&quot;
string. Here is a full list of the currently supported sets:
<P>
&nbsp;qos_ca_&nbsp;&nbsp;-&nbsp;QoS&nbsp;configuration&nbsp;parameters&nbsp;set&nbsp;for&nbsp;CAs.
<BR>&nbsp;qos_rtr_&nbsp;-&nbsp;parameters&nbsp;set&nbsp;for&nbsp;routers.
<BR>&nbsp;qos_sw0_&nbsp;-&nbsp;parameters&nbsp;set&nbsp;for&nbsp;switches'&nbsp;port&nbsp;0.
<BR>&nbsp;qos_swe_&nbsp;-&nbsp;parameters&nbsp;set&nbsp;for&nbsp;switches'&nbsp;external&nbsp;ports.
<P>
Examples:
<BR>&nbsp;qos_sw0_max_vls=2
<BR>&nbsp;qos_ca_sl2vl=0,1,2,3,5,5,5,12,12,0,
<BR>&nbsp;qos_swe_high_limit=0

<A NAME="lbAJ">&nbsp;</A>
<h3>PREFIX ROUTES</h3>

<P>

Prefix routes control how the SA responds to path record queries for
off-subnet DGIDs.  By default, the SA fails such queries.
Note that IBA does not specify how the SA should obtain off-subnet path
record information.
The prefix routes configuration is meant as a stop-gap until the
specification is completed.
<P>

Each line in the configuration file is a 64-bit prefix followed by a
64-bit GUID, separated by white space.
The GUID specifies the router port on the local subnet that will
handle the prefix.
Blank lines are ignored, as is anything between a <B>#</B> character
and the end of the line.
The prefix and GUID are both in hex, the leading 0x is optional.
Either, or both, can be wild-carded by specifying an
asterisk instead of an explicit prefix or GUID.
<P>

When responding to a path record query for an off-subnet DGID,
opensm searches for the first prefix match in the configuration file.
Therefore, the order of the lines in the configuration file is important:
a wild-carded prefix at the beginning of the configuration file renders
all subsequent lines useless.
If there is no match, then opensm fails the query.
It is legal to repeat prefixes in the configuration file,
opensm will return the path to the first available matching router.
A configuration file with a single line where both prefix and GUID
are wild-carded means that a path record query specifying any
off-subnet DGID should return a path to the first available router.
This configuration yields the same behavior formerly achieved by
compiling opensm with -DROUTER_EXP which has been obsoleted.<br>
&nbsp;<h3>ROUTING</h3>

<p>OpenSM now offers seven routing engines: </p>
<p>1. Min Hop Algorithm - based on the minimum hops to each node where the path 
length is optimized. </p>
<p>2. UPDN Unicast routing algorithm - also based on the minimum hops to each 
node, but it is constrained to ranking rules. This algorithm should be chosen if 
the subnet is not a pure Fat Tree, and deadlock may occur due to a loop in the 
subnet. </p>
<p>3. DNUP Unicast routing algorithm - similar to UPDN but allows routing in 
fabrics which have some CA nodes attached closer to the roots than some switch 
nodes. </p>
<p>4. Fat Tree Unicast routing algorithm - this algorithm optimizes routing for 
congestion-free &quot;shift&quot; communication pattern. It should be chosen if a subnet 
is a symmetrical or almost symmetrical fat-tree of various types, not just K-ary-N-Trees: 
non-constant K, not fully staffed, any Constant Bisectional Bandwidth (CBB) 
ratio. Similar to UPDN, Fat Tree routing is constrained to ranking rules. </p>
<p>5. LASH unicast routing algorithm - uses Infiniband virtual layers (SL) to 
provide deadlock-free shortest-path routing while also distributing the paths 
between layers. LASH is an alternative deadlock-free topology-agnostic routing 
algorithm to the non-minimal UPDN algorithm avoiding the use of a potentially 
congested root node. </p>
<p>6. DOR Unicast routing algorithm - based on the Min Hop algorithm, but avoids 
port equalization except for redundant links between the same two switches. This 
provides deadlock free routes for hypercubes when the fabric is cabled as a 
hypercube and for meshes when cabled as a mesh (see details below). </p>
<p>7. Torus-2QoS unicast routing algorithm - a DOR-based routing algorithm 
specialized for 2D/3D torus topologies. Torus-2QoS provides deadlock-free 
routing while supporting two quality of service (QoS) levels. In addition it is 
able to route around multiple failed fabric links or a single failed fabric 
switch without introducing deadlocks, and without changing path SL values 
granted before the failure. </p>
<p>OpenSM also supports a file method which can load routes from a table. See 
'Modular Routing Engine' for more information on this. </p>
<p>The basic routing algorithm is comprised of two stages: </p>
<p>1. MinHop matrix calculation <br>
How many hops are required to get from each port to each LID ? <br>
The algorithm to fill these tables is different if you run standard (min hop) or 
Up/Down. <br>
For standard routing, a &quot;relaxation&quot; algorithm is used to propagate min hop from 
every destination LID through neighbor switches <br>
For Up/Down routing, a BFS from every target is used. The BFS tracks link 
direction (up or down) and avoid steps that will perform up after a down step 
was used. </p>
<p>2. Once MinHop matrices exist, each switch is visited and for each target LID 
a decision is made as to what port should be used to get to that LID. <br>
This step is common to standard and Up/Down routing. Each port has a counter 
counting the number of target LIDs going through it. <br>
When there are multiple alternative ports with same MinHop to a LID, the one 
with less previously assigned LIDs is selected. <br>
If LMC &gt; 0, more checks are added: Within each group of LIDs assigned to same 
target port, <br>
a. use only ports which have same MinHop <br>
b. first prefer the ones that go to different systemImageGuid (then the previous 
LID of the same LMC group) <br>
c. if none - prefer those which go through another NodeGuid <br>
d. fall back to the number of paths method (if all go to same node). </p>
<p>Effect of Topology Changes </p>
<p>OpenSM will preserve existing routing in any case where there is no change in 
the fabric switches unless the -r (--reassign_lids) option is specified. </p>
<p>-r <br>
--reassign_lids <br>
This option causes OpenSM to reassign LIDs to all <br>
end nodes. Specifying -r on a running subnet <br>
may disrupt subnet traffic. <br>
Without -r, OpenSM attempts to preserve existing <br>
LID assignments resolving multiple use of same LID. </p>
<p>If a link is added or removed, OpenSM does not recalculate the routes that do 
not have to change. A route has to change if the port is no longer UP or no 
longer the MinHop. When routing changes are performed, the same algorithm for 
balancing the routes is invoked. </p>
<p>In the case of using the file based routing, any topology changes are 
currently ignored The 'file' routing engine just loads the LFTs from the file 
specified, with no reaction to real topology. Obviously, this will not be able 
to recheck LIDs (by GUID) for disconnected nodes, and LFTs for non-existent 
switches will be skipped. Multicast is not affected by 'file' routing engine 
(this uses min hop tables). </p>
<p><b>Min Hop Algorithm</b> </p>
<p>The Min Hop algorithm is invoked by default if no routing algorithm is 
specified. It can also be invoked by specifying '-R minhop'. </p>
<p>The Min Hop algorithm is divided into two stages: computation of min-hop 
tables on every switch and LFT output port assignment. Link subscription is also 
equalized with the ability to override based on port GUID. The latter is 
supplied by: </p>
<p>-i &lt;equalize-ignore-guids-file&gt; <br>
-ignore-guids &lt;equalize-ignore-guids-file&gt; <br>
This option provides the means to define a set of ports <br>
(by guid) that will be ignored by the link load <br>
equalization algorithm. Note that only endports (CA, <br>
switch port 0, and router ports) and not switch external <br>
ports are supported. </p>
<p>LMC awareness routes based on (remote) system or switch basis. </p>
<p><b>Purpose of UPDN Algorithm</b> </p>
<p>The UPDN algorithm is designed to prevent deadlocks from occurring in loops 
of the subnet. A loop-deadlock is a situation in which it is no longer possible 
to send data between any two hosts connected through the loop. As such, the UPDN 
routing algorithm should be used if the subnet is not a pure Fat Tree, and one 
of its loops may experience a deadlock (due, for example, to high pressure). </p>
<p>The UPDN algorithm is based on the following main stages: </p>
<p>1. Auto-detect root nodes - based on the CA hop length from any switch in the 
subnet, a statistical histogram is built for each switch (hop num vs number of 
occurrences). If the histogram reflects a specific column (higher than others) 
for a certain node, then it is marked as a root node. Since the algorithm is 
statistical, it may not find any root nodes. The list of the root nodes found by 
this auto-detect stage is used by the ranking process stage. </p>
<p><br>
Note 1: The user can override the node list manually. <br>
Note 2: If this stage cannot find any root nodes, and the user did <br>
not specify a guid list file, OpenSM defaults back to the <br>
Min Hop routing algorithm. </p>
<p>2. Ranking process - All root switch nodes (found in stage 1) are assigned a 
rank of 0. Using the BFS algorithm, the rest of the switch nodes in the subnet 
are ranked incrementally. This ranking aids in the process of enforcing rules 
that ensure loop-free paths. </p>
<p>3. Min Hop Table setting - after ranking is done, a BFS algorithm is run from 
each (CA or switch) node in the subnet. During the BFS process, the FDB table of 
each switch node traversed by BFS is updated, in reference to the starting node, 
based on the ranking rules and guid values. </p>
<p>At the end of the process, the updated FDB tables ensure loop-free paths 
through the subnet. </p>
<p>Note: Up/Down routing does not allow LID routing communication between 
switches that are located inside spine &quot;switch systems&quot;. The reason is that 
there is no way to allow a LID route between them that does not break the 
Up/Down rule. One ramification of this is that you cannot run SM on switches 
other than the leaf switches of the fabric. </p>
<p>UPDN Algorithm Usage </p>
<p>Activation through OpenSM </p>
<p>Use '-R updn' option (instead of old '-u') to activate the UPDN algorithm. 
Use '-a &lt;root_guid_file&gt;' for adding an UPDN guid file that contains the root 
nodes for ranking. If the `-a' option is not used, OpenSM uses its auto-detect 
root nodes algorithm. </p>
<p>Notes on the guid list file: </p>
<p>1. A valid guid file specifies one guid in each line. Lines with an invalid 
format will be discarded. <br>
2. The user should specify the root switch guids. However, it is also possible 
to specify CA guids; OpenSM will use the guid of the switch (if it exists) that 
connects the CA to the subnet as a root node. </p>
<p>Purpose of DNUP Algorithm </p>
<p>The DNUP algorithm is designed to serve a similar purpose to UPDN. However it 
is intended to work in network topologies which are unsuited to UPDN due to 
nodes being connected closer to the roots than some of the switches. An example 
would be a fabric which contains nodes and uplinks connected to the same switch. 
The operation of DNUP is the same as UPDN with the exception of the ranking 
process. In DNUP all switch nodes are ranked based solely on their distance from 
CA Nodes, all switch nodes directly connected to at least one CA are assigned a 
value of 1 all other switch nodes are assigned a value of one more than the 
minimum rank of all neighbor switch nodes. </p>
<p><b>Fat-tree Routing Algorithm </b></p>
<p>The fat-tree algorithm optimizes routing for &quot;shift&quot; communication pattern. 
It should be chosen if a subnet is a symmetrical or almost symmetrical fat-tree 
of various types. It supports not just K-ary-N-Trees, by handling for 
non-constant K, cases where not all leafs (CAs) are present, any CBB ratio. As 
in UPDN, fat-tree also prevents credit-loop-deadlocks. </p>
<p>If the root guid file is not provided ('-a' or '--root_guid_file' options), 
the topology has to be pure fat-tree that complies with the following rules: <br>
- Tree rank should be between two and eight (inclusively) <br>
- Switches of the same rank should have the same number <br>
of UP-going port groups*, unless they are root switches, <br>
in which case the shouldn't have UP-going ports at all. <br>
- Switches of the same rank should have the same number <br>
of DOWN-going port groups, unless they are leaf switches. <br>
- Switches of the same rank should have the same number <br>
of ports in each UP-going port group. <br>
- Switches of the same rank should have the same number <br>
of ports in each DOWN-going port group. <br>
- All the CAs have to be at the same tree level (rank). </p>
<p>If the root guid file is provided, the topology doesn't have to be pure 
fat-tree, and it should only comply with the following rules: <br>
- Tree rank should be between two and eight (inclusively) <br>
- All the Compute Nodes** have to be at the same tree level (rank). <br>
Note that non-compute node CAs are allowed here to be at different <br>
tree ranks. </p>
<p>* ports that are connected to the same remote switch are referenced as 'port 
group'. </p>
<p>** list of compute nodes (CNs) can be specified by '-u' or '--cn_guid_file' 
OpenSM options. </p>
<p>Topologies that do not comply cause a fallback to min hop routing. Note that 
this can also occur on link failures which cause the topology to no longer be 
&quot;pure&quot; fat-tree. </p>
<p>Note that although fat-tree algorithm supports trees with non-integer CBB 
ratio, the routing will not be as balanced as in case of integer CBB ratio. In 
addition to this, although the algorithm allows leaf switches to have any number 
of CAs, the closer the tree is to be fully populated, the more effective the 
&quot;shift&quot; communication pattern will be. In general, even if the root list is 
provided, the closer the topology to a pure and symmetrical fat-tree, the more 
optimal the routing will be. </p>
<p>The algorithm also dumps compute node ordering file (opensm-ftree-ca-order.dump) 
in the same directory where the OpenSM log resides. This ordering file provides 
the CN order that may be used to create efficient communication pattern, that 
will match the routing tables. </p>
<p>Routing between non-CN nodes </p>
<p>The use of the cn_guid_file option allows non-CN nodes to be located on 
different levels in the fat tree. In such case, it is not guaranteed that the 
Fat Tree algorithm will route between two non-CN nodes. To solve this problem, a 
list of non-CN nodes can be specified by '-G' or '--io_guid_file' option. Theses 
nodes will be allowed to use switches the wrong way round a specific number of 
times (specified by '-H' or '--max_reverse_hops'. With the proper 
max_reverse_hops and io_guid_file values, you can ensure full connectivity in 
the Fat Tree. </p>
<p>Please note that using max_reverse_hops creates routes that use the switch in 
a counter-stream way. This option should never be used to connect nodes with 
high bandwidth traffic between them ! It should only be used to allow 
connectivity for HA purposes or similar. Also having routes the other way around 
can in theory cause credit loops. </p>
<p>Use these options with extreme care ! </p>
<p>Activation through OpenSM </p>
<p>Use '-R ftree' option to activate the fat-tree algorithm. Use '-a &lt;root_guid_file&gt;' 
to provide root nodes for ranking. If the `-a' option is not used, routing 
algorithm will detect roots automatically. Use '-u &lt;root_cn_file&gt;' to provide 
the list of compute nodes. If the `-u' option is not used, all the CAs are 
considered as compute nodes. </p>
<p>Note: LMC &gt; 0 is not supported by fat-tree routing. If this is specified, the 
default routing algorithm is invoked instead. </p>
<p><b>LASH Routing Algorithm</b> </p>
<p>LASH is an acronym for LAyered SHortest Path Routing. It is a deterministic 
shortest path routing algorithm that enables topology agnostic deadlock-free 
routing within communication networks. </p>
<p>When computing the routing function, LASH analyzes the network topology for 
the shortest-path routes between all pairs of sources / destinations and groups 
these paths into virtual layers in such a way as to avoid deadlock. </p>
<p>Note LASH analyzes routes and ensures deadlock freedom between switch pairs. 
The link from HCA between and switch does not need virtual layers as deadlock 
will not arise between switch and HCA. </p>
<p>In more detail, the algorithm works as follows: </p>
<p>1) LASH determines the shortest-path between all pairs of source / 
destination switches. Note, LASH ensures the same SL is used for all SRC/DST - 
DST/SRC pairs and there is no guarantee that the return path for a given DST/SRC 
will be the reverse of the route SRC/DST. </p>
<p>2) LASH then begins an SL assignment process where a route is assigned to a 
layer (SL) if the addition of that route does not cause deadlock within that 
layer. This is achieved by maintaining and analysing a channel dependency graph 
for each layer. Once the potential addition of a path could lead to deadlock, 
LASH opens a new layer and continues the process. </p>
<p>3) Once this stage has been completed, it is highly likely that the first 
layers processed will contain more paths than the latter ones. To better balance 
the use of layers, LASH moves paths from one layer to another so that the number 
of paths in each layer averages out. </p>
<p>Note, the implementation of LASH in opensm attempts to use as few layers as 
possible. This number can be less than the number of actual layers available.
</p>
<p>In general LASH is a very flexible algorithm. It can, for example, reduce to 
Dimension Order Routing in certain topologies, it is topology agnostic and fares 
well in the face of faults. </p>
<p>It has been shown that for both regular and irregular topologies, LASH 
outperforms Up/Down. The reason for this is that LASH distributes the traffic 
more evenly through a network, avoiding the bottleneck issues related to a root 
node and always routes shortest-path. </p>
<p>The algorithm was developed by Simula Research Laboratory. </p>
<p>Use '-R lash -Q ' option to activate the LASH algorithm. </p>
<p>Note: QoS support has to be turned on in order that SL/VL mappings are used.
</p>
<p>Note: LMC &gt; 0 is not supported by the LASH routing. If this is specified, the 
default routing algorithm is invoked instead. </p>
<p>For open regular cartesian meshes the DOR algorithm is the ideal routing 
algorithm. For toroidal meshes on the other hand there are routing loops that 
can cause deadlocks. LASH can be used to route these cases. The performance of 
LASH can be improved by preconditioning the mesh in cases where there are 
multiple links connecting switches and also in cases where the switches are not 
cabled consistently. An option exists for LASH to do this. To invoke this use 
'-R lash -Q --do_mesh_analysis'. This will add an additional phase that analyses 
the mesh to try to determine the dimension and size of a mesh. If it determines 
that the mesh looks like an open or closed cartesian mesh it reorders the ports 
in dimension order before the rest of the LASH algorithm runs. </p>
<p>DOR Routing Algorithm </p>
<p>The Dimension Order Routing algorithm is based on the Min Hop algorithm and 
so uses shortest paths. Instead of spreading traffic out across different paths 
with the same shortest distance, it chooses among the available shortest paths 
based on an ordering of dimensions. Each port must be consistently cabled to 
represent a hypercube dimension or a mesh dimension. Alternatively, the -O 
option can be used to assign a custom mapping between the ports on a given 
switch, and the associated dimension. Paths are grown from a destination back to 
a source using the lowest dimension (port) of available paths at each step. This 
provides the ordering necessary to avoid deadlock. When there are multiple links 
between any two switches, they still represent only one dimension and traffic is 
balanced across them unless port equalization is turned off. In the case of 
hypercubes, the same port must be used throughout the fabric to represent the 
hypercube dimension and match on both ends of the cable, or the -O option used 
to accomplish the alignment. In the case of meshes, the dimension should 
consistently use the same pair of ports, one port on one end of the cable, and 
the other port on the other end, continuing along the mesh dimension, or the -O 
option used as an override. </p>
<p>Use '-R dor' option to activate the DOR algorithm. </p>
<p>Torus-2QoS Routing Algorithm </p>
<p>Torus-2QoS is routing algorithm designed for large-scale 2D/3D torus fabrics; 
see <a href="http://localhost/cgi-bin/man/man2html?8+torus-2QoS">torus-2QoS</a>(8) 
for full documentation. </p>
<p>Use '-R torus-2QoS -Q' or '-R torus-2QoS,no_fallback -Q' to activate the 
torus-2QoS algorithm. </p>
<p>Routing References </p>
<p>To learn more about deadlock-free routing, see the article &quot;Deadlock Free 
Message Routing in Multiprocessor Interconnection Networks&quot; by William J Dally 
and Charles L Seitz (1985). </p>
<p>To learn more about the up/down algorithm, see the article &quot;Effective 
Strategy to Compute Forwarding Tables for InfiniBand Networks&quot; by Jose Carlos 
Sancho, Antonio Robles, and Jose Duato at the Universidad Politecnica de 
Valencia. </p>
<p>To learn more about LASH and the flexibility behind it, the requirement for 
layers, performance comparisons to other algorithms, see the following articles:
</p>
<p>&quot;Layered Routing in Irregular Networks&quot;, Lysne et al, IEEE Transactions on 
Parallel and Distributed Systems, VOL.16, No12, December 2005. </p>
<p>&quot;Routing for the ASI Fabric Manager&quot;, Solheim et al. IEEE Communications 
Magazine, Vol.44, No.7, July 2006. </p>
<p>&quot;Layered Shortest Path (LASH) Routing in Irregular System Area Networks&quot;, 
Skeie et al. IEEE Computer Society Communication Architecture for Clusters 2002.
</p>
<p><b>Modular Routine Engine</b> </p>
<p>Modular routing engine structure allows for the ease of &quot;plugging&quot; new 
routing modules. </p>
<p>Currently, only unicast callbacks are supported. Multicast can be added 
later. </p>
<p>One existing routing module is up-down &quot;updn&quot;, which may be activated with 
'-R updn' option (instead of old '-u'). </p>
<p>General usage is: $ opensm -R 'module-name' </p>
<p>There is also a trivial routing module which is able to load LFT tables from 
a file. </p>
<p>Main features: <br>
- this will load switch LFTs and/or LID matrices (min hops tables) <br>
- this will load switch LFTs according to the path entries introduced <br>
in the file <br>
- no additional checks will be performed (such as &quot;is port connected&quot;, <br>
etc.) <br>
- in case when fabric LIDs were changed this will try to reconstruct <br>
LFTs correctly if endport GUIDs are represented in the file <br>
(in order to disable this, GUIDs may be removed from the file <br>
or zeroed) </p>
<p>The file format is compatible with output of 'ibroute' util and for whole 
fabric can be generated with dump_lfts.sh script. </p>
<p>To activate file based routing module, use:<br>
<br>
opensm -R file -U /path/to/lfts_file </p>
<p>If the lfts_file is not found or is in error, the default routing algorithm 
is utilized. </p>
<p>The ability to dump switch lid matrices (aka min hops tables) to file and 
later to load these is also supported. </p>
<p>The usage is similar to unicast forwarding tables loading from a lfts file 
(introduced by 'file' routing engine), but new lid matrix file name should be 
specified by -M or --lid_matrix_file option. For example: <br>
<br>
opensm -R file -M ./opensm-lid-matrix.dump </p>
<p>The dump file is named 'opensm-lid-matrix.dump' and will be generated in 
standard opensm dump directory (%windir%\temp\ by default) when OSM_LOG_ROUTING 
logging flag is set. </p>
<p>When routing engine 'file' is activated, but the lfts file is not specified 
or not cannot be open default lid matrix algorithm will be used. </p>
<p>There is also a switch forwarding tables dumper which generates a file 
compatible with dump_lfts.sh output. This file can be used as input for 
forwarding tables loading by 'file' routing engine. Both or one of options -U 
and -M can be specified together with '-R file'. </p>
<h3>FILES</h3>

<DL COMPACT>
<DT><B>%ProgramFiles\OFED\OpenSM\opensm.conf</B>

<DD>
default OpenSM config file.
<P>
<DT><B>%ProgramFiles%\OFED\OpenSM\ib-node-name-map</B>

<DD>
default node name map file.  See ibnetdiscover for more information on format.
<P>
<DT><B>%ProgramFiles%\OFED\OpenSM\partitions.conf</B>

<DD>
default partition config file
<P>
<DT><B>%ProgramFiles%\OFED\OpenSM\qos-policy.conf</B>

<DD>
default QOS policy config file
<P>
<DT><B>%ProgramFiles%\OFED\OpenSM\prefix-routes.conf</B>

<DD>
default prefix routes file.
<P>
</DL>
<h3>AUTHORS</h3>

<DL COMPACT>
<DT>Hal Rosenstock<DD>
&lt;<I><A HREF="mailto:hal.rosenstock@gmail.com">hal.rosenstock@gmail.com</A></I>&gt;

<DT>Sasha Khapyorsky<DD>
&lt;<I><A HREF="mailto:sashak@voltaire.com">sashak@voltaire.com</A></I>&gt;

<DT>Eitan Zahavi<DD>
&lt;<I><A HREF="mailto:eitan@mellanox.co.il">eitan@mellanox.co.il</A></I>&gt;

<DT>Yevgeny Kliteynik<DD>
&lt;<I><A HREF="mailto:kliteyn@mellanox.co.il">kliteyn@mellanox.co.il</A></I>&gt;

<DT>Thomas Sodring<DD>
&lt;<I><A HREF="mailto:tsodring@simula.no">tsodring@simula.no</A></I>&gt;

<DT>Ira Weiny<DD>
&lt;<I><A HREF="mailto:weiny2@llnl.gov">weiny2@llnl.gov</A></I>&gt;

<DT>Stan Smith<DD>
&lt;<a href="mailto:weiny2@llnl.gov"><i>stan.smith</i></a><I><A HREF="mailto:weiny2@llnl.gov">@intel.com</A></I>&gt;<dt>
Dale Purdy<br>
&nbsp;&nbsp;&nbsp; &lt; purdy@sgi.com &gt;</dt>
</DL>

<h4 align="left"><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></h4>
<h3 align="left">&nbsp;</h3>
<h2 align="left"><a name="osmtest"></a><br>
Osmtest - Subnet Management Tests</h2>
<p align="left">osmtest - InfiniBand subnet manager and administration (SM/SA) 
test program<br>
<br>
osmtest currently can not 
run on the same HCA port which OpenSM is currently using.</p>
<h3>SYNOPSIS</h3>

<B>osmtest</B>

[-f(low) &lt;c|a|v|s|e|f|m|q|t&gt;] [-w(ait) &lt;trap_wait_time&gt;] [-d(ebug) &lt;number&gt;]
[-m(ax_lid) &lt;LID in hex&gt;] [-g(uid)[=]&lt;GUID in hex&gt;] [-p(ort)]
[-i(nventory) &lt;filename&gt;] [-s(tress)] [-M(ulticast_Mode)]
[-t(imeout) &lt;milliseconds&gt;] [-l | --log_file] [-v] [-vf &lt;flags&gt;]
[-h(elp)]
<h3>DESCRIPTION</h3>

<P>

osmtest is a test program used to validate the correct operation of the InfiniBand subnet manager and
administration (SM/SA).
<P>
Default is to run all flows with the exception of the QoS flow.
<P>
osmtest provides a test suite for opensm.
<P>
osmtest has the following capabilities and testing flows:
<P>
It creates an inventory file of all available Nodes, Ports, and PathRecords,
including all their fields.
It verifies the existing inventory, with all the object fields, and matches it
to a pre-saved one.
A Multicast Compliancy test.
An Event Forwarding test.
A Service Record registration test.
An RMPP stress test.
A Small SA Queries stress test.
<P>
It is recommended that after installing opensm, the user should run
&quot;osmtest -f c&quot; to generate the inventory file, and
immediately afterwards run &quot;osmtest -f a&quot; to test OpenSM.
<P>
Another recommendation for osmtest usage is to create the inventory when the
IB fabric is stable, and occasionally
run &quot;osmtest -v&quot; to verify that nothing has changed.
<h3>OPTIONS</h3>

<P>
<P>

<DL COMPACT>
<DT><B>-f</B>, <B>--flow</B><DD>
This option directs osmtest to run a specific flow:
<BR>&nbsp;FLOW&nbsp;&nbsp;DESCRIPTION
<BR>&nbsp;c&nbsp;=&nbsp;create&nbsp;an&nbsp;inventory&nbsp;file&nbsp;with&nbsp;all&nbsp;nodes,&nbsp;ports&nbsp;and&nbsp;paths
<BR>&nbsp;a&nbsp;=&nbsp;run&nbsp;all&nbsp;validation&nbsp;tests&nbsp;(expecting&nbsp;an&nbsp;input&nbsp;inventory)
<BR>&nbsp;v&nbsp;=&nbsp;only&nbsp;validate&nbsp;the&nbsp;given&nbsp;inventory&nbsp;file
<BR>&nbsp;s&nbsp;=&nbsp;run&nbsp;service&nbsp;registration,&nbsp;deregistration,&nbsp;and&nbsp;lease&nbsp;test
<BR>&nbsp;e&nbsp;=&nbsp;run&nbsp;event&nbsp;forwarding&nbsp;test
<BR>&nbsp;f&nbsp;=&nbsp;flood&nbsp;the&nbsp;SA&nbsp;with&nbsp;queries&nbsp;according&nbsp;to&nbsp;the&nbsp;stress&nbsp;mode
<BR>&nbsp;m&nbsp;=&nbsp;multicast&nbsp;flow
<BR>&nbsp;q&nbsp;=&nbsp;QoS&nbsp;info:&nbsp;dump&nbsp;VLArb&nbsp;and&nbsp;SLtoVL&nbsp;tables
<BR>&nbsp;t&nbsp;=&nbsp;run&nbsp;trap&nbsp;64/65&nbsp;flow&nbsp;(this&nbsp;flow&nbsp;requires&nbsp;running&nbsp;of&nbsp;external&nbsp;tool)
<BR>&nbsp;(default&nbsp;is&nbsp;all&nbsp;flows&nbsp;except&nbsp;QoS)
<DT><B>-w</B>, <B>--wait</B><DD>
This option specifies the wait time for trap 64/65 in seconds
It is used only when running -f t - the trap 64/65 flow
(default to 10 sec)
<DT><B>-d</B>, <B>--debug</B><DD>
This option specifies a debug option.
These options are not normally needed.
The number following -d selects the debug
option to enable as follows:
<P>
&nbsp;OPT&nbsp;&nbsp;&nbsp;Description
<BR>&nbsp;---&nbsp;&nbsp;&nbsp;&nbsp;-----------------
<BR>&nbsp;-d0&nbsp;&nbsp;-&nbsp;Ignore&nbsp;other&nbsp;SM&nbsp;nodes
<BR>&nbsp;-d1&nbsp;&nbsp;-&nbsp;Force&nbsp;single&nbsp;threaded&nbsp;dispatching
<BR>&nbsp;-d2&nbsp;&nbsp;-&nbsp;Force&nbsp;log&nbsp;flushing&nbsp;after&nbsp;each&nbsp;log&nbsp;message
<BR>&nbsp;-d3&nbsp;&nbsp;-&nbsp;Disable&nbsp;multicast&nbsp;support
<DT><B>-m</B>, <B>--max_lid</B><DD>
This option specifies the maximal LID number to be searched
for during inventory file build (default to 100)
<DT><B>-g</B>, <B>--guid</B><DD>
This option specifies the local port GUID value
with which OpenSM should bind.  OpenSM may be
bound to 1 port at a time.
If GUID given is 0, OpenSM displays a list
of possible port GUIDs and waits for user input.
Without -g, OpenSM trys to use the default port.
<DT><B>-p</B>, <B>--port</B><DD>
This option displays a menu of possible local port GUID values
with which osmtest could bind
<DT><B>-i</B>, <B>--inventory</B><DD>
This option specifies the name of the inventory file
Normally, osmtest expects to find an inventory file,
which osmtest uses to validate real-time information
received from the SA during testing
If -i is not specified, osmtest defaults to the file
'osmtest.dat'
See -c option for related information
<DT><B>-s</B>, <B>--stress</B><DD>
This option runs the specified stress test instead
of the normal test suite
Stress test options are as follows:
<P>
&nbsp;OPT&nbsp;&nbsp;&nbsp;&nbsp;Description
<BR>&nbsp;---&nbsp;&nbsp;&nbsp;&nbsp;-----------------
<BR>&nbsp;-s1&nbsp;&nbsp;-&nbsp;Single-MAD&nbsp;(RMPP)&nbsp;response&nbsp;SA&nbsp;queries
<BR>&nbsp;-s2&nbsp;&nbsp;-&nbsp;Multi-MAD&nbsp;(RMPP)&nbsp;response&nbsp;SA&nbsp;queries
<BR>&nbsp;-s3&nbsp;&nbsp;-&nbsp;Multi-MAD&nbsp;(RMPP)&nbsp;Path&nbsp;Record&nbsp;SA&nbsp;queries
<BR>&nbsp;-s4&nbsp;&nbsp;-&nbsp;Single-MAD&nbsp;(non&nbsp;RMPP)&nbsp;get&nbsp;Path&nbsp;Record&nbsp;SA&nbsp;queries
<P>
Without -s, stress testing is not performed
<DT><B>-M</B>, <B>--Multicast_Mode</B><DD>
This option specify length of Multicast test:
<P>
&nbsp;OPT&nbsp;&nbsp;&nbsp;&nbsp;Description
<BR>&nbsp;---&nbsp;&nbsp;&nbsp;&nbsp;-----------------
<BR>&nbsp;-M1&nbsp;&nbsp;-&nbsp;Short&nbsp;Multicast&nbsp;Flow&nbsp;(default)&nbsp;-&nbsp;single&nbsp;mode
<BR>&nbsp;-M2&nbsp;&nbsp;-&nbsp;Short&nbsp;Multicast&nbsp;Flow&nbsp;-&nbsp;multiple&nbsp;mode
<BR>&nbsp;-M3&nbsp;&nbsp;-&nbsp;Long&nbsp;Multicast&nbsp;Flow&nbsp;-&nbsp;single&nbsp;mode
<BR>&nbsp;-M4&nbsp;&nbsp;-&nbsp;Long&nbsp;Multicast&nbsp;Flow&nbsp;-&nbsp;multiple&nbsp;mode
<P>
Single mode - Osmtest is tested alone, with no other
apps that interact with OpenSM MC
<P>
Multiple mode - Could be run with other apps using MC with
OpenSM. Without -M, default flow testing is performed
<DT><B>-t</B>, <B>--timeout</B><DD>
This option specifies the time in milliseconds
used for transaction timeouts.
Specifying -t 0 disables timeouts.
Without -t, OpenSM defaults to a timeout value of
200 milliseconds.
<DT><B>-l</B>, <B>--log_file</B><DD>
This option defines the log to be the given file.
By default the log goes to stdout.
<DT><B>-v</B>, <B>--verbose</B><DD>
This option increases the log verbosity level.
The -v option may be specified multiple times
to further increase the verbosity level.
See the -vf option for more information about.
log verbosity.
<DT><B>-V</B><DD>
This option sets the maximum verbosity level and
forces log flushing.
The -V is equivalent to '-vf 0xFF -d 2'.
See the -vf option for more information about.
log verbosity.
<DT><B>-vf</B><DD>
This option sets the log verbosity level.
A flags field must follow the -D option.
A bit set/clear in the flags enables/disables a
specific log level as follows:
<P>
&nbsp;BIT&nbsp;&nbsp;&nbsp;&nbsp;LOG&nbsp;LEVEL&nbsp;ENABLED
<BR>&nbsp;----&nbsp;&nbsp;&nbsp;-----------------
<BR>&nbsp;0x01&nbsp;-&nbsp;ERROR&nbsp;(error&nbsp;messages)
<BR>&nbsp;0x02&nbsp;-&nbsp;INFO&nbsp;(basic&nbsp;messages,&nbsp;low&nbsp;volume)
<BR>&nbsp;0x04&nbsp;-&nbsp;VERBOSE&nbsp;(interesting&nbsp;stuff,&nbsp;moderate&nbsp;volume)
<BR>&nbsp;0x08&nbsp;-&nbsp;DEBUG&nbsp;(diagnostic,&nbsp;high&nbsp;volume)
<BR>&nbsp;0x10&nbsp;-&nbsp;FUNCS&nbsp;(function&nbsp;entry/exit,&nbsp;very&nbsp;high&nbsp;volume)
<BR>&nbsp;0x20&nbsp;-&nbsp;FRAMES&nbsp;(dumps&nbsp;all&nbsp;SMP&nbsp;and&nbsp;GMP&nbsp;frames)
<BR>&nbsp;0x40&nbsp;-&nbsp;ROUTING&nbsp;(dump&nbsp;FDB&nbsp;routing&nbsp;information)
<BR>&nbsp;0x80&nbsp;-&nbsp;currently&nbsp;unused.
<P>
Without -vf, osmtest defaults to ERROR + INFO (0x3)
Specifying -vf 0 disables all messages
Specifying -vf 0xFF enables all messages (see -V)
High verbosity levels may require increasing
the transaction timeout with the -t option
<DT><B>-h</B>, <B>--help</B><DD>
Display this usage info then exit.
<P>
</DL>
<h3>AUTHORS</h3>

<DL COMPACT>
<DT>Hal Rosenstock<DD>
&lt;<I><A HREF="mailto:hal.rosenstock@gmail.com">hal.rosenstock@gmail.com</A></I>&gt;

<DT>Eitan Zahavi<DD>
&lt;<I><A HREF="mailto:eitan@mellanox.co.il">eitan@mellanox.co.il</A></I>&gt;

<dt>&nbsp;</dt>
<h3>EXAMPLES</h3>
<p>Note - osmtest will not run on the node where OpenSM is running.<br>See 'osmtest -h' for all options.</p>
<p>Functionality:</p>
<blockquote>
	<p>osmtest -f c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			# creates osmtest.dat inventory file in the current directory; 
			required by other osmtest runs.<br>
	osmtest -f v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	# validate the default inventory file 'osmtest.dat'.<br>osmtest -f a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			# run all validation tests (expecting an input inventory file 'osmtest.dat' 
			in the current folder).</p>
</blockquote>
</DL>
	<p>Stress tests</p>
<blockquote>
	<p>osmtest -f&nbsp; f -s1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; 
	Single-MAD (RMPP) response SA queries<br>
	osmtest -f&nbsp; f -s2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Multi-MAD 
	(RMPP) response SA queries<br>
	osmtest -f&nbsp; f -s3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Multi-MAD 
	(RMPP) Path Record SA queries</p>
</blockquote>
<p align="left"><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></p>
<h3 align="left"><br>
<BLOCKQUOTE></BLOCKQUOTE>
	<h2>
<a name="ibtrapgen"></a><br>
ibtrapgen - Generate Infiniband subnet management traps</h2>
	</h3>
<p align="left">Usage: ibtrapgen -t|--trap_num &lt;TRAP_NUM&gt; -n|--number &lt;NUM_TRAP_CREATIONS&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
-r|--rate &lt;TRAP_RATE&gt; -l|--lid &lt;LIDADDR&gt; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
-s|--src_port &lt;SOURCE_PORT&gt; -p|--port_num &lt;PORT_NUM&gt;<br>
<br>
Options: one of the following optional flows:</p>
<blockquote>
	<p align="left">-t &lt;TRAP_NUM&gt;<br>
	--trap_num &lt;TRAP_NUM&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This option specifies the 
	number of the trap to generate. Valid values are 128-131.<br>
	-n &lt;NUM_TRAP_CREATIONS&gt;<br>
	--number &lt;NUM_TRAP_CREATIONS&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This option specifies the 
	number of times to generate this trap.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If not specified - 
	default to 1.<br>
	-r &lt;TRAP_RATE&gt;<br>
	--rate &lt;TRAP_RATE&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This option specifies the 
	rate of the trap generation.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; What is the time period 
	between one generation and another?<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The value is given in 
	miliseconds. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If the number of trap 
	creations is 1 - this value is ignored.<br>
	-l &lt;LIDADDR&gt;<br>
	--lid &lt;LIDADDR&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This option specifies the 
	lid address from where the trap should be generated.<br>
	-s &lt;SOURCE_PORT&gt;<br>
	--src_port &lt;SOURCE_PORT&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This option specifies the 
	port number from which the trap should<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be generated. If trap 
	number is 128 - this value is ignored (since<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trap 128 is not sent with 
	a specific port number)<br>
	-p &lt;port num&gt;<br>
	--port_num &lt;port num&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This is the port number 
	used for communicating with the SA.<br>
	-h<br>
	--help<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Display this usage info 
	then exit.<br>
	-o<br>
	--out_log_file<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This option defines the 
	log to be the given file.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; By default the log goes 
	to stdout.<br>
	-v<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This option increases the 
	log verbosity level.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The -v option may be 
	specified multiple times to further increase the verbosity level.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; See the -vf option for 
	more information about log verbosity.<br>
	-V<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This option sets the 
	maximum verbosity level and forces log flushing.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The -V is equivalent to 
	'-vf 0xFF -d 2'.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; See the -vf option for 
	more information about. log verbosity.<br>
	-x &lt;flags&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This option sets the log 
	verbosity level.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A flags field must follow 
	the -vf option.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A bit set/clear in the 
	flags enables/disables a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; specific log level as 
	follows:</p>
	<blockquote>
		<p align="left">BIT LOG LEVEL ENABLED<br>
		---- -----------------<br>
		0x01 - ERROR (error messages)<br>
		0x02 - INFO (basic messages, low volume)<br>
		0x04 - VERBOSE (interesting stuff, moderate volume)<br>
		0x08 - DEBUG (diagnostic, high volume)<br>
		0x10 - FUNCS (function entry/exit, very high volume)<br>
		0x20 - FRAMES (dumps all SMP and GMP frames)<br>
		0x40 - currently unused.<br>
		0x80 - currently unused.<br>
		Without -x, ibtrapgen defaults to ERROR + INFO (0x3).<br>
		Specifying -x 0 disables all messages.<br>
		Specifying -x 0xFF enables all messages (see -V).</p>
	</blockquote>
</blockquote>
<h4 align="left"><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></h4>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<BLOCKQUOTE></BLOCKQUOTE>
<h2 align="left"><a name="IPoIB"></a>IPoIB - Internet Protocols over InfiniBand</h2>
<hr>
<p align="left">IPoIB enables the use of Internet Protocol utilities (e.g., ftp, 
telnet) to function correctly over an Infiniband fabric. IPoIB is implemented as 
an NDIS Miniport driver with a WDM lower edge.</p>
<p align="left">The IPoIB Network adapters are 
located via 'My Computer-&gt;Manage-&gt;Device Manager-&gt;Network adapters-&gt;IPoIB' 
or the command 'ncpa.cpl'.<br>
<br>
'My 
Network Places-&gt;Properties' will display IPoIB Local Area Connection instances and should be used to 
configure IP addresses for the IPoIB interfaces; one Local Area Connection 
instance per HCA port.<br>
The IP 
(Internet Protocol) address bound to the IPoIB adapter instance can be assigned 
by DHCP or as a static IP addresses via<br>
'My Network Places-&gt;Properties-&gt;Local 
Area Connection X-&gt;Properties-&gt;(General Tab)Internet Protocol(TCP/IP)-&gt;Properties'.<br>
The command line equivalent is 'netsh interface ip set address &quot;Local Area 
Connection X&quot; static 192.168.1.1 255.255.255.0'.<br>
<br>
To display the IPv4 address bound to your IPoIB Local Area Connection X, use 'netsh 
interface ip show address &quot;Local Area Connection X&quot;''.</p>
<p align="left">When the subnet manager (opensm) configures/sweeps the local 
Infiniband HCA, the Local Area Connection will become enabled. If you discover 
the Local Area Connection to be disabled, then likely your subnet manager 
(opensm) is not running or functioning correctly.</p>
<p align="left">IPoIB defaults to user-datagram (UD) mode, where 2044 MTU sized 
data packets are broadcast to an Infiniband Multicast group which each IPoIB 
joins.</p>
<p align="left">The high performance IPoIB Connected Mode (CM) is enabled 
ncpa.cpl&nbsp; -&gt;Local Area Connection X --&gt;Properties --&gt;Configure --&gt;Advanced 
tab --&gt; Connected Mode --&gt; Enable.</p>
<p align="left">To verify IPoIB CM mode is enabled, verify the MTU size as 65520 
with 'netsh int ip show int'.</p>
<p align="left">To change IPoIB CM MTU size one can either:</p>
<ul>
	<li>
	<p align="left">use 'netsh int ip set interface device-index mtu=new-mtu-value'.<br>
	The device-index is obtained with 'netsh int ip show int', matching the 
	'connected' Local Area Connection X name to device index.</p></li>
	<li>
	<p align="left">ncpa.cpl&nbsp; -&gt;Local Area Connection X --&gt;Properties 
	--&gt;Configure --&gt;Advanced tab --&gt; Connected Mode Payload MTU size</p></li>
</ul>
<p align="left">&nbsp;</p>
		<h4 align="left"><u>IPoIB Partition Management</u></h4>
		<ul>
			<li>
			<p align="left"><a href="#InfiniBand_Partition_Management">part_man</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			Manage (add/remove/show) IPoIB partitions.</li>
	</ul>
<h4 align="left"><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></h4>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<BLOCKQUOTE></BLOCKQUOTE>
<h2 align="left"><a name="winsockdirect"></a>Winsock Direct Service Provider</h2>
<hr>
<p align="left">Winsock Direct (WSD) is Microsoft's proprietary protocol that 
predates SDP (Sockets Direct Protocol) for accelerating TCP/IP applications by 
using RDMA hardware. Microsoft had a significant role in defining the SDP 
protocol, hence SDP and WSD are remarkably similar, though unfortunately 
incompatible.<br>
<br>
WSD is made up of two parts, the winsock direct switch and the winsock direct 
provider. The WSD switch is in the winsock DLL that ships in all editions of 
Windows Server 2008, and is responsible for routing socket traffic over either 
the regular TCP/IP stack, or offload it to a WSD provider. The WSD provider is a 
hardware specific DLL that implements connection management and data transfers 
over particular RDMA hardware.</p>
<p align="left">The WSD Protocol seamlessly transports TCP 
		data using Infiniband data packets in 'buffered' mode or Infiniband 
		RDMA in 'direct' mode. Either way the user mode socket application sees no 
		behavioral difference in the standard Internet Protocol socket it created other than 
reduced data transfer times and increased bandwidth.<br>
<br>
The Windows OpenFabrics release includes a WSD provider library that has been 
extensively tested with Microsoft Windows Server 2008.<br>
&nbsp;</p>
<div id="tiki-main">
	<div id="tiki-mid">
		<table id="table1" cellSpacing="0" cellPadding="0" border="0">
			<tr>
				<td id="centercolumn">
				<div id="tiki-center">
					<div class="wikitext">
						Environment variables can be used to change the behavior 
						of the WSD provider:<br>
						<br>
						IBWSD_NO_READ - Disables RDMA Read operations when set 
						to any value. Note that this variable must be used 
						consistently throughout the cluster or communication 
						will fail.<br>
						<br>
						IBWSD_POLL - Sets the number of times to poll the 
						completion queue after processing completions in 
						response to a CQ event. Reduces latency at the cost of 
						CPU utilization. Default is 500.<br>
						<br>
						IBWSD_SA_RETRY - Sets the number of times to retry SA 
						query requests. Default is 4, can be increased if 
						connection establishment fails.<br>
						<br>
						IBWSD_SA_TIMEOUT - Sets the number of milliseconds to 
						wait before retrying SA query requests. Default is 4, 
						can be increased if connection establishment fails.<br>
						<br>
						IBWSD_NO_IPOIB - SA query timeouts by default allow the 
						connection to be established over IPoIB. Setting this 
						environment variable to any value prevents fall back to 
						IPoIB if SA queries time out.<br>
						<br>
						IBWSD_DBG - Controls debug output when using a debug 
						version of the WSD provider. Takes a hex value, with 
						leading '0x', default value is '0x80000000'<br>
						<br>
&nbsp;<table class="wikitable" id="table2">
							<tr>
								<td class="wikicell">0x00000001</td>
								<td class="wikicell">DLL</td>
							</tr>
							<tr>
								<td class="wikicell">0x00000002</td>
								<td class="wikicell">socket info</td>
							</tr>
							<tr>
								<td class="wikicell">0x00000004</td>
								<td class="wikicell">initialization code</td>
							</tr>
							<tr>
								<td class="wikicell">0x00000008</td>
								<td class="wikicell">WQ related functions</td>
							</tr>
							<tr>
								<td class="wikicell">0x00000010</td>
								<td class="wikicell">Enpoints related functions</td>
							</tr>
							<tr>
								<td class="wikicell">0x00000020</td>
								<td class="wikicell">memory registration</td>
							</tr>
							<tr>
								<td class="wikicell">0x00000040</td>
								<td class="wikicell">CM (Connection Manager)</td>
							</tr>
							<tr>
								<td class="wikicell">0x00000080</td>
								<td class="wikicell">connections</td>
							</tr>
							<tr>
								<td class="wikicell">0x00000200</td>
								<td class="wikicell">socket options</td>
							</tr>
							<tr>
								<td class="wikicell">0x00000400</td>
								<td class="wikicell">network events</td>
							</tr>
							<tr>
								<td class="wikicell">0x00000800</td>
								<td class="wikicell">Hardware</td>
							</tr>
							<tr>
								<td class="wikicell">0x00001000</td>
								<td class="wikicell">Overlapped I/O request</td>
							</tr>
							<tr>
								<td class="wikicell">0x00002000</td>
								<td class="wikicell">Socket Duplication</td>
							</tr>
							<tr>
								<td class="wikicell">0x00004000</td>
								<td class="wikicell">Performance Monitoring</td>
							</tr>
							<tr>
								<td class="wikicell">0x01000000</td>
								<td class="wikicell">More verbose than 
								IBSP_DBG_LEVEL3</td>
							</tr>
							<tr>
								<td class="wikicell">0x02000000</td>
								<td class="wikicell">More verbose than 
								IBSP_DBG_LEVEL2</td>
							</tr>
							<tr>
								<td class="wikicell">0x04000000</td>
								<td class="wikicell">More verbose than 
								IBSP_DBG_LEVEL1</td>
							</tr>
							<tr>
								<td class="wikicell">0x08000000</td>
								<td class="wikicell">Verbose output</td>
							</tr>
							<tr>
								<td class="wikicell">0x20000000</td>
								<td class="wikicell">Function enter/exit</td>
							</tr>
							<tr>
								<td class="wikicell">0x40000000</td>
								<td class="wikicell">Warnings</td>
							</tr>
							<tr>
								<td class="wikicell">0x80000000</td>
								<td class="wikicell">Errors</td>
							</tr>
						</table>
					</div>
				</div>
				</td>
			</tr>
		</table>
	</div>
</div>
<p align="left"><br>
See <a href="https://wiki.openfabrics.org/tiki-index.php?page=Winsock+Direct">
https://wiki.openfabrics.org/tiki-index.php?page=Winsock+Direct</a> for the 
latest WSD status.</p>
<h3 align="left">Winsock Direct Service Provider Installation</h3>
<p align="left">WSD service is automatically installed although not enabled as 
part of the 'default' installation.<br>
Manual control is performed via the \Program Files\OFED\installsp.exe utility.</p>
<blockquote>
	<p align="left">usage: installsp [-i | -r | -l]<br>
	<br>
	-i&nbsp;&nbsp;&nbsp; Install the Winsock Direct (WSD) service provider<br>
	-r&nbsp;&nbsp;&nbsp; Remove the WSD service provider<br>
	-r &lt;name&gt;&nbsp;&nbsp;&nbsp; Remove the specified service provider<br>
	-l&nbsp;&nbsp;&nbsp; List service providers<br>
&nbsp;</p>
</blockquote>
<h4 align="left"><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></h4>
<p align="left">&nbsp;</p>
<BLOCKQUOTE></BLOCKQUOTE>
<h2 align="left"><a name="Network_Direct_Service_Provider">NetworkDirect 
Service Provider</a></h2><hr>
<h3 align="left">NetworkDirect Service Provider Installation</h3>
<p align="left">ND service 
is automatically installed and started as part of the 'default' installation for 
Windows Server 2008 R2 or HPC systems.<br>
Manual control is performed via the %windir%\system32\ndinstall.exe utility.</p>
<blockquote>
	<p align="left">usage: ndinstall [-l] [-i | -r [ServiceProvider]]<br>
	<br>
	where valid ServiceProvider names are</p>
	<ul>
		<li>
		<p align="left">'mlx4nd2' (NetworkDirect.v2)</p></li>
		<li>
		<p align="left">'mlx4nd' (NetworkDirect.v1)</p></li>
		<li>
		<p align="left">'ibal' (NetworkDirect.v1)</p></li>
		<li>
		<p align="left">'winverbs' (NetworkDirect.v1)</p></li>
		<li>
		<p align="left">blank [blank after '-r' implies the 
	default Service Provider 'ibal']</p></li>
	</ul>
	<p align="left">-i&nbsp;&lt;name&gt;&nbsp;&nbsp;&nbsp; Install (enable) the NetworkDirect (ND) 
	Service Provider 'name'<br>
	-r &lt;name&gt;&nbsp;&nbsp;&nbsp; Remove the specified Service Provider 
	'name'<br>
	-l&nbsp;&nbsp;&nbsp; List all service providers; same as 'ndinstall' with no 
	args.</p>
</blockquote>
<p align="left">The Microsoft Network Direct SDK can be downloaded from
<a href="http://www.microsoft.com/downloads/details.aspx?familyid=12887DA1-9410-4A59-B903-693116BFD30E&displaylang=en">
here</a>.&nbsp; Once the ND SDK is installed, ND test programs can be located @<br>
%ProgramFiles%\Microsoft HPC Pack 2008 SDK\NetworkDirect\Bin\amd64\ as nd*.exe.</p>
<p align="left">Known working ND test command invocations (loopback or remote 
host)</p>
<blockquote>
	<p align="left"><font size="4">svr: ndrpingpong s IPoIB_IPv4_addr 4096 p1<br>
	cli: ndrpingpong c IPoIB_IPv4_addr 4096 p1</font></p>
	<p align="left"><font size="4">svr: ndpingpong s IPoIB_IPv4_addr 4096 b1<br>
	cli: ndpingpong c IPoIB_IPv4_addr 4096 b1</font></p>
</blockquote>
<p align="left">See ndping.exe /? for details.</p>
<p align="left">NetworkDirect.v2 devices + assigned IPv* addresses can be 
displayed via the 'NDlist' command.</p>
<p align="left"><b><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></b></p>
<p align="left">&nbsp;</p>
<BLOCKQUOTE></BLOCKQUOTE>
<h2 align="left"><a name="DAT"></a>Usermode Direct Access Transport and Direct Access Programming 
Libraries</h2>
<hr>
<p align="left"><font face="Times New Roman">The DAT (Direct Access Transport) 
API is a C programming interface developed by the
<a class="wiki" href="http://www.datcollaborative.org">DAT Collaborative</a> in 
order provide a set of transport-independent, platform-independent Application 
Programming Interfaces that exploit the RDMA (remote direct memory access) 
capabilities of next-generation interconnect technologies such as InfiniBand, 
and iWARP.</font></p>
<p align="left"><font face="Times New Roman">OFED uDAT and uDAPL are based on the 
2.0 DAT specification. The DAPL 
(Direct Access Provider Library) which now fully supports Infiniband RDMA and 
IPoIB.</font></p>
<p align="left"><font face="Times New Roman">Previous OFED 
releases supported the uDAT/uDAPL 1.1 provider which has now been deprecated.<br>
uDAT/uDAPL version 2.0 runtime libraries along with an optional 
v2.0 application build environment are the only options.<br>
uDAT 2.0 is configured with InfiniBand extensions enabled. The IB extensions 
include</font></p>
<ul>
	<li>
	<p align="left"><font face="Times New Roman">RDMA write with Immediate data</font></p>
	</li>
	<li>
	<p align="left"><font face="Times New Roman">Atomic Compare and Swap 
	operation</font></p></li>
	<li>
	<p align="left"><font face="Times New Roman">Atomic Fetch and Add operation<br>&nbsp;</font></p>
	</li>
</ul>
<div id="tiki-main0">
	<div id="tiki-mid0">
		<table id="table3" cellSpacing="0" cellPadding="0" border="0">
			<tr>
				<td id="centercolumn0">
				<div id="tiki-center0">
					<div class="wikitext">
						<br>
						How&nbsp; DAT objects map to equivalent
						<a class="wiki" href="http://en.wikipedia.org/wiki/Infiniband">
						InfiniBand</a> objects:<br>
&nbsp;<table class="wikitable" id="table4">
							<tr>
								<td class="wikicell">Interface Adapter (IA) 
								</td>
								<td class="wikicell">HCA (Host Channel Adapter)</td>
							</tr>
							<tr>
								<td class="wikicell">Protection Zone (PZ) </td>
								<td class="wikicell">PD (Protection Domain)</td>
							</tr>
							<tr>
								<td class="wikicell">Local Memory Region (LMR) 
								</td>
								<td class="wikicell">MR (Memory Region)</td>
							</tr>
							<tr>
								<td class="wikicell">Remote Memory Region (RMR) 
								</td>
								<td class="wikicell">MW (Memory Windows)</td>
							</tr>
							<tr>
								<td class="wikicell">Event Dispatcher (EVD) 
								</td>
								<td class="wikicell">CQ (Completion Queue)</td>
							</tr>
							<tr>
								<td class="wikicell">Endpoint (EP) </td>
								<td class="wikicell">QP (Queue Pair)</td>
							</tr>
							<tr>
								<td class="wikicell">Public Service Point (PSP) 
								</td>
								<td class="wikicell">connection identifier </td>
							</tr>
							<tr>
								<td class="wikicell">Reserved Service Point (RSP) 
								</td>
								<td class="wikicell">connection identifier </td>
							</tr>
							<tr>
								<td class="wikicell">Connection Request (CR) 
								</td>
								<td class="wikicell">connection manager event 
								</td>
							</tr>
						</table>
					</div>
				</div>
				</td>
			</tr>
		</table>
	</div>
</div>
<div align="left">
	<h3 align="left"><font face="Courier New" size="3"><br>
	DAT ENVIRONMENT</font><font face="Courier New" size="2">:</font></h3>
</div>
<blockquote>
	<p align="left"><font face="Courier New" size="2">DAT/DAPL 2.0 (free-build) libraries are identified in %SystemRoot%\System32 as 
	dat2.dll and dapl2.dll.&nbsp; Debug versions of the v2.0 runtime libraries 
	are located in '%SystemDrive%\%ProgramFiles%\OFED'.</font></p>
	<p align="left"><font face="Courier New" size="2">IA32 (aka, 32-bit) 
	versions of DAT/DAPL 2.0 runtime libraries, found only on 64-bit systems, 
	are identified in '%ProgramFiles%\OFED' as dat32.dll 
	and dapl32.dll.</font></p>
	<p align="left"><font face="Courier New" size="2">In order for DAT/DAPL 
	programs to execute correctly, the runtime library files 'dat2.dll and 
	dapl2.dll' must be present in one of the following folders: current 
	directory, %SystemRoot%, %SystemRoot%\System32 or in the library search path.</font></p>
	<p align="left"><font face="Courier New" size="2">The default OFED 
	installation places the runtime library files dat2.dll and dapl2.dll in the '%SystemRoot%\System32' folder; 
	symbol files (.pdb) are located in '%ProgramFiles%\OFED\'.</font></p>
	<p align="left"><font face="Courier New" size="2">The default DAPL configuration 
	file is defined as '%SystemDrive%\DAT\dat.conf'. This default 
	specification can be overriden by use of the environment variable 
	DAT_OVERRIDE; see following environment variable discussion.</font></p>
	<p align="left"><font face="Courier New" size="2">Within the dat.conf file, 
	the DAPL library specification can be located as the 5th whitespace 
	separated line argument. By default the DAPL library file is installed as
	'%SystemRoot%\System32\dapl2.dll'.</font></p>
	<p align="left"><font face="Courier New" size="2">Should you choose to 
	relocated the DAPL library file to a path where whitespace appears in the 
	full library path specification, then the full library file specification 
	must be contained within double-quotes. A side effect of the double-quotes 
	is the library specification is treated as a Windows string which implies 
	the '\' (backslash character) is treated as an 'escape' character.&nbsp; Hence 
	all backslashes in the library path must be duplicated when enclosed in 
	double-quotes
	(e.g., &quot;C:\\Programs Files\\OFED\\dapl.dll&quot;).</font></p>
	<p align="left"><font face="Courier New" size="2">A sample InfiniBand dat.conf file is 
	installed as '\Program Files\OFED\dat.conf'.&nbsp; If dat.conf does not 
	exist in the DAT default configuration folder '%SystemDrive%\DAT\', dat.conf 
	will be copied there.<br>
&nbsp;</font></p>
</blockquote>
<h3 align="left"><u><font face="Times New Roman" size="3">
<a name="DAPL_Providers">DAPL Providers</a></font></u></h3>
<blockquote>
	<p align="left"><font face="Courier New" size="2">DAT 2.0 (free-build) 
	libraries utilize the following user application selectable DAPL providers. 
	Each DAPL provider represents an RDMA hardware interface device type and 
	it's Connection Manager.<br>DAPL providers are listed in the file '%SystemDrive%\DAT\dat.conf'.<br>The dat.conf InfiniBand DAPL provider names are formatted 'ibnic-HCA#-DAPL_Version-CM_type'.<br>Example:<br>
&nbsp;&nbsp;&nbsp; NDx - Microsoft NetworkDirect v2, where x == 0..nth ND device 
	(see NDlist for ND device listing)<br>&nbsp;&nbsp;&nbsp; ibnic0v2 - InfiniBand HCA #zero, DAPL version 2.0, (default 
	CM is IBAL).<br>&nbsp;&nbsp;&nbsp; ibnic1v2-scm - InfiniBand HCA #one, DAPL version 2.0, CM is 
	'socket-CM'<br>
&nbsp;&nbsp;&nbsp; ibnic0v2-cma - InfiniBand HCA #zero, DAPL version 2.0, CM is 
	'rdma-CM'</font></p>
	<p align="left"><font face="Courier New" size="2">Each non-comment line in 
	the dat.conf file describes a DAPL provider interface.<br>
	The 2nd to the last field on the right (7th from the left) describes the 
	ia_device_params (Interface Adapter Device Parameters) (aka, RDMA device) in 
	accordance with the specific DAPL provider specified in the 5th field.
	</font></p>
	<ul>
		<li>
		<p align="left"><font face="Times New Roman"><u>NetworkDirect DAPL 
		Provider</u></font></p></li>
	</ul>
	<blockquote>
		<ul>
			<li>
			<p align="left"><font face="Courier New" size="2">File: 
			%windir%\System32\dapl2-ND.dll</font></p></li>
			<li>
			<p align="left"><font face="Courier New" size="2">dat.conf Provider 
			name: ND</font></p></li>
			<li>
			<p align="left"><font face="Courier New" size="2">ia_device_params - 
			'NDX Y'<br>where 'X' is the IB HCA device instance (0 == 1st HCA), 
			Y is the port number (1 == 1st port).</font></p></li>
		</ul>
		<p align="left"><font face="Courier New" size="2">Use the InfiniBand Access Layer 
		(IBAL) Connection 
	Manager (CM) to establish InfiniBand reliable connections to Windows based system. 
		IBAL is the original DAPL provider.</font></p>
	</blockquote>
	<p align="left">&nbsp;</p>
	<ul>
		<li>
		<p align="left"><font face="Times New Roman"><u>IBAL (eye-ball) DAPL 
		Provider</u></font></p>
		<ul>
			<li>
			<p align="left"><font face="Courier New" size="2">File: 
			%windir%\System32\dapl2.dll</font></p></li>
			<li>
			<p align="left"><font face="Courier New" size="2">dat.conf Provider 
			name: ibnic0v2</font></p></li>
			<li>
			<p align="left"><font face="Courier New" size="2">ia_device_params - 
			'IbalHcaX Y'<br>
			where 'X' is the IB HCA device instance (0 == 1st HCA), 
			Y is the port number (1 == 1st port).</font></p></li>
		</ul>
		<p align="left"><font face="Courier New" size="2">Use the InfiniBand Access Layer 
		(IBAL) Connection 
	Manager (CM) to establish InfiniBand reliable connections to Windows based system. 
		IBAL is the original DAPL provider.<br>
&nbsp;</font></p></li>
		<li>
		<p align="left"><u>Socket-CM Provider</u></p>
		<ul>
			<li>
			<p align="left"><font face="Courier New" size="2">File: %windir%\System32\dapl2-ofa-scm.dll</font></p>
			</li>
			<li>
			<p align="left"><font face="Courier New" size="2"><u>dat.conf</u> 
			Provider name: ibnic0v2-scm</font></p></li>
			<li>
			<p align="left"><font face="Courier New" size="2">ia_device_params - 
			&quot;ibv_deviceX Y&quot;<br>
			where 'X' is the IB HCA device instance (0 == 1st 
			HCA), Y is the port number (1 == 1st port). Socket-CM uses Winverbs 
			hence the ibv_deviceX nomenclature; see ibstat command.</font></p></li>
		</ul>
		<p align="left"><font face="Courier New" size="2">To facilitate DAT v2.0 
		Windows to Linux DAT v2.0 InfiniBand communications, a BSD socket based Connection Manager (socket-cm) is 
		supported. Both 
	nodes must use the same Connection Manager IBAL-CM[ibnic0v2] or 
	Socket-CM[ibnicv2-scm] in order for connections to be 
	established. For Linux &lt;==&gt; Windows DAT connections, the DAPL provider must 
		be socket-cm or rdma-cm; IBAL DAPL provider is not supported on Linux.<br>
&nbsp;</font></p></li>
		<li>
		<p align="left"><font face="Times New Roman">RDMA-CM Provider</font></p>
		<ul>
			<li>
			<p align="left"><font face="Courier New" size="2">File: %windir%\System32\dapl2-ofa-cma.dll</font></p>
			</li>
			<li>
			<p align="left"><font face="Courier New" size="2">dat.conf Provider 
			name: ibnic0v2-cma</font></p></li>
			<li>
			<p align="left"><font face="Courier New" size="2">ia_device_params - 
			&quot;rdma_devX Y&quot;<br>
			where 'X' is the RDMA device instance (future iWARP 
			support, today InfiniBand) with assigned IPv4 address (0 == 1st 
			IPoIB device with an assigned IPv4 address); Y is ignored although 
			there must be a digit present.<br>
			Alternatively, 'rdma_devX' can be replaced with the IP4v address 
			assigned to an IPoIB device instance. The 'rdma_dev0' is used to 
			instruct the rdma-cm provider to use the 1st RDMA device (IPoIB) 
			with an assigned IP4v address such that the dat.conf file does not 
			have to be specifically tailored for each OFED installation.</font></p></li>
		</ul>
		<p align="left"><font face="Courier New" size="2">OFED RDMA CM manager 
		can be used to establish connections between Windows and/or Linux systems.</font></p></li>
	</ul>
	<p align="left">&nbsp;</p>
</blockquote>
<p align="left"><b><u><a name="DAT_App_Build"></a>DAT application build environment</u>:</b></p>
<blockquote>
	<p align="left"><font face="Courier New" size="2">DAT library header files 
	are selectively installed in the DAT default configuration folder as<br>'%SystemDrive%\DAT\v2-0'. 
	Your C language based DAT application compilation command line 
	should include'/I%SystemDrive%\DAT\v2-0' with C code referencing '#include &lt;DAT\udat.h&gt;'.<br>
	<br>
	The 'default' DAT/DAPL C language calling convention is '__stdcall', not the 
	'normal' Visual Studio C compiler default. __stdcall was chosen as MS 
	recommended it to be more efficient. An application can freely mix default C 
	compiler linkages '__cdecl' and '__stdcall'.<br>
	<br>
	Visual Studio 2005 command window - (nmake) Makefile Fragments:</font></p>
	<blockquote>
		<p align="left"><font face="Courier New" size="2">DAT_PATH=%SystemDrive%\DAT\v2-0<br>
		CC = cl<br>
		INC_FLAGS = /I $(DAT_PATH)<br>
		<br>
		CC_FLAGS= /nologo /Gy /W3 /Gm- /GR- /GF /O2 /Oi /Oy- /D_CRT_SECURE_NO_WARNINGS 
		\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /D_WIN64 
		/D_X64_ /D_AMD64_ $(INC_FLAGS) <br>
		<br>
		LINK = link<br>
		LIBS = ws2_32.lib advapi32.lib User32.lib bufferoverflowU.lib dat.lib<br>
		<br>
		LINK_FLAGS = /nologo /subsystem:console /machine:X64 
		/libpath:$(DAT_PATH) $(LIBS)</font><b><br><br>
		</b>When linking a DEBUG/Checked version make sure to use dat2d.lib .</p>
	</blockquote>
</blockquote>
<h4><u>DAT library environment variables</u>:</h4>
<blockquote>
	<pre>
DAT_OVERRIDE
------------
Value used as the static registry configuration file, overriding the
default location, 'C:\DAT\dat.conf'.

Example: set DAT_OVERRIDE=%SystemDrive%\path\to\my\private.conf


DAT_DBG_LEVEL
-------------

Value specifies which parts of the registry will print debugging
information, valid values are 

DAT_OS_DBG_TYPE_ERROR        = 0x1
DAT_OS_DBG_TYPE_GENERIC      = 0x2
DAT_OS_DBG_TYPE_SR           = 0x4
DAT_OS_DBG_TYPE_DR           = 0x8
DAT_OS_DBG_TYPE_PROVIDER_API = 0x10
DAT_OS_DBG_TYPE_CONSUMER_API = 0x20
DAT_OS_DBG_TYPE_ALL          = 0xff

or any combination of these. For example you can use 0xC to get both 
static and dynamic registry output.

Example set DAT_DBG_LEVEL=0xC

DAT_DBG_DEST
------------ 

Value sets the output destination, valid values are 

DAT_OS_DBG_DEST_STDOUT = 0x1
DAT_OS_DBG_DEST_SYSLOG = 0x2 
DAT_OS_DBG_DEST_ALL    = 0x3 

For example, 0x3 will output to both stdout and the syslog. 
</pre>
</blockquote>
<h4><u>DAPL Provider library environment variables</u></h4>
<blockquote>
	<p><font size="2">DAPL_DBG_TYPE<br>-------------<br><br>
	<font face="Courier New">Value specifies which parts of the registry will print 
debugging information, valid values are</font> <br><br></font>
	<font face="Courier New"><font size="2">DAPL_DBG_TYPE_ERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0x0001<br>DAPL_DBG_TYPE_WARN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0x0002<br>DAPL_DBG_TYPE_EVD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0x0004<br>DAPL_DBG_TYPE_CM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0x0008<br>DAPL_DBG_TYPE_EP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0x0010<br>DAPL_DBG_TYPE_UTIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0x0020<br>DAPL_DBG_TYPE_CALLBACK&nbsp;&nbsp;&nbsp;&nbsp; = 0x0040<br>DAPL_DBG_TYPE_DTO_COMP_ERR = 0x0080<br>DAPL_DBG_TYPE_API&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0x0100<br>DAPL_DBG_TYPE_RTN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0x0200<br>DAPL_DBG_TYPE_EXCEPTION&nbsp;&nbsp;&nbsp; = 0x0400<br>
	<br>or any combination of these. For example you can use 0xC to get both <br>EVD and CM output.<br>
	<br>Example set DAPL_DBG_TYPE=0xC<br><br><br>DAPL_DBG_DEST<br>-------------<br>
	<br>Value sets the output destination, valid values are <br><br>DAPL_DBG_DEST_STDOUT = 0x1<br>DAPL_DBG_DEST_SYSLOG = 0x2
	<br>DAPL_DBG_DEST_ALL&nbsp;&nbsp;&nbsp; = 0x3 <br><br>For example, 0x3 will output to both stdout and the syslog.</font>
	</font><br><br></p>
<p align="left"><a href="#TOP"><font color="#000000">&lt;<b>return-to-top</b>&gt;</font></a><br></p>
</blockquote><hr>
<BLOCKQUOTE></BLOCKQUOTE>
<h3><a name="DAPLTEST"></a>DAPLTEST</h3>
<pre>

    dapltest - test for the Direct Access Provider Library (DAPL) v2.0

DESCRIPTION

    Dapltest is a set of tests developed to exercise, characterize,
    and verify the DAPL interfaces during development and porting.
    At least two instantiations of the test must be run.  One acts
    as the server, fielding requests and spawning server-side test
    threads as needed.  Other client invocation connects to the
    Dapltest server and issue test requests.

    The server side of the test, once invoked, listens continuously
    for client connection requests, until quit or killed.  Upon
    receipt of a connection request, the connection is established,
    the server and client sides swap version numbers to verify that
    they are able to communicate, and the client sends the test
    request to the server.  If the version numbers match, and the
    test request is well-formed, the server spawns the threads
    needed to run the test before awaiting further connections.

USAGE

    dapltest [ -f script_file_name ]
             [ -T S|Q|T|P|L ] [ -D device_name ] [ -d ] [ -R HT|LL|EC|PM|BE ]

    With no arguments, dapltest runs as a server using default values,
    and loops accepting requests from clients.  The -f option allows
    all arguments to be placed in a file, to ease test automation.
    The following arguments are common to all tests:

    [ -T S|Q|T|P|L ]    Test function to be performed:
                            S   - server loop
                            Q   - quit, client requests that server
                                  wait for any outstanding tests to
                                  complete, then clean up and exit
                            T   - transaction test, transfers data between 
                                  client and server
                            P   - performance test, times DTO operations
                            L   - limit test, exhausts various resources,
                                  runs in client w/o server interaction
                        Default: S

    [ -D device_name ]  Specifies the name of the device (interface adapter).
                        Default: host-specific, look for DT_MdepDeviceName
                                 in dapl_mdep.h

    [ -d ]              Enables extra debug verbosity, primarily tracing
			of the various DAPL operations as they progress.
			Repeating this parameter increases debug spew.
			Errors encountered result in the test spewing some
			explanatory text and stopping; this flag provides
			more detail about what lead up to the error.
                        Default: zero

    [ -R BE ]           Indicate the quality of service (QoS) desired.
                        Choices are:
                            HT  - high throughput
                            LL  - low latency
                            EC  - economy (neither HT nor LL)
                            PM  - premium
                            BE  - best effort
                        Default: BE

USAGE - Quit test client

    dapltest [Common_Args] [ -s server_name ]

    Quit testing (-T Q) connects to the server to ask it to clean up and
    exit (after it waits for any outstanding test runs to complete).
    In addition to being more polite than simply killing the server,
    this test exercises the DAPL object teardown code paths.
    There is only one argument other than those supported by all tests:

    -s server_name      Specifies the name of the server interface.
                        No default.


USAGE - Transaction test client

    dapltest [Common_Args] [ -s server_name ]
             [ -t threads ] [ -w endpoints ] [ -i iterations ] [ -Q ] 
             [ -V ] [ -P ] OPclient OPserver [ op3, 

    Transaction testing (-T T) transfers a variable amount of data between 
    client and server.  The data transfer can be described as a sequence of 
    individual operations; that entire sequence is transferred 'iterations' 
    times by each thread over all of its endpoint(s).

    The following parameters determine the behavior of the transaction test:

    -s server_name      Specifies the hostname of the dapltest server.
                        No default.

    [ -t threads ]      Specify the number of threads to be used.
                        Default: 1

    [ -w endpoints ]    Specify the number of connected endpoints per thread.
                        Default: 1

    [ -i iterations ]   Specify the number of times the entire sequence
                        of data transfers will be made over each endpoint.
                        Default: 1000

    [ -Q ]              Funnel completion events into a CNO.
			Default: use EVDs

    [ -V ]              Validate the data being transferred.
			Default: ignore the data

    [ -P ]		Turn on DTO completion polling
			Default: off

    OP1 OP2 [ OP3, ... ]
                        A single transaction (OPx) consists of:

                        server|client   Indicates who initiates the
                                        data transfer.

                        SR|RR|RW        Indicates the type of transfer:
                                        SR  send/recv
                                        RR  RDMA read
                                        RW  RDMA write
                        Defaults: none

                        [ seg_size [ num_segs ] ]
                                        Indicates the amount and format
                                        of the data to be transferred.
                                        Default:  4096  1
                                                  (i.e., 1 4KB buffer)

                        [ -f ]          For SR transfers only, indicates
                                        that a client's send transfer
                                        completion should be reaped when
                                        the next recv completion is reaped.
					Sends and receives must be paired
					(one client, one server, and in that
					order) for this option to be used.

    Restrictions:  
    
    Due to the flow control algorithm used by the transaction test, there 
    must be at least one SR OP for both the client and the server.  

    Requesting data validation (-V) causes the test to automatically append 
    three OPs to those specified. These additional operations provide 
    synchronization points during each iteration, at which all user-specified 
    transaction buffers are checked. These three appended operations satisfy 
    the &quot;one SR in each direction&quot; requirement.

    The transaction OP list is printed out if -d is supplied.

USAGE - Performance test client

    dapltest [Common_Args] -s server_name [ -m p|b ]
             [ -i iterations ] [ -p pipeline ] OP

    Performance testing (-T P) times the transfer of an operation.
    The operation is posted 'iterations' times.

    The following parameters determine the behavior of the transaction test:

    -s server_name      Specifies the hostname of the dapltest server.
                        No default.

    -m b|p		Used to choose either blocking (b) or polling (p)
                        Default: blocking (b)

    [ -i iterations ]   Specify the number of times the entire sequence
                        of data transfers will be made over each endpoint.
                        Default: 1000

    [ -p pipeline ]     Specify the pipline length, valid arguments are in 
                        the range [0,MAX_SEND_DTOS]. If a value greater than 
                        MAX_SEND_DTOS is requested the value will be
                        adjusted down to MAX_SEND_DTOS.
                        Default: MAX_SEND_DTOS

    OP
                        An operation consists of:

                        RR|RW           Indicates the type of transfer:
                                        RR  RDMA read
                                        RW  RDMA write
                        Default: none

                        [ seg_size [ num_segs ] ]
                                        Indicates the amount and format
                                        of the data to be transferred.
                                        Default:  4096  1
                                                  (i.e., 1 4KB buffer)

USAGE - Limit test client

    Limit testing (-T L) neither requires nor connects to any server
    instance.  The client runs one or more tests which attempt to
    exhaust various resources to determine DAPL limits and exercise
    DAPL error paths.  If no arguments are given, all tests are run.

    Limit testing creates the sequence of DAT objects needed to
    move data back and forth, attempting to find the limits supported
    for the DAPL object requested.  For example, if the LMR creation
    limit is being examined, the test will create a set of
    {IA, PZ, CNO, EVD, EP} before trying to run dat_lmr_create() to
    failure using that set of DAPL objects.  The 'width' parameter
    can be used to control how many of these parallel DAPL object
    sets are created before beating upon the requested constructor.
    Use of -m limits the number of dat_*_create() calls that will
    be attempted, which can be helpful if the DAPL in use supports
    essentailly unlimited numbers of some objects.

    The limit test arguments are:

    [ -m maximum ]      Specify the maximum number of dapl_*_create()
                        attempts.
                        Default: run to object creation failure

    [ -w width ]        Specify the number of DAPL object sets to
                        create while initializing.
                        Default: 1

    [ limit_ia ]        Attempt to exhaust dat_ia_open()

    [ limit_pz ]        Attempt to exhaust dat_pz_create()

    [ limit_cno ]       Attempt to exhaust dat_cno_create()

    [ limit_evd ]       Attempt to exhaust dat_evd_create()

    [ limit_ep ]        Attempt to exhaust dat_ep_create()

    [ limit_rsp ]       Attempt to exhaust dat_rsp_create()

    [ limit_psp ]       Attempt to exhaust dat_psp_create()

    [ limit_lmr ]       Attempt to exhaust dat_lmr_create(4KB)

    [ limit_rpost ]     Attempt to exhaust dat_ep_post_recv(4KB)

    [ limit_size_lmr ]  Probe maximum size dat_lmr_create()

                        Default: run all tests


<a name="DAPLtest-examples"></a>EXAMPLES

    dapltest -T S -d -D ibnic0v2

                        Starts a local dapltest server process with debug verbosity.
                        Server loops (listen for dapltest request, process request).
    
    dapltest -T T -d -s winIB -D ibnic0v2 -i 100 client SR 4096 2 server SR 4096 2

                        Runs a transaction test, with both sides
                        sending one buffer with two 4KB segments,
                        one hundred times; dapltest server is on host winIB.

    dapltest -T P -d -s winIB -D ibnic0v2 -i 100 RW 4096 2

                        Runs a performance test, with the client 
                        RDMA writing one buffer with two 4KB segments,
                        one hundred times.

    dapltest -T Q -s winIB -D ibnic0v2

                        Asks the dapltest server at host 'winIB' to clean up and exit.

    dapltest -T L -D ibnic0v2 -d -w 16 -m 1000

                        Runs all of the limit tests, setting up
                        16 complete sets of DAPL objects, and
                        creating at most a thousand instances
                        when trying to exhaust resources.

    dapltest -T T -V -d -t 2 -w 4 -i 55555 -s winIB -D ibnic0v2 \
       client RW  4096 1    server RW  2048 4    \
       client SR  1024 4    server SR  4096 2    \
       client SR  1024 3 -f server SR  2048 1 -f

                        Runs a more complicated transaction test,
                        with two thread using four EPs each,
                        sending a more complicated buffer pattern
                        for a larger number of iterations,
                        validating the data received.</pre>
<pre>
dt-svr.bat - DAPLtest server script; starts a DAPL2test.exe server on the local system.
	dt-svr DAPL-provider [-D [hex-debug-bitmask] ]</pre>
<blockquote>
	<blockquote>
		<pre>where: DAPL-provider can be one of [ ibal | scm | cma ]</pre>
		<blockquote>
			<ul>
				<li>
				<pre>ibal - Original InfiniBand Access Layer (eye-bal) ibal verbs interface</pre>
				</li>
				<li>
				<pre>scm - Socket-CM (Connection Manager), exchanges QP information over a n IP socket.</pre>
				</li>
				<li>
				<pre>cma - rdma CM, use the OFED rdma Communications Manager to create the QP connection.</pre>
				</li>
				<li>
				<pre>or the DAPL-provider name from %SystemDrive%\DAT\dat.conf</pre>
				</li>
			</ul>
		</blockquote>
	</blockquote>
</blockquote>
<pre>dt-cli.bat - DAPLtest client; drives testing by interacting with dt-svr.bat script.
	dt-cli DAPL-provider host-IPv4-address testname [-D [hex-debug-bitmask] ]
		example: dt-cli ibnic0v2 10.10.2.20 trans
		         dt-cli -h  # outputs help text.
			 dt-svr ibnic0v2	# IBAL dapltest server listening on port HCA0</pre>
<pre>
Verify dt-*.bat script is running same dapl2test.exe(DAPL v2.0)


BUGS  (and To Do List)

    Use of CNOs (-Q) is not yet supported.

    Further limit tests could be added.</pre>
<h4 align="left"><a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></h4>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<BLOCKQUOTE></BLOCKQUOTE>
<h2 align="left"><u><a name="SRP"></a></u>SRP (SCSI RDMA) Protocol Driver</h2>
<hr>
<p align="left"><span style="color: black">
<font face="Times New Roman" size="3">The
<a href="http://infiniband.sourceforge.net/Storage/SRP/overview.htm">SCSI RDMA 
Protocol </a>&nbsp;(SRP) is an emerging industry standard protocol for utilizing 
block storage devices over an InfiniBand™ fabric. SRP is being defined in the 
ANSI T-10 committee.</font></span></p>
<p align="left"><font face="Times New Roman">OFED </font>SRP is a storage 
driver implementation that enables the SCSI RDMA protocol over an InfiniBand 
fabric.<br>
The implementation conforms
to the T10 Working Group draft
<a href="http://www.t10.org/ftp/t10/drafts/srp/srp-r16a.pdf">
http://www.t10.org/ftp/t10/drafts/srp/srp-r16a.pdf</a>.</p>
<h4 align="left"><u>Software Dependencies</u></h4>
<p align="left">The SRP driver depends on the installation of the OFED stack 
with a Subnet<br>
Manager running somewhere on the IB fabric.<br>
<br>
- Supported Operating Systems and Service Packs:<br>
&nbsp;&nbsp; o Windows 7 (x86 &amp; x64)<br>
&nbsp;&nbsp; o Windows Server 2008 R2&nbsp; (x86, x64)<br>
&nbsp;&nbsp; o Windows Server 2008 R2 HPC Edition (x64,x86)<br>
&nbsp;&nbsp; o Windows Server 2008 &amp; Vista&nbsp; (x86, x64)</p>
<h4 align="left"><u>Testing Levels</u></h4>
<p align="left">The SRP driver has undergone basic testing against Mellanox 
Technologies'
SRP Targets MTD1000 and MTD2000.<br>
Additionally the Linux RHEL 5.3 with OFED 1.5.1 SRP target using scst 1.0.1.1 (vdisk with 
blockio) has been tested.<br>
<br>
Testing included SRP target drive format, read, write and dismount/offline
operations from the Windows SRP initiator system.<br>
&nbsp;</p>
<h4 align="left"><u>Installation</u></h4>
<p align="left">The OFED installer does not install the SRP driver as part of a default 
installation.&nbsp; 
If the SRP feature is selected in the custom features installation view, an InfiniBand 
SRP Miniport driver will be installed; see the device manager view under SCSI 
and RAID controllers.</p>
<p align="left">The system device 'InfiniBand I/O Unit' (IOU) 
device is required for correct SRP operation.&nbsp; The OFED installer will 
install and load the IOU driver if the SRP feature is selected.&nbsp; See the device 
manager view System Devices --&gt; InfiniBand I/O Unit for conformation of correct 
IOU driver loading.</p>
<p align="left">In order for the SRP miniport driver installation to complete, an SRP target must be
detected by a Subnet Manager running somewhere on the InfiniBand fabric; either 
a local or remote Subnet Manager will work.</p>
<h4 align="left"><u>SRP Driver Uninstall</u></h4>
<p align="left">If the SRP (SCSI RDMA Protocol) driver has been previously 
installed, then in order to achieve a 'clean' uninstall, the SRP target drive(s) 
must be released.</p>
<p align="left">For Server 2008, 2008 R2 and win7 systems, the Storage manager 
implements a disk on/off-line right-click functionality.</p>
<p align="left">&nbsp;The consequences of not releasing (offline'ing) the SRP target drive(s) are that after the 
OFED uninstall reboot there are lingering InfiniBand driver files. These driver 
files remain because while the SRP target is active they have references, thus 
when the OFED uninstall attempts to delete the files the operation fails.</p>
<p align="left">SRP supports WPP tracing tools by using the GUID: 
'5AF07B3C-D119-4233-9C81-C07EF481CBE6'.&nbsp; The flags and level of debug can be controlled at load-time or run-time; 
see ib_srp.inf file for details.</p>
<h4 align="left"><u>Constructing a RHEL 5.3 OFED 1.5.1 SRP vdisk BLOCKIO target</u></h4>
<p align="left">Example assumptions:</p>
<ul>
	<li>
	<p align="left">Red Hat Enterprise Linux Server release 5 (Tikanga) EL 5.3 
	(2.6.18-128.el5)<br>
	Later RHEL 5.4 releases will work with some minor scst compile time fixes 
	and later OFED releases.</p></li>
	<li>
	<p align="left">Linux SRP Target has /dev/sdb[123]<br>
	sizeof(sdb1) &lt; sdb2 &lt; sdb3; test convention only.</p></li>
	<li>
	<p align="left">scst-1.0.1.1.tgz is required; later versions of scst do not 
	interoperate with the current windows srp client.</p></li>
	<li>
	<p align="left"><a href="http://sourceforge.net/projects/scst/files/scst/">download scst-1.0.1.1</a></p></li>
</ul>
<p align="left">Use out of the box scst defines which include (#undef 
STRICT_SERIALIZING),<br>
'no' kernel mods are required for BLOCKIO access to /dev/sdb[123].<br>
<br>
cd scst-1.0.1.1<br>
make &amp;
make install</p>
<p align="left">Patch /usr/local/include/scst/scst.h per instructions in 
OFED-1.5.1/docs/SRPT_README.txt<br>
&nbsp;</p>
<p align="left">Unpack OFED-1.5.1<br>
cd OFED-1.5.1<br>
build OFED select #3 for 'all' OFED components<br>
&nbsp; - no SRP loads in /etc/infiniband/openib.conf, edit prior to reboot.</p>
<p align="left">REBOOT.<br>
<br>
./LOAD &amp; ./UNLOAD scripts are manual versions of what scstAdmin (separate scst 
package) will do minus<br>
loading the OFED driver ib_srpt.<br>
<br>
SRP targets formatted from Windows using default NTFS allocation size.<br>
Partition size &amp; numbering is derrived from local test conventions; your setup 
may be different.<br>
<br>
/dev/sdb1&nbsp; &lt; 1GB<br>
/dev/sdb2 &gt; 1GB<br>
/dev/sdb3 &gt; sdb2</p>
<p align="left">&nbsp;</p>
<h4 align="left"><u>Manual SRP Target LOAD script</u></h4>
<div align="left">
	<pre>#!/bin/sh 

GRP=Default

if [ ! -e /proc/scsi_tgt ] ; then
  echo -n Loading scst driver
  modprobe scst
  if [ $? -ne 0 ] ; then
    echo
    echo err $? modprobe scst
    exit $?
  fi
  echo ...OK
fi 

if [ ! -e /proc/scsi_tgt/vdisk ] ; then
  echo -n Loading scst_vdisk driver
  modprobe scst_vdisk
  if [ $? -ne 0 ] ; then
    echo
    echo err $? modprobe scst_vdisk
    exit $?
  fi
  echo ...OK
fi 

fgrep -q ib_srpt /proc/modules
if [ $? -ne 0 ] ; then
  modprobe ib_srpt
  echo ib_srpt...OK
fi 

echo -n Open SRP devices srp[123]
echo &quot;open srp1 /dev/sdb1 512 BLOCKIO&quot; &gt; /proc/scsi_tgt/vdisk/vdisk
if [ $? -ne 0 ] ; then
  echo err $? open srp1 /dev/sdb1
  exit $?
fi
echo &quot;open srp2 /dev/sdb2 512 BLOCKIO&quot; &gt; /proc/scsi_tgt/vdisk/vdisk
if [ $? -ne 0 ] ; then
  echo err $? open srp2 /dev/sdb2
  exit $?
fi
echo &quot;open srp3 /dev/sdb3 512 BLOCKIO&quot; &gt; /proc/scsi_tgt/vdisk/vdisk
if [ $? -ne 0 ] ; then
  echo err $? open srp3 /dev/sdb3
  exit $?
fi
echo ...OK

echo -n Set allowed hosts access...
echo &quot;add *&quot; &gt; /proc/scsi_tgt/groups/Default/names
echo ...OK

echo -n Adding targets srp[123] as LUNs [012] in group $GRP
echo &quot;add srp1 0&quot; &gt; /proc/scsi_tgt/groups/Default/devices
if [ $? -ne 0 ] ; then
  echo
  echo err $? add srp1 0
  exit $?
fi
echo &quot;add srp2 1&quot; &gt; /proc/scsi_tgt/groups/Default/devices
if [ $? -ne 0 ] ; then
  echo
  echo err $? add srp2 1
  exit $?
fi
echo &quot;add srp3 2&quot; &gt; /proc/scsi_tgt/groups/Default/devices
if [ $? -ne 0 ] ; then
  echo
  echo err $? add srp3 2
  exit $?
fi
echo ...OK
</pre>
</div>
<div align="left">
	<h4 align="left"><u>Manual SRP Target UNLOAD script</u></h4>
	<pre>#!/bin/sh

if [ -w /proc/scsi_tgt/vdisk/vdisk ] ; then
  echo -n Closing SRP Targets srp[321]...
  echo &quot;close srp3&quot; &gt; /proc/scsi_tgt/vdisk/vdisk
  echo &quot;close srp2&quot; &gt; /proc/scsi_tgt/vdisk/vdisk
  echo &quot;close srp1&quot; &gt; /proc/scsi_tgt/vdisk/vdisk
  echo Done.
fi

fgrep -q scst_vdisk /proc/modules
if [ $? -eq 0 ] ; then
  modprobe -r scst_vdisk
fi

fgrep -q ib_srpt /proc/modules
if [ $? -eq 0 ] ; then
  modprobe -r ib_srpt
fi

fgrep -q scst /proc/modules
if [ $? -eq 0 ] ; then
  modprobe -r scst
fi
</pre>
</div>
<h4 align="left"><a href="#TOP"><font color="#000000" size="4">&lt;return-to-top&gt;</font></a></h4>
<h3>&nbsp;</h3>
<BLOCKQUOTE></BLOCKQUOTE>
<h2><u><a name="QLOGICVNIC"></a></u>QLogic VNIC Configuration</h2>
<hr>
<p><font face="Arial">
<span style="font-size: 12pt; font-family: Times New Roman">The QLogic VNIC 
(Virtual Network Interface Card) driver in conjunction with the QLogic Ethernet 
Virtual I/O Controller (EVIC) provides virtual Ethernet interfaces and transport 
for Ethernet packets over Infiniband.<br>
<br>
Users can modify NIC parameters through User Interface icon in Network 
Connections:<br>
( Properties-&gt;&quot;Configure...&quot; button -&gt; &quot;Advanced&quot; Tab).</span></p>
<p class="MsoPlainText" style="MARGIN: 0in 0in 0pt">
<span style="font-size: 12pt; font-family: Times New Roman">Parameters 
available:<br>
<br>
Vlan Id (802.1Q)&nbsp;</span></p>
<p class="MsoPlainText" style="MARGIN: 0in 0in 0pt">
<span style="font-size: 12pt; font-family: Times New Roman">&nbsp; values from 0 to 
4094 ( default&nbsp;<span class="899314318-23042008">0, </span>disabled )<br>
&nbsp; This specifies if VLAN ID-marked packet transmission is enabled and, if so, 
specifies the ID.<br>
<br>
Priority (802.1P)</span></p>
<p class="MsoPlainText" style="MARGIN: 0in 0in 0pt">
<span style="font-size: 12pt; font-family: Times New Roman">&nbsp; values from 0 to 7 
( default 0, feature disabled)<br>
&nbsp; This specifies if priority-marked packet transmission is enabled.<br>
<br>
Payload MTU size&nbsp;</span></p>
<p class="MsoPlainText" style="MARGIN: 0in 0in 0pt">
<span style="font-size: 12pt; font-family: Times New Roman">&nbsp; values from 1500 
to 9500 (default 1500)<br>
&nbsp; This specifies the maximum transfer unit size in 100 bytes increments.<br>
<br>
Recv ChkSum offload&nbsp;</span></p>
<p class="MsoPlainText" style="MARGIN: 0in 0in 0pt">
<span style="font-size: 12pt; font-family: Times New Roman">&nbsp; (default enabled)<br>
&nbsp; This specifies if IP protocols checksum calculations for receive is offloaded.<br>
<br>
Send ChkSum offload</span></p>
<p class="MsoPlainText" style="MARGIN: 0in 0in 0pt">
<span style="font-size: 12pt; font-family: Times New Roman">&nbsp; (default enabled)<br>
&nbsp; This specifies if IP protocols checksum calculations for send is offloaded.<br>
&nbsp;</span></p>
<p class="MsoPlainText" style="MARGIN: 0in 0in 0pt">
<span style="font-size: 12pt; font-family: Times New Roman">Secondary Path&nbsp;</span></p>
<p class="MsoPlainText" style="MARGIN: 0in 0in 0pt">
<span style="font-size: 12pt; font-family: Times New Roman">&nbsp;&nbsp; (default 
disabled)<br>
&nbsp;&nbsp; Enabled - If more than one IB path to IOC exist then secondary IB instance of 
virtual port will be created and configured with the same parameters as primary 
one. Failover from Primary to Secondary IB path is transparent for user 
application sending data through associated NIC.<br>
<br>
&nbsp;&nbsp; Disabled – only one path at a time is allowed. If more than one path to IOC 
exists then failed path will be destroyed and next available path will be used 
for new connection. With this scenario there is a possibility new interface 
instance will be assigned different MAC address when other hosts compete for 
EVIC resources.<br>
&nbsp;</span></p>
<p class="MsoPlainText" style="MARGIN: 0in 0in 0pt">
<font face="Times New Roman" size="3">LBFO Bundle Id<br>
&nbsp;&nbsp; (default disabled) Enabling support for OS provided Load Balancing and Fail 
Over functionality on adapter level.<br>
&nbsp;&nbsp; If enabled group ID can be selected from predefined names.</font></p>
<p class="MsoPlainText" style="MARGIN: 0in 0in 0pt">
<span style="font-size: 12pt; font-family: Times New Roman">&nbsp;</span></p>
<p class="MsoPlainText" style="MARGIN: 0in 0in 0pt">
<span style="font-size: 12pt; font-family: Times New Roman">Heartbeat interval</span></p>
<p class="MsoPlainText" style="MARGIN: 0in 0in 0pt">
<span style="font-size: 12pt; font-family: Times New Roman">&nbsp;&nbsp; configures 
interval for VNIC protocol heartbeat messages in milliseconds.<br>
&nbsp;&nbsp; 0 – heartbeats disabled.<br>
<br>
Note:<br>
&nbsp;&nbsp; To take advantage of the features supported by these options, ensure that the 
Ethernet gateway is also configured appropriately.&nbsp; For example, if the Payload 
MTU for a VNIC interface is set to&nbsp;<span class="899314318-23042008">4</span>000, 
the MTU at the EVIC module must also be set at least&nbsp;<span class="899314318-23042008">4</span>000 
for the setting to take effect.</span></p>
</font>
<h3>&nbsp;<a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></h3>
<p>&nbsp;</p>
<h2><u><a name="qlgcvnicconfig"></a></u>QLogic VNIC Child Device Management</h2>
<hr>
<p><font face="Arial">
<span style="font-size: 12pt; font-family: Times New Roman">Each I/O Controller (IOC) of QLogic's EVIC gateway 
device is able to handle 256 connections per host. So a single host can have multiple VNIC interfaces connecting to the same
IOC. So qlgcvnic_config can be used to create multiple VNIC interfaces by giving local channel adapter node guid and 
target ioc guid parameters as input.<br> </span></p>
<p class="MsoPlainText" style="MARGIN: 0in 0in 0pt">
<span style="font-size: 12pt; font-family: Times New Roman">
Usage:
<br><br>
<span style="text-decoration: underline;">Create child vnic devices</span>
<br><br>
qlgcvnic_config -c {caguid}&nbsp;&nbsp;{iocguid}&nbsp;&nbsp;{instanceid}&nbsp;&nbsp;{interface description}
<br><br>
caguid -- Local HCA node guid value in hex format (may start with "0x")
<br>
iocguid -- Target IOC's guid vale in hex format (may start with "0x")
<br>
instanceid -- InstanceID is used to distinguish between different child devices created by IBAL. So this must be a unique 
value. InstanceID is a 32bit value. User input should be in decimal format.
<br>
interface description -- Description that should be shown in device manager's device tree for the child device.
<br><br>
<span style="text-decoration: underline;">Listing Channel Adapter to IOC paths</span>
<br><br>
Executing qlgcvnic_config without any option or with -l option will list the IOCs reachable from the host.
<br>

<h3>&nbsp;<a href="#TOP"><font color="#000000">&lt;return-to-top&gt;</font></a></h3>
<p>&nbsp;</p>
<BLOCKQUOTE></BLOCKQUOTE>
<h2><a name="InfiniBand_Software_Development_Kit">OFED Software 
Development Kit</a></h2>
<hr>
<p>If selected during install, the OFED Software Development Kit will 
be installed as '%SystemDrive%\OFED_SDK'. Underneath the OFED_SDK\ folder you will find 
the following folders:</p>
<ul>
	<li>&nbsp;'Inc\'&nbsp;&nbsp;&nbsp; include files</li>
	<li>'Lib\'ibrary definition files</li>
	<li>'Samples' example codes to demonstrate building and use of OFED 
	interfaces.</li>
</ul>
<h4>Compilation:</h4>
<blockquote>
	<p>Add the additional include path '%SystemDrive%\OFED_SDK\Inc'; resource files 
	may also use this path.</p>
</blockquote>
<h4>Linking:</h4>
<blockquote>
	<p>Add the additional library search path '%SystemDrive%\OFED_SDK\Lib'.</p>
	<p>Include dependent libraries: ibal.lib and complib.lib, or ibal32.lib &amp; 
	complib32.lib for win32 applications on 64-bit platforms.</p>
</blockquote>
<h4>Samples:</h4>
<ul>
	<li>WDK\&nbsp;&nbsp;&nbsp; demonstrates how to build an OFED application in the <b>Windows</b>
	<b>Driver Kit (WDK) </b>environment.<br>
	Consult the README.txt file for details.<br>
	See <a href="http://www.microsoft.com/whdc/Devtools/wdk/default.mspx">
	http://www.microsoft.com/whdc/Devtools/wdk/default.mspx</a>&nbsp; for WDK details.<br>
&nbsp;</li>
	<li>rdma_bw\&nbsp;&nbsp;&nbsp; demonstrates how to build an OFED IB verbs 
	application in the Visual Studio environment.<br>
	Consult the README.txt file for details.<br>
&nbsp;</li>
	<li>cmtest\&nbsp;&nbsp;&nbsp; demonstrates how to build an IB (ibal) application in the 
	Visual Studio environment.<br>
	Consult the README.txt file for details.<br>
&nbsp;</li>
</ul>

<p align="left"><a href="#TOP"><font color="#000000">&lt;<b>return-to-top</b>&gt;</font></a></p>
<p align="left">&nbsp;</p>
<h2 align="left"><a name="OFED_InfiniBand_Verbs">OFED InfiniBand Verbs</a></h2>
<hr>
</span>
<span style="font-size: 12pt; ">
<p align="left"><b>NAME</b><br>
<br>&nbsp;&nbsp;&nbsp;
libibverbs.lib - OpenFabrics Enterprise Distribution (OFED) Infiniband verbs library <br><br>
<b>SYNOPSIS<br>
</b><br>&nbsp;&nbsp;&nbsp;
#include &lt;infiniband/verbs.h&gt;<br>
<br><b>DESCRIPTION</b></p>
<blockquote>
	<p align="left">This library is an implementation of the verbs based on the Infiniband 
specification volume 1.2 chapter 11. It handles the control path of creating, 
modifying, querying and destroying resources such as Protection Domains (PD), 
Completion Queues (CQ), Queue-Pairs (QP), Shared Receive Queues (SRQ), Address 
Handles (AH), Memory Regions (MR). It also handles sending and receiving data 
posted to QPs and SRQs, getting completions from CQs using polling and 
completions events.<br><br>The control path is implemented through system calls to the uverbs kernel module 
which further calls the low level HW driver. The data path is implemented through 
calls made to low level HW library which in most cases interacts directly with 
the HW providing kernel and network stack bypass (saving context/mode switches) 
along with zero copy and an asynchronous I/O model.<br><br>Typically, under network and RDMA programming, there are operations which 
involve interaction with remote peers (such as address resolution and connection 
establishment) and remote entities (such as route resolution and joining a 
multicast group under IB), where a resource managed through IB verbs such as QP 
or AH would be eventually created or effected from this interaction. In such 
cases, applications whose addressing semantics is based on IP can use librdmacm 
(see rdma_cm) which works in conjunction with libibverbs.<br><br>This library is thread safe library and verbs can be called from every thread in 
the process (the same resource can even be handled from different threads, for 
example: ibv_poll_cq can be called from more than one thread).<br><br>However, it is up to the user to stop working with a resource after it was 
destroyed (by the same thread or by any other thread), this may result a 
segmentation fault.</p>
	<p align="left">The following shall be declared as functions and may also be defined as
macros.</p>
</blockquote>
<blockquote>
	<p align="left">Function prototypes are provided in 
<span style="font-size: 12pt; ">
	%SystemDrive%</span>\OFED_SDK\inc\infiniband\verbs.h.<br>
	<br>Link to 
	%SystemDrive%\OFED_SDK\lib\libibverbs.lib</p>
</blockquote>
<p align="left"><b>Device functions</b></p>
<blockquote>
	<p align="left">struct ibv_device **<a href="#IBV_GET_DEVICE_LIST">ibv_get_device_list</a>(int *num_devices);</p>
	<p align="left">void <a href="#IBV_FREE_DEVICE_LIST">ibv_free_device_list</a>(struct ibv_device **list);</p>
	<p align="left">const char *<a href="#IBV_GET_DEVICE_NAME">ibv_get_device_name</a>(struct ibv_device *device);</p>
	<p align="left">uint64_t <a href="#IBV_GET_DEVICE_GUID">ibv_get_device_guid</a>(struct ibv_device *device);</p>
</blockquote>
<p align="left"><b>Context functions</b></p>
<blockquote>
	<p align="left">struct ibv_context *<a href="#IBV_OPEN_DEVICE">ibv_open_device</a>(struct ibv_device *device);</p>
	<p align="left">int <a href="#IBV_CLOSE_DEVICE">ibv_close_device</a>(struct ibv_context *context);</p>
</blockquote>
<p align="left"><b>Queries</b></p>
<blockquote>
	<p align="left">int <a href="#IBV_QUERY_DEVICE">ibv_query_device</a>(struct ibv_context *context,
struct ibv_device_attr *device_attr);</p>
	<p align="left">int <a href="#IBV_QUERY_PORT">ibv_query_port</a>(struct ibv_context *context, uint8_t port_num,
struct ibv_port_attr *port_attr);</p>
	<p align="left">int <a href="#IBV_QUERY_PKEY">ibv_query_pkey</a>(struct ibv_context *context, uint8_t port_num,
int index, uint16_t *pkey);</p>
	<p align="left">int <a href="#IBV_QUERY_GID">ibv_query_gid</a>(struct ibv_context *context, uint8_t port_num,
int index, union ibv_gid *gid);</p>
</blockquote>
<p align="left"><b>Asynchronous events</b></p>
<blockquote>
	<p align="left">int <a href="#IBV_GET_ASYNC_EVENT">ibv_get_async_event</a>(struct ibv_context *context,
struct ibv_async_event *event);</p>
	<p align="left">void <a href="#IBV_ACK_ASYNC_EVENT">ibv_ack_async_event</a>(struct ibv_async_event *event);</p>
</blockquote>
<p align="left"><b>Protection Domains</b></p>
<blockquote>
	<p align="left">struct ibv_pd *<a href="#IBV_ALLOC_PD">ibv_alloc_pd</a>(struct ibv_context *context);</p>
	<p align="left">int <a href="#IBV_DEALLOC_PD">ibv_dealloc_pd</a>(struct ibv_pd *pd);</p>
</blockquote>
<p align="left"><b>Memory Regions</b></p>
<blockquote>
	<p align="left">struct ibv_mr *<a href="#IBV_REG_MR">ibv_reg_mr</a>(struct ibv_pd *pd, void *addr,
size_t length, enum ibv_access_flags access);</p>
	<p align="left">int <a href="#IBV_DEREG_MR">ibv_dereg_mr</a>(struct ibv_mr *mr);</p>
</blockquote>
<p align="left"><b>Address Handles</b></p>
<blockquote>
	<p align="left">struct ibv_ah *<a href="#IBV_CREATE_AH">ibv_create_ah</a>(struct ibv_pd *pd, struct ibv_ah_attr *attr);<br><br>int
	<a href="#IBV_INIT_AH_FROM_WC">ibv_init_ah_from_wc</a>(struct ibv_context *context, uint8_t port_num,
struct ibv_wc *wc, struct ibv_grh *grh,
struct ibv_ah_attr *ah_attr);<br><br>struct ibv_ah *<a href="#IBV_CREATE_AH_FROM_WC">ibv_create_ah_from_wc</a>(struct ibv_pd *pd, struct ibv_wc *wc,
struct ibv_grh *grh, uint8_t port_num);<br><br>int <a href="#IBV_DESTROY_AH">ibv_destroy_ah</a>(struct ibv_ah *ah);</p>
</blockquote>
<p align="left"><b>Completion event channels</b></p>
<blockquote>
	<p align="left">struct ibv_comp_channel *<a href="#IBV_CREATE_COMP_CHANNEL">ibv_create_comp_channel</a>(struct ibv_context 
	*context);</p>
</blockquote>
<blockquote>
	<p align="left">int <a href="#IBV_DESTROY_COMP_CHANNEL">ibv_destroy_comp_channel</a>(struct ibv_comp_channel *channel);</p>
</blockquote>
<p align="left"><b>Completion Queues Control</b></p>
<blockquote>
	<p align="left">struct ibv_cq *<a href="#IBV_CREATE_CQ">ibv_create_cq</a>(struct ibv_context *context, int cqe,
void *cq_context,
struct ibv_comp_channel *channel,
int comp_vector);<br><br>int <a href="#IBV_DESTROY_CQ">ibv_destroy_cq</a>(struct ibv_cq *cq);<br><br>int
	<a href="#IBV_RESIZE_CQ">ibv_resize_cq</a>(struct ibv_cq *cq, int cqe);</p>
</blockquote>
<p align="left"><b>Reading Completions from CQ</b></p>
<blockquote>
	<p align="left">int <a href="#IBV_POLL_CQ">ibv_poll_cq</a>(struct ibv_cq *cq, int num_entries, struct ibv_wc *wc);</p>
</blockquote>
<p align="left"><b>Requesting / Managing CQ events</b></p>
<blockquote>
	<p align="left">int <a href="#IBV_REQ_NOTIFY_CQ">ibv_req_notify_cq</a>(struct ibv_cq *cq, int solicited_only);</p>
	<p align="left">int <a href="#IBV_GET_CQ_EVENT">ibv_get_cq_event</a>(struct ibv_comp_channel *channel,
struct ibv_cq **cq, void **cq_context);</p>
	<p align="left">void <a href="#IBV_ACK_CQ_EVENTS">ibv_ack_cq_events</a>(struct ibv_cq *cq, unsigned int nevents);</p>
</blockquote>
<p align="left"><b>Shared Receive Queue control</b></p>
<blockquote>
	<p align="left">struct ibv_srq *<a href="#IBV_CREATE_SRQ">ibv_create_srq</a>(struct ibv_pd *pd, struct ibv_srq_init_attr *srq_init_attr);<br>
	<br>int <a href="#IBV_DESTROY_SRQ">ibv_destroy_srq</a>(struct ibv_srq *srq);<br><br>int
	<a href="#IBV_MODIFY_SRQ">ibv_modify_srq</a>(struct ibv_srq *srq, struct ibv_srq_attr *srq_attr, enum ibv_srq_attr_mask srq_attr_mask);<br>
	<br>int <a href="#IBV_QUERY_SRQ">ibv_query_srq</a>(struct ibv_srq *srq, struct ibv_srq_attr *srq_attr);</p>
</blockquote>
<p align="left"><b>eXtended Reliable Connection control</b></p>
<blockquote>
	<p align="left">struct ibv_xrc_domain *<a href="#IBV_OPEN_XRC_DOMAIN">ibv_open_xrc_domain</a>(struct ibv_context *context, int fd, int oflag);<br>
	<br>int <a href="#IBV_CLOSE_XRC_DOMAIN">ibv_close_xrc_domain</a>(struct ibv_xrc_domain *d);<br><br>struct ibv_srq *<a href="#IBV_CREATE_XRC_SRQ">ibv_create_xrc_srq</a>(struct ibv_pd *pd, struct ibv_xrc_domain *xrc_domain, struct ibv_cq *xrc_cq, struct ibv_srq_init_attr *srq_init_attr);<br>
	<br>int <a href="#IBV_CREATE_XRC_RCV_QP">ibv_create_xrc_rcv_qp</a>(struct ibv_qp_init_attr *init_attr, uint32_t *xrc_rcv_qpn);<br>
	<br>int <a href="#IBV_MODIFY_XRC_RCV_QP">ibv_modify_xrc_rcv_qp</a>(struct ibv_xrc_domain *xrc_domain, uint32_t xrc_qp_num, struct ibv_qp_attr *attr, int attr_mask);<br>
	<br>int <a href="#IBV_QUERY_XRC_RCV_QP">ibv_query_xrc_rcv_qp</a>(struct ibv_xrc_domain *xrc_domain, uint32_t xrc_qp_num, struct ibv_qp_attr *attr, int attr_mask, struct ibv_qp_init_attr *init_attr);<br>
	<br>int <a href="#IBV_REG_XRC_RCV_QP">ibv_reg_xrc_rcv_qp</a>(struct ibv_xrc_domain *xrc_domain, uint32_t xrc_qp_num);<br>
	<br>int <a href="#IBV_UNREG_XRC_RCV_QP">ibv_unreg_xrc_rcv_qp</a>(struct ibv_xrc_domain *xrc_domain, uint32_t xrc_qp_num);</p>
</blockquote>
<p align="left"><b>Queue Pair control</b></p>
<blockquote>
	<p align="left">struct ibv_qp *<a href="#IBV_CREATE_QP">ibv_create_qp</a>(struct ibv_pd *pd, struct ibv_qp_init_attr *qp_init_attr);<br>
	<br>int <a href="#IBV_DESTROY_QP">ibv_destroy_qp</a>(struct ibv_qp *qp);<br><br>int
	<a href="#IBV_MODIFY_QP">ibv_modify_qp</a>(struct ibv_qp *qp, struct ibv_qp_attr *attr, enum ibv_qp_attr_mask attr_mask);<br>
	<br>int <a href="#IBV_QUERY_QP">ibv_query_qp</a>(struct ibv_qp *qp, struct ibv_qp_attr *attr, enum ibv_qp_attr_mask attr_mask, struct ibv_qp_init_attr *init_attr);</p>
</blockquote>
<p align="left"><b>Posting Work Requests to QPs/SRQs</b></p>
<blockquote>
	<p align="left">int <a href="#IBV_POST_SEND">ibv_post_send</a>(struct ibv_qp *qp, struct ibv_send_wr *wr, struct ibv_send_wr **bad_wr);<br>
	<br>int <a href="#IBV_POST_RECV">ibv_post_recv</a>(struct ibv_qp *qp, struct ibv_recv_wr *wr, struct ibv_recv_wr **bad_wr);<br>
	<br>int <a href="#IBV_POST_SRQ_RECV">ibv_post_srq_recv</a>(struct ibv_srq *srq, struct ibv_recv_wr *recv_wr, struct ibv_recv_wr **bad_recv_wr);</p>
</blockquote>
<p align="left"><b>Multicast group</b></p>
<blockquote>
	<p align="left">int <a href="#IBV_ATTACH_MCAST">ibv_attach_mcast</a>(struct ibv_qp *qp, union ibv_gid *gid, uint16_t lid);</p>
	<p align="left">int <a href="#IBV_DETACH_MCAST">ibv_detach_mcast</a>(struct ibv_qp *qp, union ibv_gid *gid, uint16_t lid);</p>
</blockquote>
<p align="left"><b>General functions</b></p>
<blockquote>
	<p align="left">int <a href="#IBV_RATE_TO_MULT">ibv_rate_to_mult</a>(enum ibv_rate rate);<br><br>enum ibv_rate
	<a href="#IBV_MULT_TO_RATE">mult_to_ibv_rate</a>(int mult);<br>&nbsp;</p>
</blockquote>
<p align="left"><b>SEE ALSO</b></p>
<blockquote>
	<p align="left"><a href="#IBV_GET_DEVICE_LIST">ibv_get_device_list</a>, 
	<a href="#IBV_FREE_DEVICE_LIST">ibv_free_device_list</a>,<br>
	<a href="#IBV_GET_DEVICE_NAME">ibv_get_device_name</a>, 
	<a href="#IBV_GET_DEVICE_GUID">ibv_get_device_guid</a>, 
	<a href="#IBV_OPEN_DEVICE">ibv_open_device</a>,<br>
	<a href="#IBV_CLOSE_DEVICE">ibv_close_device</a>, 
	<a href="#IBV_QUERY_DEVICE">ibv_query_device</a>, 
	<a href="#IBV_QUERY_PORT">ibv_query_port</a>,<br>
	<a href="#IBV_QUERY_PKEY">ibv_query_pkey</a>, <a href="#IBV_QUERY_GID">ibv_query_gid</a>, 
	<a href="#IBV_GET_ASYNC_EVENT">ibv_get_async_event</a>,<br>
	<a href="#IBV_GET_ASYNC_EVENT">ibv_ack_async_event</a>,
	<a href="#IBV_ALLOC_PD">ibv_alloc_pd</a>, <a href="#IBV_DEALLOC_PD">ibv_dealloc_pd</a>,
	<a href="#IBV_REG_MR">ibv_reg_mr</a>,<br><a href="#IBV_DEREG_MR">ibv_dereg_mr</a>, 
	<a href="#IBV_CREATE_AH">ibv_create_ah</a>, <a href="#IBV_INIT_AH_FROM_WC">ibv_init_ah_from_wc</a>,
	<a href="#IBV_CREATE_AH_FROM_WC">ibv_create_ah_from_wc</a>,<br>
	<a href="#IBV_DESTROY_AH">ibv_destroy_ah</a>,
	<a href="#IBV_CREATE_COMP_CHANNEL">ibv_create_comp_channel</a>,<br>
	<a href="#IBV_DESTROY_COMP_CHANNEL">ibv_destroy_comp_channel</a>,
	<a href="#IBV_CREATE_CQ">ibv_create_cq</a>, <a href="#IBV_DESTROY_CQ">ibv_destroy_cq</a>,<br>
	<a href="#IBV_RESIZE_CQ">ibv_resize_cq</a>, <a href="#IBV_POLL_CQ">ibv_poll_cq</a>,
	<a href="#IBV_REQ_NOTIFY_CQ">ibv_req_notify_cq</a>,<br>
	<a href="#IBV_GET_CQ_EVENT">ibv_get_cq_event</a>,
	<a href="#IBV_ACK_CQ_EVENTS">ibv_ack_cq_events</a>,
	<a href="#IBV_CREATE_SRQ">ibv_create_srq</a>,<br><a href="#IBV_DESTROY_SRQ">ibv_destroy_srq</a>,
	<a href="#IBV_MODIFY_SRQ">ibv_modify_srq</a>, <a href="#IBV_QUERY_SRQ">ibv_query_srq</a>,<br>
	<a href="#IBV_OPEN_XRC_DOMAIN">ibv_open_xrc_domain</a>,
	<a href="#IBV_CLOSE_XRC_DOMAIN">ibv_close_xrc_domain</a>,
	<a href="#IBV_CREATE_XRC_SRQ">ibv_create_xrc_srq</a>,<br>
	<a href="#IBV_CREATE_XRC_RCV_QP">ibv_create_xrc_rcv_qp</a>,
	<a href="#IBV_MODIFY_XRC_RCV_QP">ibv_modify_xrc_rcv_qp</a>,<br>
	<a href="#IBV_QUERY_XRC_RCV_QP">ibv_query_xrc_rcv_qp</a>,
	<a href="#IBV_REG_XRC_RCV_QP">ibv_reg_xrc_rcv_qp</a>,
	<a href="#IBV_UNREG_XRC_RCV_QP">ibv_unreg_xrc_rcv_qp</a>,<br>
	<a href="#IBV_POST_SRQ_RECV">ibv_post_srq_recv</a>, <a href="#IBV_CREATE_QP">ibv_create_qp</a>,
	<a href="#IBV_DESTROY_QP">ibv_destroy_qp</a>, <a href="#IBV_MODIFY_QP">ibv_modify_qp</a>,<br>
	<a href="#IBV_QUERY_QP">ibv_query_qp</a>, <a href="#IBV_POST_SEND">ibv_post_send</a>,
	<a href="#IBV_POST_RECV">ibv_post_recv</a>,<br><a href="#IBV_ATTACH_MCAST">ibv_attach_mcast</a>,
	<a href="#IBV_DETACH_MCAST">ibv_detach_mcast</a>,
	<a href="#IBV_RATE_TO_MULT">ibv_rate_to_mult</a>,
	<a href="#IBV_MULT_TO_RATE">mult_to_ibv_rate</a></p>
</blockquote>
<p align="left"><br><b>AUTHORS</b></p>
<blockquote>
	<p align="left">Dotan Barak &lt;dotanb@mellanox.co.il&gt;<br>Or Gerlitz &lt;ogerlitz@voltaire.com&gt;<br>Stan Smith &lt;<a href="mailto:stan.smith@intel.com">stan.smith@intel.com</a>&gt;</p>
</blockquote>
<p align="left"><a href="#TOP"><font color="#000000">
<span style="font-size: 12pt; ">
&lt;</span></font></a></span><a href="#TOP"><font color="#000000"><b>return-to-top</b><span style="font-size: 12pt; ">&gt;</span></font></a><span style="font-size: 12pt; "></p>
<p align="left">&nbsp;</p>
<h3><a name="IBV_GET_DEVICE_LIST">IBV_GET_DEVICE_LIST</a></h3>
<h3><a name="IBV_FREE_DEVICE_LIST">IBV_FREE_DEVICE_LIST</a></h3>
<hr>
<h4>NAME</h4>
ibv_get_device_list, ibv_free_device_list - get and release list of available 
RDMA devices<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>struct ibv_device **ibv_get_device_list(int </b><i>*num_devices</i><b>);</b>

<b>void ibv_free_device_list(struct ibv_device </b><i>**list</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_get_device_list()</b> returns a NULL-terminated array of RDMA devices 
currently available. The argument <i>num_devices</i> is optional; if not NULL, 
it is set to the number of devices returned in the array.
<p><b>ibv_free_device_list()</b> frees the array of devices <i>list</i> returned 
by <b>ibv_get_device_list()</b>.</p>
<h4>RETURN VALUE</h4>
<b>ibv_get_device_list()</b> returns the array of available RDMA devices, or 
sets <i>errno</i> and returns NULL if the request fails. If no devices are found 
then <i>num_devices</i> is set to 0, and non-NULL is returned.
<p><b>ibv_free_device_list()</b> returns no value.</p>
<h4>ERRORS</h4>
<dl COMPACT>
	<dt><b>EPERM</b> </dt>
	<dd>Permission denied.
	</dd>
	<dt><b>ENOSYS</b> </dt>
	<dd>No kernel support for RDMA.
	</dd>
	<dt><b>ENOMEM</b> </dt>
	<dd>Insufficient memory to complete the operation.</dd>
</dl>
<h4>NOTES</h4>
Client code should open all the devices it intends to use with <b>
ibv_open_device()</b> before calling <b>ibv_free_device_list()</b>. Once it 
frees the array with <b>ibv_free_device_list()</b>, it will be able to use only 
the open devices; pointers to unopened devices will no longer be valid.
<a NAME="lbAH">&nbsp;</a>
<h4>SEE ALSO</h4>
<b><a href="#IBV_GET_DEVICE_NAME">ibv_get_device_name</a></b>, <b>
<a href="#IBV_GET_DEVICE_GUID">ibv_get_device_guid</a></b>, <b>
<a href="#IBV_OPEN_DEVICE">ibv_open_device</a></b><p>&nbsp;</p>
<h3><a name="IBV_GET_DEVICE_GUID">IBV_GET_DEVICE_GUID</a></h3>
<hr>
<h4>NAME</h4>
ibv_get_device_guid - get an RDMA device's GUID
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>uint64_t ibv_get_device_guid(struct ibv_device </b><i>*device</i><b>);</b> </pre>
<h4>DESCRIPTION</h4>
<b>ibv_get_device_name()</b> returns the Global Unique IDentifier (GUID) of the 
RDMA device <i>device</i>.<h4>RETURN VALUE</h4>
<b>ibv_get_device_guid()</b> returns the GUID of the device in network byte 
order. <a NAME="lbAF">&nbsp;</a>
<h4>SEE ALSO</h4>
<b><a href="#IBV_GET_DEVICE_LIST">ibv_get_device_list</a></b>, <b>
<a href="#IBV_GET_DEVICE_NAME">ibv_get_device_name</a></b>, <b>
<a href="#IBV_OPEN_DEVICE">ibv_open_device</a></b><p>&nbsp;</p>
<h3><br>
<a name="IBV_GET_DEVICE_NAME">IBV_GET_DEVICE_NAME</a></h3>
<hr>
<h4>NAME</h4>
ibv_get_device_name - get an RDMA device's name<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>const char *ibv_get_device_name(struct ibv_device </b><i>*device</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_get_device_name()</b> returns a human-readable name associated with the 
RDMA device <i>device</i>.<h4>RETURN VALUE</h4>
<b>ibv_get_device_name()</b> returns a pointer to the device name, or NULL if 
the request fails.<h4>SEE ALSO</h4>
<b><a href="#IBV_GET_DEVICE_LIST">ibv_get_device_list</a></b>, <b>
<a href="#IBV_GET_DEVICE_GUID">ibv_get_device_guid</a></b>, <b>
<a href="#IBV_OPEN_DEVICE">ibv_open_device</a></b><h3>
<br>
<br>
<a name="IBV_OPEN_DEVICE">IBV_OPEN_DEVICE</a></h3>
<h3><a name="IBV_CLOSE_DEVICE">IBV_CLOSE_DEVICE</a></h3>
<hr>
<h4>NAME</h4>
ibv_open_device, ibv_close_device - open and close an RDMA device context
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>struct ibv_context *ibv_open_device(struct ibv_device </b><i>*device</i><b>);</b>

<b>int ibv_close_device(struct ibv_context </b><i>*context</i><b>);</b>
</pre>
<h4>DESCRIPTION</h4>
<b>ibv_open_device()</b> opens the device <i>device</i> and creates a context 
for further use.
<p><b>ibv_close_device()</b> closes the device context <i>context</i>.</p>
<h4>RETURN VALUE</h4>
<b>ibv_open_device()</b> returns a pointer to the allocated device context, or 
NULL if the request fails.
<p><b>ibv_close_device()</b> returns 0 on success, -1 on failure.</p>
<h4>NOTES</h4>
<b>ibv_close_device()</b> does not release all the resources allocated using 
context <i>context</i>. To avoid resource leaks, the user should release all 
associated resources before closing a context.
<h4>SEE ALSO</h4>
<b><a href="#IBV_GET_DEVICE_LIST">ibv_get_device_list</a></b>, <b>
<a href="#IBV_QUERY_DEVICE">ibv_query_device</a></b>, <b>
<a href="#IBV_QUERY_PORT">ibv_query_port</a></b>,
<b><a href="#IBV_QUERY_GID">ibv_query_gid</a></b>, <b><a href="#IBV_QUERY_PKEY">ibv_query_pkey</a></b><p>&nbsp;</p>
<p>&nbsp;</p>
<h3><br>
<a name="IBV_GET_ASYNC_EVENT">IBV_GET_ASYNC_EVENT</a></h3>
<h3>
<br>
<br>
<a name="IBV_ACK_ASYNC_EVENT">IBV_ACK_ASYNC_EVENT</a></h3>
<hr>
<h4>NAME</h4>
ibv_get_async_event, ibv_ack_async_event - get or acknowledge asynchronous 
events <a NAME="lbAC">&nbsp;</a>
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_get_async_event(struct ibv_context </b><i>*context</i><b>,</b>
<b>                        struct ibv_async_event </b><i>*event</i><b>);</b>

<b>void ibv_ack_async_event(struct ibv_async_event </b><i>*event</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_get_async_event()</b> waits for the next async event of the RDMA device 
context <i>context</i> and returns it through the pointer <i>event</i>, which is 
an ibv_async_event struct, as defined in &lt;infiniband/verbs.h&gt;.
<p></p>
<pre>struct ibv_async_event {
union {
struct ibv_cq  *cq;             /* CQ that got the event */
struct ibv_qp  *qp;             /* QP that got the event */
struct ibv_srq *srq;            /* SRQ that got the event */
int             port_num;       /* port number that got the event */
} element;
enum ibv_event_type     event_type;     /* type of the event */
};
</pre>
<p>One member of the element union will be valid, depending on the event_type 
member of the structure. event_type will be one of the following events: </p>
<p><i>QP events:</i> </p>
<dl COMPACT>
	<dt><b>IBV_EVENT_QP_FATAL </b>Error occurred on a QP and it transitioned to 
	error state </dt>
	<dd></dd>
	<dt><b>IBV_EVENT_QP_REQ_ERR </b>Invalid Request Local Work Queue Error </dt>
	<dd></dd>
	<dt><b>IBV_EVENT_QP_ACCESS_ERR </b>Local access violation error </dt>
	<dd></dd>
	<dt><b>IBV_EVENT_COMM_EST </b>Communication was established on a QP </dt>
	<dd></dd>
	<dt><b>IBV_EVENT_SQ_DRAINED </b>Send Queue was drained of outstanding 
	messages in progress </dt>
	<dd></dd>
	<dt><b>IBV_EVENT_PATH_MIG </b>A connection has migrated to the alternate 
	path </dt>
	<dd></dd>
	<dt><b>IBV_EVENT_PATH_MIG_ERR </b>A connection failed to migrate to the 
	alternate path </dt>
	<dd></dd>
	<dt><b>IBV_EVENT_QP_LAST_WQE_REACHED </b>Last WQE Reached on a QP associated 
	with an SRQ </dt>
	<dd></dd>
</dl>
<p><i>CQ events:</i> </p>
<dl COMPACT>
	<dt><b>IBV_EVENT_CQ_ERR </b>CQ is in error (CQ overrun) </dt>
	<dd></dd>
</dl>
<p><i>SRQ events:</i> </p>
<dl COMPACT>
	<dt><b>IBV_EVENT_SRQ_ERR </b>Error occurred on an SRQ </dt>
	<dd></dd>
	<dt><b>IBV_EVENT_SRQ_LIMIT_REACHED </b>SRQ limit was reached </dt>
	<dd></dd>
</dl>
<p><i>Port events:</i> </p>
<dl COMPACT>
	<dt><b>IBV_EVENT_PORT_ACTIVE </b>Link became active on a port </dt>
	<dd></dd>
	<dt><b>IBV_EVENT_PORT_ERR </b>Link became unavailable on a port </dt>
	<dd></dd>
	<dt><b>IBV_EVENT_LID_CHANGE </b>LID was changed on a port </dt>
	<dd></dd>
	<dt><b>IBV_EVENT_PKEY_CHANGE </b>P_Key table was changed on a port </dt>
	<dd></dd>
	<dt><b>IBV_EVENT_SM_CHANGE </b>SM was changed on a port </dt>
	<dd></dd>
	<dt><b>IBV_EVENT_CLIENT_REREGISTER </b>SM sent a CLIENT_REREGISTER request 
	to a port </dt>
	<dd></dd>
</dl>
<p><i>CA events:</i> </p>
<dl COMPACT>
	<dt><b>IBV_EVENT_DEVICE_FATAL </b>CA is in FATAL state </dt>
	<dd></dd>
</dl>
<p><b>ibv_ack_async_event()</b> acknowledge the async event <i>event</i>. </p>
<h4>RETURN VALUE</h4>
<b>ibv_get_async_event()</b> returns 0 on success, and -1 on error.
<p><b>ibv_ack_async_event()</b> returns no value. </p>
<h4>NOTES</h4>
All async events that <b>ibv_get_async_event()</b> returns must be acknowledged 
using <b>ibv_ack_async_event()</b>. To avoid races, destroying an object (CQ, 
SRQ or QP) will wait for all affiliated events for the object to be 
acknowledged; this avoids an application retrieving an affiliated event after 
the corresponding object has already been destroyed.
<p><b>ibv_get_async_event()</b> is a blocking function. If multiple threads call 
this function simultaneously, then when an async event occurs, only one thread 
will receive it, and it is not possible to predict which thread will receive it.
</p>
<h4>EXAMPLES</h4>
The following code example demonstrates one possible way to work with async 
events in non-blocking mode. It performs the following steps:
<p>1. Set the async events queue work mode to be non-blocked <br>
2. Poll the queue until it has an async event <br>
3. Get the async event and ack it </p>
<p></p>
<pre>/* change the blocking mode of the async event queue */
flags = fcntl(ctx-&gt;async_fd, F_GETFL);
rc = fcntl(ctx-&gt;async_fd, F_SETFL, flags | O_NONBLOCK);
if (rc &lt; 0) {
        fprintf(stderr, &quot;Failed to change file descriptor of async event queue\n&quot;);
        return 1;
}

/*
 * poll the queue until it has an event and sleep ms_timeout
 * milliseconds between any iteration
 */
my_pollfd.fd      = ctx-&gt;async_fd;
my_pollfd.events  = POLLIN;
my_pollfd.revents = 0;

do {
        rc = poll(&amp;my_pollfd, 1, ms_timeout);
} while (rc == 0);
if (rc &lt; 0) {
        fprintf(stderr, &quot;poll failed\n&quot;);
        return 1;
}

/* Get the async event */
if (ibv_get_async_event(ctx, &amp;async_event)) {
        fprintf(stderr, &quot;Failed to get async_event\n&quot;);
        return 1;
}

/* Ack the event */
ibv_ack_async_event(&amp;async_event);

</pre>
<h4>SEE ALSO</h4>
<b><a href="#IBV_OPEN_DEVICE">ibv_open_device</a></b>
<p>&nbsp;</p>
<h3><br>
<a name="IBV_QUERY_DEVICE">IBV_QUERY_DEVICE</a></h3>
<hr>
<h4>NAME</h4>
ibv_query_device - query an RDMA device's attributes <a NAME="lbAC">&nbsp;</a>
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_query_device(struct ibv_context </b><i>*context,</i>
<b>                     struct ibv_device_attr </b><i>*device_attr</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_query_device()</b> returns the attributes of the device with context <i>
context</i>. The argument <i>device_attr</i> is a pointer to an ibv_device_attr 
struct, as defined in &lt;infiniband/verbs.h&gt;.
<p></p>
<pre>struct ibv_device_attr {
char                    fw_ver[64];             /* FW version */
uint64_t                node_guid;              /* Node GUID (in network byte order) */
uint64_t                sys_image_guid;         /* System image GUID (in network byte order) */
uint64_t                max_mr_size;            /* Largest contiguous block that can be registered */
uint64_t                page_size_cap;          /* Supported memory shift sizes */
uint32_t                vendor_id;              /* Vendor ID, per IEEE */
uint32_t                vendor_part_id;         /* Vendor supplied part ID */
uint32_t                hw_ver;                 /* Hardware version */
int                     max_qp;                 /* Maximum number of supported QPs */
int                     max_qp_wr;              /* Maximum number of outstanding WR on any work queue */
int                     device_cap_flags;       /* HCA capabilities mask */
int                     max_sge;                /* Maximum number of s/g per WR for non-RD QPs */
int                     max_sge_rd;             /* Maximum number of s/g per WR for RD QPs */
int                     max_cq;                 /* Maximum number of supported CQs */
int                     max_cqe;                /* Maximum number of CQE capacity per CQ */
int                     max_mr;                 /* Maximum number of supported MRs */
int                     max_pd;                 /* Maximum number of supported PDs */
int                     max_qp_rd_atom;         /* Maximum number of RDMA Read &amp; Atomic operations that can be outstanding per QP */
int                     max_ee_rd_atom;         /* Maximum number of RDMA Read &amp; Atomic operations that can be outstanding per EEC */
int                     max_res_rd_atom;        /* Maximum number of resources used for RDMA Read &amp; Atomic operations by this HCA as the Target */
int                     max_qp_init_rd_atom;    /* Maximum depth per QP for initiation of RDMA Read &amp; Atomic operations */ 
int                     max_ee_init_rd_atom;    /* Maximum depth per EEC for initiation of RDMA Read &amp; Atomic operations */
enum ibv_atomic_cap     atomic_cap;             /* Atomic operations support level */
int                     max_ee;                 /* Maximum number of supported EE contexts */
int                     max_rdd;                /* Maximum number of supported RD domains */
int                     max_mw;                 /* Maximum number of supported MWs */
int                     max_raw_ipv6_qp;        /* Maximum number of supported raw IPv6 datagram QPs */
int                     max_raw_ethy_qp;        /* Maximum number of supported Ethertype datagram QPs */
int                     max_mcast_grp;          /* Maximum number of supported multicast groups */
int                     max_mcast_qp_attach;    /* Maximum number of QPs per multicast group which can be attached */
int                     max_total_mcast_qp_attach;/* Maximum number of QPs which can be attached to multicast groups */
int                     max_ah;                 /* Maximum number of supported address handles */
int                     max_fmr;                /* Maximum number of supported FMRs */
int                     max_map_per_fmr;        /* Maximum number of (re)maps per FMR before an unmap operation in required */
int                     max_srq;                /* Maximum number of supported SRQs */
int                     max_srq_wr;             /* Maximum number of WRs per SRQ */
int                     max_srq_sge;            /* Maximum number of s/g per SRQ */
uint16_t                max_pkeys;              /* Maximum number of partitions */
uint8_t                 local_ca_ack_delay;     /* Local CA ack delay */
uint8_t                 phys_port_cnt;          /* Number of physical ports */
};</pre>
<h4>RETURN VALUE</h4>
<b>ibv_query_device()</b> returns 0 on success, or the value of errno on failure 
(which indicates the failure reason). <a NAME="lbAF">&nbsp;</a>
<h4>NOTES</h4>
The maximum values returned by this function are the upper limits of supported 
resources by the device. However, it may not be possible to use these maximum 
values, since the actual number of any resource that can be created may be 
limited by the machine configuration, the amount of host memory, user 
permissions, and the amount of resources already in use by other 
users/processes.<h4>SEE ALSO</h4>
<b><a href="#IBV_OPEN_DEVICE">ibv_open_device</a></b>, <b>
<a href="#IBV_QUERY_PORT">ibv_query_port</a></b>, <b><a href="#IBV_QUERY_PKEY">ibv_query_pkey</a></b>,
<b><a href="#IBV_QUERY_GID">ibv_query_gid</a></b>
<p>&nbsp;</p>
<h3><br>
<a name="IBV_QUERY_GID">IBV_QUERY_GID</a></h3>
<hr>
<h4>NAME</h4>
ibv_query_gid - query an InfiniBand port's GID table<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_query_gid(struct ibv_context </b><i>*context</i><b>, uint8_t </b><i>port_num</i><b>,</b>
<b>                  int </b><i>index</i><b>, union ibv_gid </b><i>*gid</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_query_gid()</b> returns the GID value in entry <i>index</i> of port <i>
port_num</i> for device context <i>context</i> through the pointer <i>gid</i>.<h4>
RETURN VALUE</h4>
<b>ibv_query_gid()</b> returns 0 on success, and -1 on error.<h4>SEE ALSO</h4>
<b><a href="#IBV_OPEN_DEVICE">ibv_open_device</a></b>, <b>
<a href="#IBV_QUERY_DEVICE">ibv_query_device</a></b>, <b>
<a href="#IBV_QUERY_PORT">ibv_query_port</a></b>,
<b><a href="#IBV_QUERY_PKEY">ibv_query_pkey</a></b>
<p>&nbsp;</p>
<h3><br>
<a name="IBV_QUERY_PKEY">IBV_QUERY_PKEY</a></h3>
<hr>
<h4>NAME</h4>
ibv_query_pkey - query an InfiniBand port's P_Key table
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_query_pkey(struct ibv_context </b><i>*context</i><b>, uint8_t </b><i>port_num</i><b>,</b>
<b>                   int </b><i>index</i><b>, uint16_t </b><i>*pkey</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_query_pkey()</b> returns the P_Key value (in network byte order) in entry
<i>index</i> of port <i>port_num</i> for device context <i>context</i> through 
the pointer <i>pkey</i>.<h4>RETURN VALUE</h4>
<b>ibv_query_pkey()</b> returns 0 on success, and -1 on error.
<h4>SEE ALSO</h4>
<b><a href="#IBV_OPEN_DEVICE">ibv_open_device</a></b>, <b>
<a href="#IBV_QUERY_DEVICE">ibv_query_device</a></b>, <b>
<a href="#IBV_QUERY_PORT">ibv_query_port</a></b>,
<b><a href="#IBV_QUERY_GID">ibv_query_gid</a></b><p>&nbsp;</p>
<h3><br>
<a name="IBV_QUERY_PORT">IBV_QUERY_PORT</a></h3>
<hr>
<h4>NAME</h4>
ibv_query_port - query an RDMA port's attributes
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_query_port(struct ibv_context </b><i>*context</i><b>, uint8_t </b><i>port_num</i><b>,</b>
<b>                   struct ibv_port_attr </b><i>*port_attr</i><b>);</b> </pre>
<h4>DESCRIPTION</h4>
<b>ibv_query_port()</b> returns the attributes of port <i>port_num</i> for 
device context <i>context</i> through the pointer <i>port_attr</i>. The argument
<i>port_attr</i> is an ibv_port_attr struct, as defined in &lt;infiniband/verbs.h&gt;.
<p></p>
<pre>struct ibv_port_attr {
enum ibv_port_state     state;          /* Logical port state */
enum ibv_mtu            max_mtu;        /* Max MTU supported by port */
enum ibv_mtu            active_mtu;     /* Actual MTU */
int                     gid_tbl_len;    /* Length of source GID table */
uint32_t                port_cap_flags; /* Port capabilities */
uint32_t                max_msg_sz;     /* Maximum message size */
uint32_t                bad_pkey_cntr;  /* Bad P_Key counter */
uint32_t                qkey_viol_cntr; /* Q_Key violation counter */
uint16_t                pkey_tbl_len;   /* Length of partition table */
uint16_t                lid;            /* Base port LID */
uint16_t                sm_lid;         /* SM LID */
uint8_t                 lmc;            /* LMC of LID */
uint8_t                 max_vl_num;     /* Maximum number of VLs */
uint8_t                 sm_sl;          /* SM service level */
uint8_t                 subnet_timeout; /* Subnet propagation delay */
uint8_t                 init_type_reply;/* Type of initialization performed by SM */
uint8_t                 active_width;   /* Currently active link width */
uint8_t                 active_speed;   /* Currently active link speed */
uint8_t                 phys_state;     /* Physical port state */
};</pre>
<h4>RETURN VALUE</h4>
<b>ibv_query_port()</b> returns 0 on success, or the value of errno on failure 
(which indicates the failure reason).
<h4>SEE ALSO</h4>
<b><a href="#IBV_CREATE_QP">ibv_create_qp</a></b>, <b><a href="#IBV_DESTROY_QP">ibv_destroy_qp</a></b>, <b>
<a href="#IBV_QUERY_QP">ibv_query_qp</a></b>, <b>
<a href="#IBV_CREATE_AH">ibv_create_ah</a></b><p>&nbsp;</p>
<p>&nbsp;</p>
<h3><a name="IBV_ALLOC_PD">IBV_ALLOC_PD</a></h3>
<h3><a name="IBV_DEALLOC_PD">IBV_DEALLOC_PD</a></h3>
<hr>
<h4>NAME</h4>
ibv_alloc_pd, ibv_dealloc_pd - allocate or deallocate a protection domain (PDs)<h4>
SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>struct ibv_pd *ibv_alloc_pd(struct ibv_context </b><i>*context</i><b>);</b>

<b>int ibv_dealloc_pd(struct ibv_pd </b><i>*pd</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_alloc_pd()</b> allocates a PD for the RDMA device context <i>context</i>.

<p><b>ibv_dealloc_pd()</b> deallocates the PD <i>pd</i>.</p>
<h4>RETURN VALUE</h4>
<b>ibv_alloc_pd()</b> returns a pointer to the allocated PD, or NULL if the 
request fails.
<p><b>ibv_dealloc_pd()</b> returns 0 on success, or the value of errno on 
failure (which indicates the failure reason). <a NAME="lbAF">&nbsp;</a> </p>
<h4>NOTES</h4>
<b>ibv_dealloc_pd()</b> may fail if any other resource is still associated with 
the PD being freed. <a NAME="lbAG">&nbsp;</a>
<h4>SEE ALSO</h4>
<b><a href="#IBV_REG_MR">ibv_reg_mr</a></b>, <b><a href="#IBV_CREATE_SRQ">ibv_create_srq</a></b>, <b>
<a href="#IBV_CREATE_QP">ibv_create_qp</a></b>, <b>
<a href="#IBV_CREATE_AH">ibv_create_ah</a></b>, <b>
<a href="#IBV_CREATE_AH_FROM_WC">ibv_create_ah_from_wc</a></b><p>&nbsp;</p>
<p>&nbsp;</p>
<h3><a name="IBV_REG_MR">IBV_REG_MR</a></h3>
<h3><a name="IBV_DEREG_MR">IBV_DEREG_MR</a></h3>
<hr>
<h4>NAME</h4>
ibv_reg_mr, ibv_dereg_mr - register or deregister a memory region (MR)
<a NAME="lbAC">&nbsp;</a>
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>struct ibv_mr *ibv_reg_mr(struct ibv_pd </b><i>*pd</i><b>, void </b><i>*addr</i><b>,</b>
<b>                          size_t </b><i>length</i><b>, int </b><i>access</i><b>);</b>

<b>int ibv_dereg_mr(struct ibv_mr </b><i>*mr</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_reg_mr()</b> registers a memory region (MR) associated with the 
protection domain <i>pd</i>. The MR's starting address is <i>addr</i> and its 
size is <i>length</i>. The argument <i>access</i> describes the desired memory 
protection attributes; it is either 0 or the bitwise OR of one or more of the 
following flags:
<p></p>
<dl COMPACT>
	<dt><b>IBV_ACCESS_LOCAL_WRITE </b>Enable Local Write Access </dt>
	<dd></dd>
	<dt><b>IBV_ACCESS_REMOTE_WRITE </b>Enable Remote Write Access </dt>
	<dd></dd>
	<dt><b>IBV_ACCESS_REMOTE_READ</b> Enable Remote Read Access </dt>
	<dd></dd>
	<dt><b>IBV_ACCESS_REMOTE_ATOMIC</b> Enable Remote Atomic Operation Access 
	(if supported) </dt>
	<dd></dd>
	<dt><b>IBV_ACCESS_MW_BIND</b> Enable Memory Window Binding </dt>
	<dd></dd>
</dl>
<p>If <b>IBV_ACCESS_REMOTE_WRITE</b> or <b>IBV_ACCESS_REMOTE_ATOMIC</b> is set, 
then <b>IBV_ACCESS_LOCAL_WRITE</b> must be set too. </p>
<p>Local read access is always enabled for the MR. </p>
<p><b>ibv_dereg_mr()</b> deregisters the MR <i>mr</i>.</p>
<h4>RETURN VALUE</h4>
<b>ibv_reg_mr()</b> returns a pointer to the registered MR, or NULL if the 
request fails. The local key (<b>L_Key</b>) field <b>lkey</b> is used as the 
lkey field of struct ibv_sge when posting buffers with ibv_post_* verbs, and the 
the remote key (<b>R_Key</b>) field <b>rkey</b> is used by remote processes to 
perform Atomic and RDMA operations. The remote process places this <b>rkey</b> 
as the rkey field of struct ibv_send_wr passed to the ibv_post_send function.
<p><b>ibv_dereg_mr()</b> returns 0 on success, or the value of errno on failure 
(which indicates the failure reason).</p>
<h4>NOTES</h4>
<b>ibv_dereg_mr()</b> fails if any memory window is still bound to this MR.<h4>
SEE ALSO</h4>
<b><a href="#IBV_ALLOC_PD">ibv_alloc_pd</a></b>, <b><a href="#IBV_POST_SEND">ibv_post_send</a></b>, <b>
<a href="#IBV_POST_RECV">ibv_post_recv</a></b>, <b>
<a href="#IBV_POST_SRQ_RECV">ibv_post_srq_recv</a></b>
<p>&nbsp;</p>
<h3><br>
<a name="IBV_CREATE_AH">IBV_CREATE_AH</a></h3>
<h3><br>
<a name="IBV_DESTROY_AH">IBV_DESTROY_AH</a></h3>
<hr>
<h4>NAME</h4>
ibv_create_ah, ibv_destroy_ah - create or destroy an address handle (AH)<h4>
SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>struct ibv_ah *ibv_create_ah(struct ibv_pd </b><i>*pd</i><b>,</b>
<b>                             struct ibv_ah_attr </b><i>*attr</i><b>);</b>

<b>int ibv_destroy_ah(struct ibv_ah </b><i>*ah</i><b>);</b> </pre>
<h4>DESCRIPTION</h4>
<b>ibv_create_ah()</b> creates an address handle (AH) associated with the 
protection domain <i>pd</i>. The argument <i>attr</i> is an ibv_ah_attr struct, 
as defined in &lt;infiniband/verbs.h&gt;.
<p></p>
<pre>struct ibv_ah_attr {
struct ibv_global_route grh;            /* Global Routing Header (GRH) attributes */
uint16_t                dlid;           /* Destination LID */
uint8_t                 sl;             /* Service Level */
uint8_t                 src_path_bits;  /* Source path bits */
uint8_t                 static_rate;    /* Maximum static rate */
uint8_t                 is_global;      /* GRH attributes are valid */
uint8_t                 port_num;       /* Physical port number */
};

struct ibv_global_route {
union ibv_gid           dgid;           /* Destination GID or MGID */
uint32_t                flow_label;     /* Flow label */
uint8_t                 sgid_index;     /* Source GID index */
uint8_t                 hop_limit;      /* Hop limit */
uint8_t                 traffic_class;  /* Traffic class */
};
</pre>
<p></p>
<p><b>ibv_destroy_ah()</b> destroys the AH <i>ah</i>. </p>
<h4>RETURN VALUE</h4>
<b>ibv_create_ah()</b> returns a pointer to the created AH, or NULL if the 
request fails.
<p><b>ibv_destroy_ah()</b> returns 0 on success, or the value of errno on 
failure (which indicates the failure reason).</p>
<h4>SEE ALSO</h4>
<b><a href="#IBV_ALLOC_PD">ibv_alloc_pd</a></b>, <b>
<a href="#IBV_INIT_AH_FROM_WC">ibv_init_ah_from_wc</a></b>, <b>
<a href="#IBV_CREATE_AH_FROM_WC">ibv_create_ah_from_wc</a></b>
<p align="left">&nbsp;</p>
<h3><br>
<a name="IBV_CREATE_AH_FROM_WC">IBV_CREATE_AH_FROM_WC</a></h3>
<h3><br>
<a name="IBV_INIT_AH_FROM_WC">IBV_INIT_AH_FROM_WC</a></h3>
<hr>
<h4>NAME</h4>
ibv_init_ah_from_wc, ibv_create_ah_from_wc - initialize or create an address 
handle (AH) from a work completion <a NAME="lbAC">&nbsp;</a>
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_init_ah_from_wc(struct ibv_context </b><i>*context</i><b>, uint8_t </b><i>port_num</i><b>,</b>
<b>                        struct ibv_wc </b><i>*wc</i><b>, struct ibv_grh </b><i>*grh</i><b>,</b>
<b>                        struct ibv_ah_attr </b><i>*ah_attr</i><b>);</b>

<b>struct ibv_ah *ibv_create_ah_from_wc(struct ibv_pd </b><i>*pd</i><b>,</b>
<b>                                     struct ibv_wc </b><i>*wc</i><b>,</b>
<b>                                     struct ibv_grh </b><i>*grh</i><b>,</b>
<b>                                     uint8_t </b><i>port_num</i><b>);</b>
</pre>
<h4>DESCRIPTION</h4>
<b>ibv_init_ah_from_wc()</b> initializes the address handle (AH) attribute 
structure <i>ah_attr</i> for the RDMA device context <i>context</i> using the 
port number <i>port_num</i>, using attributes from the work completion <i>wc</i> 
and the Global Routing Header (GRH) structure <i>grh</i>.

<p><b>ibv_create_ah_from_wc()</b> creates an AH associated with the protection 
domain <i>pd</i> using the port number <i>port_num</i>, using attributes from 
the work completion <i>wc</i> and the Global Routing Header (GRH) structure <i>
grh</i>. </p>
<h4>RETURN VALUE</h4>
<b>ibv_init_ah_from_wc()</b> returns 0 on success, and -1 on error.
<p><b>ibv_create_ah_from_wc()</b> returns a pointer to the created AH, or NULL 
if the request fails. <a NAME="lbAF">&nbsp;</a> </p>
<h4>NOTES</h4>
The filled structure <i>ah_attr</i> returned from <b>ibv_init_ah_from_wc()</b> 
can be used to create a new AH using <b>ibv_create_ah()</b>.
<h4>SEE ALSO</h4>
<b><a href="#IBV_OPEN_DEVICE">ibv_open_device</a></b>, <b>
<a href="#IBV_ALLOC_PD">ibv_alloc_pd</a></b>, <b><a href="#IBV_CREATE_AH">ibv_create_ah</a></b>, <b>
<a href="#IBV_DESTROY_AH">ibv_destroy_ah</a></b>, <b><a href="#IBV_POLL_CQ">ibv_poll_cq</a></b><p>&nbsp;</p>
<h3><a name="IBV_CREATE_COMP_CHANNEL">IBV_CREATE_COMP_CHANNEL</a></h3>
<h3><a name="IBV_DESTROY_COMP_CHANNEL">IBV_DESTROY_COMP_CHANNEL</a></h3>
<hr>
<h4>NAME</h4>
ibv_create_comp_channel, ibv_destroy_comp_channel - create or destroy a 
completion event channel<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>struct ibv_comp_channel *ibv_create_comp_channel(struct ibv_context</b>
<b>                                                 </b><i>*context</i><b>);</b>

<b>int ibv_destroy_comp_channel(struct ibv_comp_channel </b><i>*channel</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_create_comp_channel()</b> creates a completion event channel for the RDMA 
device context <i>context</i>.

<p><b>ibv_destroy_comp_channel()</b> destroys the completion event channel <i>
channel</i>. </p>
<h4>RETURN VALUE</h4>
<b>ibv_create_comp_channel()</b> returns a pointer to the created completion 
event channel, or NULL if the request fails.
<p><b>ibv_destroy_comp_channel()</b> returns 0 on success, or the value of errno 
on failure (which indicates the failure reason).</p>
<h4>NOTES</h4>
A &quot;completion channel&quot; is an abstraction introduced by libibverbs that does not 
exist in the InfiniBand Architecture verbs specification or RDMA Protocol Verbs 
Specification. A completion channel is essentially file descriptor that is used 
to deliver completion notifications to a userspace process. When a completion 
event is generated for a completion queue (CQ), the event is delivered via the 
completion channel attached to that CQ. This may be useful to steer completion 
events to different threads by using multiple completion channels.
<p><b>ibv_destroy_comp_channel()</b> fails if any CQs are still associated with 
the completion event channel being destroyed.</p>
<h4>SEE ALSO</h4>
<b><a href="#IBV_OPEN_DEVICE">ibv_open_device</a></b>, <b>
<a href="#IBV_CREATE_CQ">ibv_create_cq</a></b>, <b><a href="#IBV_GET_CQ_EVENT">ibv_get_cq_event</a></b><p>&nbsp;</p>
<h3><a name="IBV_CREATE_CQ">IBV_CREATE_CQ</a></h3>
<h3><a name="IBV_DESTROY_CQ">IBV_DESTROY_CQ</a></h3>
<hr>
<h4>NAME</h4>
ibv_create_cq, ibv_destroy_cq - create or destroy a completion queue (CQ)
<a NAME="lbAC">&nbsp;</a>
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>struct ibv_cq *ibv_create_cq(struct ibv_context </b><i>*context</i><b>, int </b><i>cqe</i><b>,</b>
<b>                             void </b><i>*cq_context</i><b>,</b>
<b>                             struct ibv_comp_channel </b><i>*channel</i><b>,</b>
<b>                             int </b><i>comp_vector</i><b>);</b>

<b>int ibv_destroy_cq(struct ibv_cq </b><i>*cq</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_create_cq()</b> creates a completion queue (CQ) with at least <i>cqe</i> 
entries for the RDMA device context <i>context</i>. The pointer <i>cq_context</i> 
will be used to set user context pointer of the CQ structure. The argument <i>
channel</i> is optional; if not NULL, the completion channel <i>channel</i> will 
be used to return completion events. The CQ will use the completion vector <i>
comp_vector</i> for signaling completion events; it must be at least zero and 
less than <i>context</i>-&gt;num_comp_vectors.

<p><b>ibv_destroy_cq()</b> destroys the CQ <i>cq</i>.</p>
<h4>RETURN VALUE</h4>
<b>ibv_create_cq()</b> returns a pointer to the CQ, or NULL if the request 
fails.
<p><b>ibv_destroy_cq()</b> returns 0 on success, or the value of errno on 
failure (which indicates the failure reason).</p>
<h4>NOTES</h4>
<b>ibv_create_cq()</b> may create a CQ with size greater than or equal to the 
requested size. Check the cqe attribute in the returned CQ for the actual size.
<p><b>ibv_destroy_cq()</b> fails if any queue pair is still associated with this 
CQ. </p>
<h4>SEE ALSO</h4>
<b><a href="#IBV_RESIZE_CQ">ibv_resize_cq</a></b>, <b>
<a href="#IBV_REQ_NOTIFY_CQ">ibv_req_notify_cq</a></b>, <b>
<a href="#IBV_ACK_CQ_EVENTS">ibv_ack_cq_events</a></b>,
<b><a href="#IBV_CREATE_QP">ibv_create_qp</a></b><p>&nbsp;</p>
<h3><a name="IBV_POLL_CQ">IBV_POLL_CQ</a></h3>
<hr>
<h4>NAME</h4>
ibv_poll_cq - poll a completion queue (CQ) <a NAME="lbAC">&nbsp;</a>
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_poll_cq(struct ibv_cq </b><i>*cq</i><b>, int </b><i>num_entries</i><b>,</b>
<b>                struct ibv_wc </b><i>*wc</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_poll_cq()</b> polls the CQ <i>cq</i> for work completions and returns the 
first <i>num_entries</i> (or all available completions if the CQ contains fewer 
than this number) in the array <i>wc</i>. The argument <i>wc</i> is a pointer to 
an array of ibv_wc structs, as defined in &lt;infiniband/verbs.h&gt;.
<p></p>
<pre>struct ibv_wc {
uint64_t                wr_id;          /* ID of the completed Work Request (WR) */
enum ibv_wc_status      status;         /* Status of the operation */
enum ibv_wc_opcode      opcode;         /* Operation type specified in the completed WR */
uint32_t                vendor_err;     /* Vendor error syndrome */
uint32_t                byte_len;       /* Number of bytes transferred */
uint32_t                imm_data;       /* Immediate data (in network byte order) */
uint32_t                qp_num;         /* Local QP number of completed WR */
uint32_t                src_qp;         /* Source QP number (remote QP number) of completed WR (valid only for UD QPs) */
int                     wc_flags;       /* Flags of the completed WR */
uint16_t                pkey_index;     /* P_Key index (valid only for GSI QPs) */
uint16_t                slid;           /* Source LID */
uint8_t                 sl;             /* Service Level */
uint8_t                 dlid_path_bits; /* DLID path bits (not applicable for multicast messages) */
};

</pre>
<p>The attribute wc_flags describes the properties of the work completion. It is 
either 0 or the bitwise OR of one or more of the following flags: </p>
<p></p>
<dl COMPACT>
	<dt><b>IBV_WC_GRH </b>GRH is present (valid only for UD QPs) </dt>
	<dd></dd>
	<dt><b>IBV_WC_WITH_IMM </b>Immediate data value is valid </dt>
	<dd></dd>
</dl>
<p>Not all <i>wc</i> attributes are always valid. If the completion status is 
other than <b>IBV_WC_SUCCESS</b>, only the following attributes are valid: wr_id, 
status, qp_num, and vendor_err.</p>
<h4>RETURN VALUE</h4>
On success, <b>ibv_poll_cq()</b> returns a non-negative value equal to the 
number of completions found. On failure, a negative value is returned.<h4>NOTES</h4>
<p>Each polled completion is removed from the CQ and cannot be returned to it.
</p>
<p>The user should consume work completions at a rate that prevents CQ overrun 
from occurrence. In case of a CQ overrun, the async event <b>IBV_EVENT_CQ_ERR</b> 
will be triggered, and the CQ cannot be used. </p>
<h4>SEE ALSO</h4>
<b><a href="#IBV_POST_SEND">ibv_post_send</a></b>, <b><a href="#IBV_POST_RECV">ibv_post_recv</a></b><p>&nbsp;</p>
<h3><a name="IBV_RESIZE_CQ">IBV_RESIZE_CQ</a></h3>
<hr>
<h4>NAME</h4>
ibv_resize_cq - resize a completion queue (CQ)<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_resize_cq(struct ibv_cq </b><i>*cq</i><b>, int </b><i>cqe</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_resize_cq()</b> resizes the completion queue (CQ) <i>cq</i> to have at 
least <i>cqe</i> entries. <i>cqe</i> must be at least the number of unpolled 
entries in the CQ <i>cq</i>. If <i>cqe</i> is a valid value less than the 
current CQ size, <b>ibv_resize_cq()</b> may not do anything, since this function 
is only guaranteed to resize the CQ to a size at least as big as the requested 
size.<h4>RETURN VALUE</h4>
<b>ibv_resize_cq()</b> returns 0 on success, or the value of errno on failure 
(which indicates the failure reason).<h4>NOTES</h4>
<b>ibv_resize_cq()</b> may assign a CQ size greater than or equal to the 
requested size. The cqe member of <i>cq</i> will be updated to the actual size.<h4>
SEE ALSO</h4>
<a href="#IBV_CREATE_CQ">
<b>ibv_create_cq</b> </a> <b><a href="#IBV_DESTROY_CQ">ibv_destroy_cq</a></b>
<p>&nbsp;</p>
<h3><br>
<a name="IBV_GET_CQ_EVENT">IBV_GET_CQ_EVENT</a></h3>
<h3><br>
<a name="IBV_ACK_CQ_EVENTS">IBV_ACK_CQ_EVENTS</a></h3>
<hr>
<h4>NAME</h4>
ibv_get_cq_event, ibv_ack_cq_events - get and acknowledge completion queue (CQ) 
events
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_get_cq_event(struct ibv_comp_channel </b><i>*channel</i><b>,</b>
<b>                     struct ibv_cq </b><i>**cq</i><b>, void </b><i>**cq_context</i><b>);</b>

<b>void ibv_ack_cq_events(struct ibv_cq </b><i>*cq</i><b>, unsigned int </b><i>nevents</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_get_cq_event()</b> waits for the next completion event in the completion 
event channel <i>channel</i>. Fills the arguments <i>cq</i> with the CQ that got 
the event and <i>cq_context</i> with the CQ's context.
<p><b>ibv_ack_cq_events()</b> acknowledges <i>nevents</i> events on the CQ <i>cq</i>.</p>
<h4>RETURN VALUE</h4>
<b>ibv_get_cq_event()</b> returns 0 on success, and -1 on error.
<p><b>ibv_ack_cq_events()</b> returns no value. <a NAME="lbAF">&nbsp;</a> </p>
<h4>NOTES</h4>
All completion events that <b>ibv_get_cq_event()</b> returns must be 
acknowledged using <b>ibv_ack_cq_events()</b>. To avoid races, destroying a CQ 
will wait for all completion events to be acknowledged; this guarantees a 
one-to-one correspondence between acks and successful gets.
<p>Calling <b>ibv_ack_cq_events()</b> may be relatively expensive in the 
datapath, since it must take a mutex. Therefore it may be better to amortize 
this cost by keeping a count of the number of events needing acknowledgement and 
acking several completion events in one call to <b>ibv_ack_cq_events()</b>.</p>
<h4>EXAMPLES</h4>
The following code example demonstrates one possible way to work with completion 
events. It performs the following steps:
<p>Stage I: Preparation <br>
1. Creates a CQ <br>
2. Requests for notification upon a new (first) completion event </p>
<p>Stage II: Completion Handling Routine <br>
3. Wait for the completion event and ack it <br>
4. Request for notification upon the next completion event <br>
5. Empty the CQ </p>
<p>Note that an extra event may be triggered without having a corresponding 
completion entry in the CQ. This occurs if a completion entry is added to the CQ 
between Step 4 and Step 5, and the CQ is then emptied (polled) in Step 5. </p>
<p></p>
<pre>cq = ibv_create_cq(ctx, 1, ev_ctx, channel, 0);
if (!cq) {
        fprintf(stderr, &quot;Failed to create CQ\n&quot;);
        return 1;
}

/* Request notification before any completion can be created */
if (ibv_req_notify_cq(cq, 0)) {
        fprintf(stderr, &quot;Couldn't request CQ notification\n&quot;);
        return 1;
}

.
.
.

/* Wait for the completion event */
if (ibv_get_cq_event(channel, &amp;ev_cq, &amp;ev_ctx)) {
        fprintf(stderr, &quot;Failed to get cq_event\n&quot;);
        return 1;
}

/* Ack the event */
ibv_ack_cq_events(ev_cq, 1);

/* Request notification upon the next completion event */
if (ibv_req_notify_cq(ev_cq, 0)) {
        fprintf(stderr, &quot;Couldn't request CQ notification\n&quot;);
        return 1;
}

/* Empty the CQ: poll all of the completions from the CQ (if any exist) */
do {
        ne = ibv_poll_cq(cq, 1, &amp;wc);
        if (ne &lt; 0) {
                fprintf(stderr, &quot;Failed to poll completions from the CQ\n&quot;);
                return 1;
        }

        /* there may be an extra event with no completion in the CQ */
        if (ne == 0)
                continue;

        if (wc.status != IBV_WC_SUCCESS) {
                fprintf(stderr, &quot;Completion with status 0x%x was found\n&quot;, wc.status);
                return 1;
        }
} while (ne);
</pre>
<p>The following code example demonstrates one possible way to work with 
completion events in non-blocking mode. It performs the following steps: </p>
<p>1. Set the completion event channel to be non-blocked <br>
2. Poll the channel until there it has a completion event <br>
3. Get the completion event and ack it </p>
<p></p>
<pre>/* change the blocking mode of the completion channel */
flags = fcntl(channel-&gt;fd, F_GETFL);
rc = fcntl(channel-&gt;fd, F_SETFL, flags | O_NONBLOCK);
if (rc &lt; 0) {
        fprintf(stderr, &quot;Failed to change file descriptor of completion event channel\n&quot;);
        return 1;
}


/*
 * poll the channel until it has an event and sleep ms_timeout
 * milliseconds between any iteration
 */
my_pollfd.fd      = channel-&gt;fd;
my_pollfd.events  = POLLIN;
my_pollfd.revents = 0;

do {
        rc = poll(&amp;my_pollfd, 1, ms_timeout);
} while (rc == 0);
if (rc &lt; 0) {
        fprintf(stderr, &quot;poll failed\n&quot;);
        return 1;
}
ev_cq = cq;

/* Wait for the completion event */
if (ibv_get_cq_event(channel, &amp;ev_cq, &amp;ev_ctx)) {
        fprintf(stderr, &quot;Failed to get cq_event\n&quot;);
        return 1;
}

/* Ack the event */
ibv_ack_cq_events(ev_cq, 1);</pre>
<h4>SEE ALSO</h4>
<b><a href="#IBV_CREATE_COMP_CHANNEL">ibv_create_comp_channel</a></b>, <b>
<a href="#IBV_CREATE_CQ">ibv_create_cq</a></b>, <b><a href="#IBV_REQ_NOTIFY_CQ">ibv_req_notify_cq</a></b>,
<b><a href="#IBV_POLL_CQ">ibv_poll_cq</a></b><p>&nbsp;</p>
<h3><br>
<a name="IBV_REQ_NOTIFY_CQ">IBV_REQ_NOTIFY_CQ</a></h3>
<hr>
<h4>NAME</h4>
ibv_req_notify_cq - request completion notification on a completion queue (CQ)<h4>
SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_req_notify_cq(struct ibv_cq </b><i>*cq</i><b>, int </b><i>solicited_only</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_req_notify_cq()</b> requests a completion notification on the completion 
queue (CQ) <i>cq</i>.

<p>Upon the addition of a new CQ entry (CQE) to <i>cq</i>, a completion event 
will be added to the completion channel associated with the CQ. If the argument
<i>solicited_only</i> is zero, a completion event is generated for any new CQE. 
If <i>solicited_only</i> is non-zero, an event is only generated for a new CQE 
with that is considered &quot;solicited.&quot; A CQE is solicited if it is a receive 
completion for a message with the Solicited Event header bit set, or if the 
status is not successful. All other successful receive completions, or any 
successful send completion is unsolicited. </p>
<h4>RETURN VALUE</h4>
<b>ibv_req_notify_cq()</b> returns 0 on success, or the value of errno on 
failure (which indicates the failure reason).<h4>NOTES</h4>
The request for notification is &quot;one shot.&quot; Only one completion event will be 
generated for each call to <b>ibv_req_notify_cq()</b>. <a NAME="lbAG">&nbsp;</a>
<h4>SEE ALSO</h4>
<b><a href="#IBV_CREATE_COMP_CHANNEL">ibv_create_comp_channel</a></b>, <b>
<a href="#IBV_CREATE_CQ">ibv_create_cq</a></b>, <b><a href="#IBV_GET_CQ_EVENT">ibv_get_cq_event</a></b><p>&nbsp;</p>
<p align="left">&nbsp;</p>
<h3><br>
<a name="IBV_CREATE_SRQ">IBV_CREATE_SRQ</a></h3>
<h3><br>
<a name="IBV_CREATE_XRC_SRQ">IBV_CREATE_XRC_SRQ</a></h3>
<h3><br>
<a name="IBV_DESTROY_SRQ">IBV_DESTROY_SRQ</a></h3>
<hr>
<h4>NAME</h4>
ibv_create_srq, ibv_destroy_srq - create or destroy a shared receive queue (SRQ)
<a NAME="lbAC">&nbsp;</a>
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>struct ibv_srq *ibv_create_srq(struct ibv_pd </b><i>*pd</i><b>, struct </b>
<b>                               ibv_srq_init_attr </b><i>*srq_init_attr</i><b>);</b>

<b>struct ibv_srq *ibv_create_xrc_srq(struct ibv_pd </b><i>*pd</i><b>,</b>
<b>                                   struct ibv_xrc_domain </b><i>*xrc_domain</i><b>,</b>
<b>                                   struct ibv_cq </b><i>*xrc_cq</i><b>,</b>
<b>                                   struct ibv_srq_init_attr </b><i>*srq_init_attr</i><b>);</b>

<b>int ibv_destroy_srq(struct ibv_srq </b><i>*srq</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_create_srq()</b> creates a shared receive queue (SRQ) associated with the 
protection domain <i>pd</i>.

<p><b>ibv_create_xrc_srq()</b> creates an XRC shared receive queue (SRQ) 
associated with the protection domain <i>pd</i>, the XRC domain <i>xrc_domain</i> 
and the CQ which will hold the XRC completion <i>xrc_cq</i>. </p>
<p>The argument <i>srq_init_attr</i> is an ibv_srq_init_attr struct, as defined 
in &lt;infiniband/verbs.h&gt;. </p>
<p></p>
<pre>struct ibv_srq_init_attr {
void                   *srq_context;    /* Associated context of the SRQ */
struct ibv_srq_attr     attr;           /* SRQ attributes */
};

struct ibv_srq_attr {
uint32_t                max_wr;         /* Requested max number of outstanding work requests (WRs) in the SRQ */
uint32_t                max_sge;        /* Requested max number of scatter elements per WR */
uint32_t                srq_limit;      /* The limit value of the SRQ (irrelevant for ibv_create_srq) */
};
</pre>
<p>The function <b>ibv_create_srq()</b> will update the <i>srq_init_attr</i> 
struct with the original values of the SRQ that was created; the values of 
max_wr and max_sge will be greater than or equal to the values requested. </p>
<p><b>ibv_destroy_srq()</b> destroys the SRQ <i>srq</i>.</p>
<h4>RETURN VALUE</h4>
<b>ibv_create_srq()</b> returns a pointer to the created SRQ, or NULL if the 
request fails.
<p><b>ibv_destroy_srq()</b> returns 0 on success, or the value of errno on 
failure (which indicates the failure reason). </p>
<h4>NOTES</h4>
<b>ibv_destroy_srq()</b> fails if any queue pair is still associated with this 
SRQ.<h4>SEE ALSO</h4>
<b><a href="#IBV_ALLOC_PD">ibv_alloc_pd</a></b>, <b><a href="#IBV_QUERY_SRQ">ibv_modify_srq</a></b>, <b>
<a href="#IBV_QUERY_SRQ">ibv_query_srq</a></b><p>&nbsp;</p>
<h3><br>
<a name="IBV_MODIFY_SRQ">IBV_MODIFY_SRQ</a></h3>
<hr>
<h4>NAME</h4>
ibv_modify_srq - modify attributes of a shared receive queue (SRQ)<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_modify_srq(struct ibv_srq </b><i>*srq</i><b>,</b>
<b>                   struct ibv_srq_attr </b><i>*srq_attr</i><b>,</b>
<b>                   int </b><i>srq_attr_mask</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_modify_srq()</b> modifies the attributes of SRQ <i>srq</i> with the 
attributes in <i>srq_attr</i> according to the mask <i>srq_attr_mask</i>. The 
argument <i>srq_attr</i> is an ibv_srq_attr struct, as defined in &lt;infiniband/verbs.h&gt;.
<p></p>
<pre>struct ibv_srq_attr {
uint32_t                max_wr;      /* maximum number of outstanding work requests (WRs) in the SRQ */
uint32_t                max_sge;     /* number of scatter elements per WR (irrelevant for ibv_modify_srq) */
uint32_t                srq_limit;   /* the limit value of the SRQ */
};
</pre>
<p>The argument <i>srq_attr_mask</i> specifies the SRQ attributes to be 
modified. The argument is either 0 or the bitwise OR of one or more of the 
following flags: </p>
<p></p>
<dl COMPACT>
	<dt><b>IBV_SRQ_MAX_WR </b>Resize the SRQ </dt>
	<dd></dd>
	<dt><b>IBV_SRQ_LIMIT </b>Set the SRQ limit </dt>
	<dd></dd>
</dl>
<h4>RETURN VALUE</h4>
<b>ibv_modify_srq()</b> returns 0 on success, or the value of errno on failure 
(which indicates the failure reason).<h4>NOTES</h4>
If any of the modify attributes is invalid, none of the attributes will be 
modified.
<p>Not all devices support resizing SRQs. To check if a device supports it, 
check if the <b>IBV_DEVICE_SRQ_RESIZE</b> bit is set in the device capabilities 
flags. </p>
<p>Modifying the srq_limit arms the SRQ to produce an <b>
IBV_EVENT_SRQ_LIMIT_REACHED</b> &quot;low watermark&quot; asynchronous event once the 
number of WRs in the SRQ drops below srq_limit. </p>
<h4>SEE ALSO</h4>
<b><a href="#IBV_QUERY_DEVICE">ibv_query_device</a></b>, <b>
<a href="#IBV_CREATE_SRQ">ibv_create_srq</a></b>, <b><a href="#IBV_DESTROY_SRQ">ibv_destroy_srq</a></b>,
<b><a href="#IBV_QUERY_SRQ">ibv_query_srq</a></b><p>&nbsp;</p>
<h3><br>
<a name="IBV_QUERY_SRQ">IBV_QUERY_SRQ</a></h3>
<hr>
<h4>NAME</h4>
ibv_query_srq - get the attributes of a shared receive queue (SRQ)<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_query_srq(struct ibv_srq </b><i>*srq</i><b>, struct ibv_srq_attr </b><i>*srq_attr</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_query_srq()</b> gets the attributes of the SRQ <i>srq</i> and returns 
them through the pointer <i>srq_attr</i>. The argument <i>srq_attr</i> is an 
ibv_srq_attr struct, as defined in &lt;infiniband/verbs.h&gt;.
<p></p>
<pre>struct ibv_srq_attr {
uint32_t                max_wr;         /* maximum number of outstanding work requests (WRs) in the SRQ */
uint32_t                max_sge;        /* maximum number of scatter elements per WR */
uint32_t                srq_limit;      /* the limit value of the SRQ */
}; </pre>
<h4>RETURN VALUE</h4>
<b>ibv_query_srq()</b> returns 0 on success, or the value of errno on failure 
(which indicates the failure reason).<h4>NOTES</h4>
If the value returned for srq_limit is 0, then the SRQ limit reached (&quot;low 
watermark&quot;) event is not (or no longer) armed, and no asynchronous events will 
be generated until the event is rearmed. <a NAME="lbAG">&nbsp;</a>
<h4>SEE ALSO</h4>
<b><a href="#IBV_CREATE_SRQ">ibv_create_srq</a></b>, <b>
<a href="#IBV_DESTROY_SRQ">ibv_destroy_srq</a></b>, <b>
<a href="#IBV_MODIFY_SRQ">ibv_modify_srq</a></b><p>&nbsp;</p>
<p align="left">&nbsp;</p>
<h3><a name="IBV_CREATE_XRC_RCV_QP">IBV_CREATE_XRC_RCV_QP</a></h3>
<hr>
<h4>NAME</h4>
ibv_create_xrc_rcv_qp - create an XRC queue pair (QP) for serving as a 
receive-side only QP<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_create_xrc_rcv_qp(struct ibv_qp_init_attr </b><i>*init_attr</i><b>,</b>
<b>                          uint32_t </b><i>*xrc_rcv_qpn</i><b>);</b> </pre>
<h4>DESCRIPTION</h4>
<b>ibv_create_xrc_rcv_qp()</b> creates an XRC queue pair (QP) for serving as a 
receive-side only QP and returns its number through the pointer <i>xrc_rcv_qpn</i>. 
This QP number should be passed to the remote node (sender). The remote node 
will use <i>xrc_rcv_qpn</i> in <b>ibv_post_send()</b> when sending to an XRC SRQ 
on this host in the same xrc domain as the XRC receive QP. This QP is created in 
kernel space, and persists until the last process registered for the QP calls <b>
ibv_unreg_xrc_rcv_qp()</b> (at which time the QP is destroyed).
<p>The process which creates this QP is automatically registered for it, and 
should also call <b>ibv_unreg_xrc_rcv_qp()</b> at some point, to unregister. </p>
<p>Processes which wish to receive on an XRC SRQ via this QP should call <b>
ibv_reg_xrc_rcv_qp()</b> for this QP, to guarantee that the QP will not be 
destroyed while they are still using it for receiving on the XRC SRQ. </p>
<p>The argument <i>qp_init_attr</i> is an ibv_qp_init_attr struct, as defined in 
&lt;infiniband/verbs.h&gt;. </p>
<p></p>
<pre>struct ibv_qp_init_attr {
void                   *qp_context;     /* value is being ignored */
struct ibv_cq          *send_cq;        /* value is being ignored */ 
struct ibv_cq          *recv_cq;        /* value is being ignored */
struct ibv_srq         *srq;            /* value is being ignored */
struct ibv_qp_cap       cap;            /* value is being ignored */
enum ibv_qp_type        qp_type;        /* value is being ignored */
int                     sq_sig_all;     /* value is being ignored */
struct ibv_xrc_domain  *xrc_domain;     /* XRC domain the QP will be associated with */
};
</pre>
<p>Most of the attributes in <i>qp_init_attr</i> are being ignored because this 
QP is a receive only QP and all RR are being posted to an SRQ.</p>
<h4>RETURN VALUE</h4>
<b>ibv_create_xrc_rcv_qp()</b> returns 0 on success, or the value of errno on 
failure (which indicates the failure reason).<h4>SEE ALSO</h4>
<b><a href="#IBV_OPEN_XRC_DOMAIN">ibv_open_xrc_domain</a></b>, <b>
<a href="#IBV_QUERY_XRC_RCV_QP">ibv_modify_xrc_rcv_qp</a></b>, <b>
<a href="#IBV_QUERY_XRC_RCV_QP">ibv_query_xrc_rcv_qp</a></b>, <b>
<a href="#IBV_REG_XRC_RCV_QP">ibv_reg_xrc_rcv_qp</a></b>, <b>
<a href="#IBV_REG_XRC_RCV_QP">ibv_unreg_xrc_rcv_qp</a></b>, <b>
<a href="#IBV_POST_SEND">ibv_post_send</a></b><p>&nbsp;</p>
<h3><a name="IBV_MODIFY_XRC_RCV_QP">IBV_MODIFY_XRC_RCV_QP</a></h3>
<hr>
<h4>NAME</h4>
ibv_modify_xrc_rcv_qp - modify the attributes of an XRC receive queue pair (QP)<h4>
SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_modify_xrc_rcv_qp(struct ibv_xrc_domain </b><i>*xrc_domain</i><b>, uint32_t </b><i>xrc_qp_num</i><b>,</b>
<b>                          struct ibv_qp_attr </b><i>*attr</i><b>, int </b><i>attr_mask</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_modify_qp()</b> modifies the attributes of an XRC receive QP with the 
number <i>xrc_qp_num</i> which is associated with the XRC domain <i>xrc_domain</i> 
with the attributes in <i>attr</i> according to the mask <i>attr_mask</i> and 
move the QP state through the following transitions: Reset -&gt; Init -&gt; RTR. <i>
attr_mask</i> should indicate all of the attributes which will be used in this 
QP transition and the following masks (at least) should be set:
<p></p>
<pre>Next state     Required attributes
----------     ----------------------------------------
Init <b>          IBV_QP_STATE, IBV_QP_PKEY_INDEX, IBV_QP_PORT, </b>
     <b>          IBV_QP_ACCESS_FLAGS </b>
RTR  <b>          IBV_QP_STATE, IBV_QP_AV, IBV_QP_PATH_MTU, </b>
     <b>          IBV_QP_DEST_QPN, IBV_QP_RQ_PSN, </b>
     <b>          IBV_QP_MAX_DEST_RD_ATOMIC, IBV_QP_MIN_RNR_TIMER </b>
</pre>
<p>The user can add optional attributes as well. </p>
<p>The argument <i>attr</i> is an ibv_qp_attr struct, as defined in 
&lt;infiniband/verbs.h&gt;. </p>
<p></p>
<pre>struct ibv_qp_attr {
enum ibv_qp_state       qp_state;               /* Move the QP to this state */
enum ibv_qp_state       cur_qp_state;           /* Assume this is the current QP state */
enum ibv_mtu            path_mtu;               /* Path MTU (valid only for RC/UC QPs) */
enum ibv_mig_state      path_mig_state;         /* Path migration state (valid if HCA supports APM) */
uint32_t                qkey;                   /* Q_Key for the QP (valid only for UD QPs) */
uint32_t                rq_psn;                 /* PSN for receive queue (valid only for RC/UC QPs) */
uint32_t                sq_psn;                 /* PSN for send queue (valid only for RC/UC QPs) */
uint32_t                dest_qp_num;            /* Destination QP number (valid only for RC/UC QPs) */
int                     qp_access_flags;        /* Mask of enabled remote access operations (valid only for RC/UC QPs) */
struct ibv_qp_cap       cap;                    /* QP capabilities (valid if HCA supports QP resizing) */
struct ibv_ah_attr      ah_attr;                /* Primary path address vector (valid only for RC/UC QPs) */
struct ibv_ah_attr      alt_ah_attr;            /* Alternate path address vector (valid only for RC/UC QPs) */
uint16_t                pkey_index;             /* Primary P_Key index */
uint16_t                alt_pkey_index;         /* Alternate P_Key index */
uint8_t                 en_sqd_async_notify;    /* Enable SQD.drained async notification (Valid only if qp_state is SQD) */
uint8_t                 sq_draining;            /* Is the QP draining? Irrelevant for ibv_modify_qp() */
uint8_t                 max_rd_atomic;          /* Number of outstanding RDMA reads &amp; atomic operations on the destination QP (valid only for RC QPs) */
uint8_t                 max_dest_rd_atomic;     /* Number of responder resources for handling incoming RDMA reads &amp; atomic operations (valid only for RC QPs) */
uint8_t                 min_rnr_timer;          /* Minimum RNR NAK timer (valid only for RC QPs) */
uint8_t                 port_num;               /* Primary port number */
uint8_t                 timeout;                /* Local ack timeout for primary path (valid only for RC QPs) */
uint8_t                 retry_cnt;              /* Retry count (valid only for RC QPs) */
uint8_t                 rnr_retry;              /* RNR retry (valid only for RC QPs) */
uint8_t                 alt_port_num;           /* Alternate port number */
uint8_t                 alt_timeout;            /* Local ack timeout for alternate path (valid only for RC QPs) */
};
</pre>
<p>For details on struct ibv_qp_cap see the description of <b>ibv_create_qp()</b>. 
For details on struct ibv_ah_attr see the description of <b>ibv_create_ah()</b>.
</p>
<p>The argument <i>attr_mask</i> specifies the QP attributes to be modified. The 
argument is either 0 or the bitwise OR of one or more of the following flags:
</p>
<p></p>
<dl COMPACT>
	<dt><b>IBV_QP_STATE </b>Modify qp_state </dt>
	<dd></dd>
	<dt><b>IBV_QP_CUR_STATE </b>Set cur_qp_state </dt>
	<dd></dd>
	<dt><b>IBV_QP_EN_SQD_ASYNC_NOTIFY </b>Set en_sqd_async_notify </dt>
	<dd></dd>
	<dt><b>IBV_QP_ACCESS_FLAGS </b>Set qp_access_flags </dt>
	<dd></dd>
	<dt><b>IBV_QP_PKEY_INDEX </b>Set pkey_index </dt>
	<dd></dd>
	<dt><b>IBV_QP_PORT </b>Set port_num </dt>
	<dd></dd>
	<dt><b>IBV_QP_QKEY </b>Set qkey </dt>
	<dd></dd>
	<dt><b>IBV_QP_AV </b>Set ah_attr </dt>
	<dd></dd>
	<dt><b>IBV_QP_PATH_MTU </b>Set path_mtu </dt>
	<dd></dd>
	<dt><b>IBV_QP_TIMEOUT </b>Set timeout </dt>
	<dd></dd>
	<dt><b>IBV_QP_RETRY_CNT </b>Set retry_cnt </dt>
	<dd></dd>
	<dt><b>IBV_QP_RNR_RETRY </b>Set rnr_retry </dt>
	<dd></dd>
	<dt><b>IBV_QP_RQ_PSN </b>Set rq_psn </dt>
	<dd></dd>
	<dt><b>IBV_QP_MAX_QP_RD_ATOMIC </b>Set max_rd_atomic </dt>
	<dd></dd>
	<dt><b>IBV_QP_ALT_PATH </b>Set the alternative path via: alt_ah_attr, 
	alt_pkey_index, alt_port_num, alt_timeout </dt>
	<dd></dd>
	<dt><b>IBV_QP_MIN_RNR_TIMER </b>Set min_rnr_timer </dt>
	<dd></dd>
	<dt><b>IBV_QP_SQ_PSN </b>Set sq_psn </dt>
	<dd></dd>
	<dt><b>IBV_QP_MAX_DEST_RD_ATOMIC </b>Set max_dest_rd_atomic </dt>
	<dd></dd>
	<dt><b>IBV_QP_PATH_MIG_STATE </b>Set path_mig_state </dt>
	<dd></dd>
	<dt><b>IBV_QP_CAP </b>Set cap </dt>
	<dd></dd>
	<dt><b>IBV_QP_DEST_QPN </b>Set dest_qp_num </dt>
	<dd></dd>
</dl>
<h4>RETURN VALUE</h4>
<b>ibv_modify_xrc_rcv_qp()</b> returns 0 on success, or the value of errno on 
failure (which indicates the failure reason).
<h4>NOTES</h4>
If any of the modify attributes or the modify mask are invalid, none of the 
attributes will be modified (including the QP state).
<p>Not all devices support alternate paths. To check if a device supports it, 
check if the <b>IBV_DEVICE_AUTO_PATH_MIG</b> bit is set in the device 
capabilities flags.</p>
<h4>SEE ALSO</h4>
<b><a href="#IBV_OPEN_XRC_DOMAIN">ibv_open_xrc_domain</a></b>, <b>
<a href="#IBV_CREATE_XRC_RCV_QP">ibv_create_xrc_rcv_qp</a></b>, <b>
<a href="#IBV_QUERY_XRC_RCV_QP">ibv_query_xrc_rcv_qp</a></b>
<h3>&nbsp;</h3>
<h3><br>
<a name="IBV_OPEN_XRC_DOMAIN">IBV_OPEN_XRC_DOMAIN</a></h3>
<h3><br>
<a name="IBV_CLOSE_XRC_DOMAIN">IBV_CLOSE_XRC_DOMAIN</a></h3>
<hr>
<h4>NAME</h4>
ibv_open_xrc_domain, ibv_close_xrc_domain - open or close an eXtended Reliable 
Connection (XRC) domain
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;fcntl.h&gt;</b>
<b>#include &lt;infiniband/verbs.h&gt;</b>

<b>struct ibv_xrc_domain *ibv_open_xrc_domain(struct ibv_context </b><i>*context</i><b>,</b>
<b>                                           int </b><i>fd</i><b>, int </b><i>oflag</i><b>);</b>
<b>int ibv_close_xrc_domain(struct ibv_xrc_domain </b><i>*d</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_open_xrc_domain()</b> open an XRC domain for the InfiniBand device 
context <i>context</i> or return a reference to an opened one. <i>fd</i> is the 
file descriptor to be associated with the XRC domain. The argument <i>oflag</i> 
describes the desired file creation attributes; it is either 0 or the bitwise OR 
of one or more of the following flags:
<p></p>
<dl COMPACT>
	<dt><b>O_CREAT</b> </dt>
	<dd>If a domain belonging to device named by context is already associated 
	with the inode, this flag has no effect, except as noted under <b>O_EXCL</b> 
	below. Otherwise, a new XRC domain is created and is associated with inode 
	specified by <i>fd</i>.

	</dd>
	<dt><b>O_EXCL</b> </dt>
	<dd>If <b>O_EXCL</b> and <b>O_CREAT</b> are set, open will fail if a domain 
	associated with the inode exists. The check for the existence of the domain 
	and creation of the domain if it does not exist is atomic with respect to 
	other processes executing open with <i>fd</i> naming the same inode.
	</dd>
</dl>
<p>If <i>fd</i> equals -1, no inode is is associated with the domain, and the 
only valid value for <i>oflag</i> is <b>O_CREAT</b>. </p>
<p><b>ibv_close_xrc_domain()</b> closes the XRC domain <i>d</i>. If this is the 
last reference, the XRC domain will be destroyed. </p>
<h4>RETURN VALUE</h4>
<b>ibv_open_xrc_domain()</b> returns a pointer to an opened XRC, or NULL if the 
request fails.
<p><b>ibv_close_xrc_domain()</b> returns 0 on success, or the value of errno on 
failure (which indicates the failure reason).</p>
<h4>NOTES</h4>
Not all devices support XRC. To check if a device supports it, check if the <b>
IBV_DEVICE_XRC</b> bit is set in the device capabilities flags.
<p><b>ibv_close_xrc_domain()</b> may fail if any QP or SRQ are still associated 
with the XRC domain being closed.</p>
<h4>SEE ALSO</h4>
<b><a href="#IBV_CREATE_XRC_SRQ">ibv_create_xrc_srq</a></b>, <b>
<a href="#IBV_CREATE_QP">ibv_create_qp</a></b>, <b>
<a href="#IBV_CREATE_XRC_RCV_QP">ibv_create_xrc_rcv_qp</a></b>,
<b><a href="#IBV_MODIFY_XRC_RCV_QP">ibv_modify_xrc_rcv_qp</a></b>, <b>
<a href="#IBV_QUERY_XRC_RCV_QP">ibv_query_xrc_rcv_qp</a></b>, <b>
<a href="#IBV_REG_XRC_RCV_QP">ibv_reg_xrc_rcv_qp</a></b><p>&nbsp;</p>
<h3><br>
<a name="IBV_QUERY_XRC_RCV_QP">IBV_QUERY_XRC_RCV_QP</a></h3>
<hr>
<h4>NAME</h4>
ibv_query_xrc_rcv_qp - get the attributes of an XRC receive queue pair (QP)
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_query_xrc_rcv_qp(struct ibv_xrc_domain </b><i>*xrc_domain</i><b>, uint32_t </b><i>xrc_qp_num</i><b>,</b>
<b>                         struct ibv_qp_attr </b><i>*attr</i><b>, int </b><i>attr_mask</i><b>,</b>
<b>                         struct ibv_qp_init_attr </b><i>*init_attr</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_query_xrc_rcv_qp()</b> gets the attributes specified in <i>attr_mask</i> 
for the XRC receive QP with the number <i>xrc_qp_num</i> which is associated 
with the XRC domain <i>xrc_domain</i> and returns them through the pointers <i>
attr</i> and <i>init_attr</i>. The argument <i>attr</i> is an ibv_qp_attr 
struct, as defined in &lt;infiniband/verbs.h&gt;.
<p></p>
<pre>struct ibv_qp_attr {
enum ibv_qp_state       qp_state;            /* Current QP state */
enum ibv_qp_state       cur_qp_state;        /* Current QP state - irrelevant for ibv_query_qp */
enum ibv_mtu            path_mtu;            /* Path MTU (valid only for RC/UC QPs) */
enum ibv_mig_state      path_mig_state;      /* Path migration state (valid if HCA supports APM) */
uint32_t                qkey;                /* Q_Key of the QP (valid only for UD QPs) */
uint32_t                rq_psn;              /* PSN for receive queue (valid only for RC/UC QPs) */
uint32_t                sq_psn;              /* PSN for send queue (valid only for RC/UC QPs) */
uint32_t                dest_qp_num;         /* Destination QP number (valid only for RC/UC QPs) */
int                     qp_access_flags;     /* Mask of enabled remote access operations (valid only for RC/UC QPs) */
struct ibv_qp_cap       cap;                 /* QP capabilities */
struct ibv_ah_attr      ah_attr;             /* Primary path address vector (valid only for RC/UC QPs) */
struct ibv_ah_attr      alt_ah_attr;         /* Alternate path address vector (valid only for RC/UC QPs) */
uint16_t                pkey_index;          /* Primary P_Key index */
uint16_t                alt_pkey_index;      /* Alternate P_Key index */
uint8_t                 en_sqd_async_notify; /* Enable SQD.drained async notification - irrelevant for ibv_query_qp */
uint8_t                 sq_draining;         /* Is the QP draining? (Valid only if qp_state is SQD) */
uint8_t                 max_rd_atomic;       /* Number of outstanding RDMA reads &amp; atomic operations on the destination QP (valid only for RC QPs) */
uint8_t                 max_dest_rd_atomic;  /* Number of responder resources for handling incoming RDMA reads &amp; atomic operations (valid only for RC QPs) */
uint8_t                 min_rnr_timer;       /* Minimum RNR NAK timer (valid only for RC QPs) */
uint8_t                 port_num;            /* Primary port number */
uint8_t                 timeout;             /* Local ack timeout for primary path (valid only for RC QPs) */
uint8_t                 retry_cnt;           /* Retry count (valid only for RC QPs) */
uint8_t                 rnr_retry;           /* RNR retry (valid only for RC QPs) */
uint8_t                 alt_port_num;        /* Alternate port number */
uint8_t                 alt_timeout;         /* Local ack timeout for alternate path (valid only for RC QPs) */
};
</pre>
<p>For details on struct ibv_qp_cap see the description of <b>ibv_create_qp()</b>. 
For details on struct ibv_ah_attr see the description of <b>ibv_create_ah()</b>.</p>
<h4>RETURN VALUE</h4>
<b>ibv_query_xrc_rcv_qp()</b> returns 0 on success, or the value of errno on 
failure (which indicates the failure reason).<h4>NOTES</h4>
The argument <i>attr_mask</i> is a hint that specifies the minimum list of 
attributes to retrieve. Some InfiniBand devices may return extra attributes not 
requested, for example if the value can be returned cheaply.
<p>Attribute values are valid if they have been set using <b>
ibv_modify_xrc_rcv_qp()</b>. The exact list of valid attributes depends on the 
QP state. </p>
<p>Multiple calls to <b>ibv_query_xrc_rcv_qp()</b> may yield some differences in 
the values returned for the following attributes: qp_state, path_mig_state, 
sq_draining, ah_attr (if APM is enabled).</p>
<h4>SEE ALSO</h4>
<b><a href="#IBV_OPEN_XRC_DOMAIN">ibv_open_xrc_domain</a></b>, <b>
<a href="#IBV_CREATE_XRC_RCV_QP">ibv_create_xrc_rcv_qp</a></b>, <b>
<a href="#IBV_MODIFY_XRC_RCV_QP">ibv_modify_xrc_rcv_qp</a></b><p>&nbsp;</p>
<h3><br>
<a name="IBV_REG_XRC_RCV_QP">IBV_REG_XRC_RCV_QP</a></h3>
<h3><br>
<a name="IBV_UNREG_XRC_RCV_QP">IBV_UNREG_XRC_RCV_QP</a></h3>
<hr>
<h4>NAME</h4>
ibv_reg_xrc_rcv_qp, ibv_unreg_xrc_rcv_qp - register and unregister a user 
process with an XRC receive queue pair (QP) <a NAME="lbAC">&nbsp;</a>
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_reg_xrc_rcv_qp(struct ibv_xrc_domain </b><i>*xrc_domain</i><b>, uint32_t </b><i>xrc_qp_num</i><b>);</b>
<b>int ibv_unreg_xrc_rcv_qp(struct ibv_xrc_domain </b><i>*xrc_domain</i><b>, uint32_t </b><i>xrc_qp_num</i><b>);</b> </pre>
<h4>DESCRIPTION</h4>
<b>ibv_reg_xrc_rcv_qp()</b> registers a user process with the XRC receive QP 
(created via <b>ibv_create_xrc_rcv_qp()</b> ) whose number is <i>xrc_qp_num</i>, 
and which is associated with the XRC domain <i>xrc_domain</i>.

<p><b>ibv_unreg_xrc_rcv_qp()</b> unregisters a user process from the XRC receive 
QP number <i>xrc_qp_num</i>, which is associated with the XRC domain <i>
xrc_domain</i>. When the number of user processes registered with this XRC 
receive QP drops to zero, the QP is destroyed.</p>
<h4>RETURN VALUE</h4>
<b>ibv_reg_xrc_rcv_qp()</b> and <b>ibv_unreg_xrc_rcv_qp()</b> returns 0 on 
success, or the value of errno on failure (which indicates the failure reason).<h4>
NOTES</h4>
<b>ibv_reg_xrc_rcv_qp()</b> and <b>ibv_unreg_xrc_rcv_qp()</b> may fail if the 
number <i>xrc_qp_num</i> is not a number of a valid XRC receive QP (the QP is 
not allocated or it is the number of a non-XRC QP), or the XRC receive QP was 
created with an XRC domain other than <i>xrc_domain</i>.

<p>If a process is still registered with any XRC RCV QPs belonging to some 
domain, <b>ibv_close_xrc_domain()</b> will return failure if called for that 
domain in that process. </p>
<p><b>ibv_create_xrc_rcv_qp()</b> performs an implicit registration for the 
creating process; when that process is finished with the XRC RCV QP, it should 
call <b>ibv_unreg_xrc_rcv_qp()</b> for that QP. Note that if no other processes 
are registered with the QP at this time, its registration count will drop to 
zero and it will be destroyed. <a NAME="lbAG">&nbsp;</a> </p>
<h4>SEE ALSO</h4>
<b><a href="#IBV_OPEN_XRC_DOMAIN">ibv_open_xrc_domain</a></b>, <b>
<a href="#IBV_CREATE_XRC_RCV_QP">ibv_create_xrc_rcv_qp</a></b><p>&nbsp;</p>
<p align="left">&nbsp;</p>
<h3><br>
<a name="IBV_CREATE_QP">IBV_CREATE_QP</a></h3>
<h3><br>
<a name="IBV_DESTROY_QP">IBV_DESTROY_QP</a></h3>
<hr>
<h4>NAME</h4>
ibv_create_qp, ibv_destroy_qp - create or destroy a queue pair (QP)<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>struct ibv_qp *ibv_create_qp(struct ibv_pd </b><i>*pd</i><b>,</b>
<b>                             struct ibv_qp_init_attr </b><i>*qp_init_attr</i><b>);</b>

<b>int ibv_destroy_qp(struct ibv_qp </b><i>*qp</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_create_qp()</b> creates a queue pair (QP) associated with the protection 
domain <i>pd</i>. The argument <i>qp_init_attr</i> is an ibv_qp_init_attr 
struct, as defined in &lt;infiniband/verbs.h&gt;.
<p></p>
<pre>struct ibv_qp_init_attr {
void                   *qp_context;     /* Associated context of the QP */
struct ibv_cq          *send_cq;        /* CQ to be associated with the Send Queue (SQ) */ 
struct ibv_cq          *recv_cq;        /* CQ to be associated with the Receive Queue (RQ) */
struct ibv_srq         *srq;            /* SRQ handle if QP is to be associated with an SRQ, otherwise NULL */
struct ibv_qp_cap       cap;            /* QP capabilities */
enum ibv_qp_type        qp_type;        /* QP Transport Service Type: IBV_QPT_RC, IBV_QPT_UC, IBV_QPT_UD or IBV_QPT_XRC */
int                     sq_sig_all;     /* If set, each Work Request (WR) submitted to the SQ generates a completion entry */
struct ibv_xrc_domain  *xrc_domain;     /* XRC domain the QP will be associated with (valid only for IBV_QPT_XRC QP), otherwise NULL */
};

struct ibv_qp_cap {
uint32_t                max_send_wr;    /* Requested max number of outstanding WRs in the SQ */
uint32_t                max_recv_wr;    /* Requested max number of outstanding WRs in the RQ */
uint32_t                max_send_sge;   /* Requested max number of scatter/gather (s/g) elements in a WR in the SQ */
uint32_t                max_recv_sge;   /* Requested max number of s/g elements in a WR in the SQ */
uint32_t                max_inline_data;/* Requested max number of data (bytes) that can be posted inline to the SQ, otherwise 0 */
};
</pre>
<p>The function <b>ibv_create_qp()</b> will update the <i>qp_init_attr</i>-&gt;cap 
struct with the actual <font SIZE="-1">QP</font> values of the QP that was 
created; the values will be greater than or equal to the values requested. </p>
<p><b>ibv_destroy_qp()</b> destroys the QP <i>qp</i>.</p>
<h4>RETURN VALUE</h4>
<b>ibv_create_qp()</b> returns a pointer to the created QP, or NULL if the 
request fails. Check the QP number (<b>qp_num</b>) in the returned QP.
<p><b>ibv_destroy_qp()</b> returns 0 on success, or the value of errno on 
failure (which indicates the failure reason).</p>
<h4>NOTES</h4>
<b>ibv_create_qp()</b> will fail if a it is asked to create QP of a type other 
than <b>IBV_QPT_RC</b> or <b>IBV_QPT_UD</b> associated with an SRQ.
<p>The attributes max_recv_wr and max_recv_sge are ignored by <b>ibv_create_qp()</b> 
if the QP is to be associated with an SRQ. </p>
<p><b>ibv_destroy_qp()</b> fails if the QP is attached to a multicast group.</p>
<h4>SEE ALSO</h4>
<b><a href="#IBV_ALLOC_PD">ibv_alloc_pd</a></b>, <b><a href="#IBV_MODIFY_QP">ibv_modify_qp</a></b>, <b>
<a href="#IBV_QUERY_QP">ibv_query_qp</a></b>
<p>&nbsp;</p>
<h3><br>
<a name="IBV_MODIFY_QP">IBV_MODIFY_QP</a></h3>
<hr>
<h4>NAME</h4>
ibv_modify_qp - modify the attributes of a queue pair (QP)
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_modify_qp(struct ibv_qp </b><i>*qp</i><b>, struct ibv_qp_attr </b><i>*attr</i><b>,</b>
<b>                  int </b><i>attr_mask</i><b>);</b> </pre>
<h4>DESCRIPTION</h4>
<b>ibv_modify_qp()</b> modifies the attributes of QP <i>qp</i> with the 
attributes in <i>attr</i> according to the mask <i>attr_mask</i>. The argument
<i>attr</i> is an ibv_qp_attr struct, as defined in &lt;infiniband/verbs.h&gt;.
<p></p>
<pre>struct ibv_qp_attr {
enum ibv_qp_state       qp_state;               /* Move the QP to this state */
enum ibv_qp_state       cur_qp_state;           /* Assume this is the current QP state */
enum ibv_mtu            path_mtu;               /* Path MTU (valid only for RC/UC QPs) */
enum ibv_mig_state      path_mig_state;         /* Path migration state (valid if HCA supports APM) */
uint32_t                qkey;                   /* Q_Key for the QP (valid only for UD QPs) */
uint32_t                rq_psn;                 /* PSN for receive queue (valid only for RC/UC QPs) */
uint32_t                sq_psn;                 /* PSN for send queue (valid only for RC/UC QPs) */
uint32_t                dest_qp_num;            /* Destination QP number (valid only for RC/UC QPs) */
int                     qp_access_flags;        /* Mask of enabled remote access operations (valid only for RC/UC QPs) */
struct ibv_qp_cap       cap;                    /* QP capabilities (valid if HCA supports QP resizing) */
struct ibv_ah_attr      ah_attr;                /* Primary path address vector (valid only for RC/UC QPs) */
struct ibv_ah_attr      alt_ah_attr;            /* Alternate path address vector (valid only for RC/UC QPs) */
uint16_t                pkey_index;             /* Primary P_Key index */
uint16_t                alt_pkey_index;         /* Alternate P_Key index */
uint8_t                 en_sqd_async_notify;    /* Enable SQD.drained async notification (Valid only if qp_state is SQD) */
uint8_t                 sq_draining;            /* Is the QP draining? Irrelevant for ibv_modify_qp() */
uint8_t                 max_rd_atomic;          /* Number of outstanding RDMA reads &amp; atomic operations on the destination QP (valid only for RC QPs) */
uint8_t                 max_dest_rd_atomic;     /* Number of responder resources for handling incoming RDMA reads &amp; atomic operations (valid only for RC QPs) */
uint8_t                 min_rnr_timer;          /* Minimum RNR NAK timer (valid only for RC QPs) */
uint8_t                 port_num;               /* Primary port number */
uint8_t                 timeout;                /* Local ack timeout for primary path (valid only for RC QPs) */
uint8_t                 retry_cnt;              /* Retry count (valid only for RC QPs) */
uint8_t                 rnr_retry;              /* RNR retry (valid only for RC QPs) */
uint8_t                 alt_port_num;           /* Alternate port number */
uint8_t                 alt_timeout;            /* Local ack timeout for alternate path (valid only for RC QPs) */
};
</pre>
<p>For details on struct ibv_qp_cap see the description of <b>ibv_create_qp()</b>. 
For details on struct ibv_ah_attr see the description of <b>ibv_create_ah()</b>.
</p>
<p>The argument <i>attr_mask</i> specifies the QP attributes to be modified. The 
argument is either 0 or the bitwise OR of one or more of the following flags:
</p>
<p></p>
<dl COMPACT>
	<dt><b>IBV_QP_STATE </b>Modify qp_state </dt>
	<dd></dd>
	<dt><b>IBV_QP_CUR_STATE </b>Set cur_qp_state </dt>
	<dd></dd>
	<dt><b>IBV_QP_EN_SQD_ASYNC_NOTIFY </b>Set en_sqd_async_notify </dt>
	<dd></dd>
	<dt><b>IBV_QP_ACCESS_FLAGS </b>Set qp_access_flags </dt>
	<dd></dd>
	<dt><b>IBV_QP_PKEY_INDEX </b>Set pkey_index </dt>
	<dd></dd>
	<dt><b>IBV_QP_PORT </b>Set port_num </dt>
	<dd></dd>
	<dt><b>IBV_QP_QKEY </b>Set qkey </dt>
	<dd></dd>
	<dt><b>IBV_QP_AV </b>Set ah_attr </dt>
	<dd></dd>
	<dt><b>IBV_QP_PATH_MTU </b>Set path_mtu </dt>
	<dd></dd>
	<dt><b>IBV_QP_TIMEOUT </b>Set timeout </dt>
	<dd></dd>
	<dt><b>IBV_QP_RETRY_CNT </b>Set retry_cnt </dt>
	<dd></dd>
	<dt><b>IBV_QP_RNR_RETRY </b>Set rnr_retry </dt>
	<dd></dd>
	<dt><b>IBV_QP_RQ_PSN </b>Set rq_psn </dt>
	<dd></dd>
	<dt><b>IBV_QP_MAX_QP_RD_ATOMIC </b>Set max_rd_atomic </dt>
	<dd></dd>
	<dt><b>IBV_QP_ALT_PATH </b>Set the alternative path via: alt_ah_attr, 
	alt_pkey_index, alt_port_num, alt_timeout </dt>
	<dd></dd>
	<dt><b>IBV_QP_MIN_RNR_TIMER </b>Set min_rnr_timer </dt>
	<dd></dd>
	<dt><b>IBV_QP_SQ_PSN </b>Set sq_psn </dt>
	<dd></dd>
	<dt><b>IBV_QP_MAX_DEST_RD_ATOMIC </b>Set max_dest_rd_atomic </dt>
	<dd></dd>
	<dt><b>IBV_QP_PATH_MIG_STATE </b>Set path_mig_state </dt>
	<dd></dd>
	<dt><b>IBV_QP_CAP </b>Set cap </dt>
	<dd></dd>
	<dt><b>IBV_QP_DEST_QPN </b>Set dest_qp_num </dt>
	<dd></dd>
</dl>
<h4>RETURN VALUE</h4>
<b>ibv_modify_qp()</b> returns 0 on success, or the value of errno on failure 
(which indicates the failure reason).<h4>NOTES</h4>
If any of the modify attributes or the modify mask are invalid, none of the 
attributes will be modified (including the QP state).
<p>Not all devices support resizing QPs. To check if a device supports it, check 
if the <b>IBV_DEVICE_RESIZE_MAX_WR</b> bit is set in the device capabilities 
flags. </p>
<p>Not all devices support alternate paths. To check if a device supports it, 
check if the <b>IBV_DEVICE_AUTO_PATH_MIG</b> bit is set in the device 
capabilities flags. </p>
<p>The following tables indicate for each QP Transport Service Type, the minimum 
list of attributes that must be changed upon transitioning QP state from: Reset 
--&gt; Init --&gt; RTR --&gt; RTS. </p>
<p></p>
<pre>For QP Transport Service Type <b> IBV_QPT_UD</b>:

Next state     Required attributes
----------     ----------------------------------------
Init <b>          IBV_QP_STATE, IBV_QP_PKEY_INDEX, IBV_QP_PORT, </b>
     <b>          IBV_QP_QKEY </b>
RTR  <b>          IBV_QP_STATE </b>
RTS  <b>          IBV_QP_STATE, IBV_QP_SQ_PSN </b>
</pre>
<p></p>
<pre>For QP Transport Service Type <b> IBV_QPT_UC</b>:

Next state     Required attributes
----------     ----------------------------------------
Init <b>          IBV_QP_STATE, IBV_QP_PKEY_INDEX, IBV_QP_PORT, </b>
     <b>          IBV_QP_ACCESS_FLAGS </b>
RTR  <b>          IBV_QP_STATE, IBV_QP_AV, IBV_QP_PATH_MTU, </b>
     <b>          IBV_QP_DEST_QPN, IBV_QP_RQ_PSN </b>
RTS  <b>          IBV_QP_STATE, IBV_QP_SQ_PSN </b>
</pre>
<p></p>
<pre>For QP Transport Service Type <b> IBV_QPT_RC</b>:

Next state     Required attributes
----------     ----------------------------------------
Init <b>          IBV_QP_STATE, IBV_QP_PKEY_INDEX, IBV_QP_PORT, </b>
     <b>          IBV_QP_ACCESS_FLAGS </b>
RTR  <b>          IBV_QP_STATE, IBV_QP_AV, IBV_QP_PATH_MTU, </b>
     <b>          IBV_QP_DEST_QPN, IBV_QP_RQ_PSN, </b>
     <b>          IBV_QP_MAX_DEST_RD_ATOMIC, IBV_QP_MIN_RNR_TIMER </b>
RTS  <b>          IBV_QP_STATE, IBV_QP_SQ_PSN, IBV_QP_MAX_QP_RD_ATOMIC, </b>
     <b>          IBV_QP_RETRY_CNT, IBV_QP_RNR_RETRY, IBV_QP_TIMEOUT</b></pre>
<h4>SEE ALSO</h4>
<b><a href="#IBV_QUERY_QP">ibv_create_qp</a></b>, <b><a href="#IBV_DESTROY_QP">ibv_destroy_qp</a></b>, <b>
<a href="#IBV_QUERY_QP">ibv_query_qp</a></b>, <b>
<a href="#IBV_CREATE_AH">ibv_create_ah</a></b><p>&nbsp;</p>
<p>&nbsp;</p>
<h3><br>
<a name="IBV_POST_RECV">IBV_POST_RECV</a></h3>
<hr>
<h4>NAME</h4>
ibv_post_recv - post a list of work requests (WRs) to a receive queue<h4>
SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_post_recv(struct ibv_qp </b><i>*qp</i><b>, struct ibv_recv_wr </b><i>*wr</i><b>,</b>
<b>                  struct ibv_recv_wr </b><i>**bad_wr</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_post_recv()</b> posts the linked list of work requests (WRs) starting 
with <i>wr</i> to the receive queue of the queue pair <i>qp</i>. It stops 
processing WRs from this list at the first failure (that can be detected 
immediately while requests are being posted), and returns this failing WR 
through <i>bad_wr</i>.

<p>The argument <i>wr</i> is an ibv_recv_wr struct, as defined in &lt;infiniband/verbs.h&gt;.
</p>
<p></p>
<pre>struct ibv_recv_wr {
uint64_t                wr_id;     /* User defined WR ID */
struct ibv_recv_wr     *next;      /* Pointer to next WR in list, NULL if last WR */
struct ibv_sge         *sg_list;   /* Pointer to the s/g array */
int                     num_sge;   /* Size of the s/g array */
};

struct ibv_sge {
uint64_t                addr;      /* Start address of the local memory buffer */
uint32_t                length;    /* Length of the buffer */
uint32_t                lkey;      /* Key of the local Memory Region */
};</pre>
<h4>RETURN VALUE</h4>
<b>ibv_post_recv()</b> returns 0 on success, or the value of errno on failure 
(which indicates the failure reason).
<h4>NOTES</h4>
The buffers used by a WR can only be safely reused after WR the request is fully 
executed and a work completion has been retrieved from the corresponding 
completion queue (CQ).
<p>If the QP <i>qp</i> is associated with a shared receive queue, you must use 
the function <b>ibv_post_srq_recv()</b>, and not <b>ibv_post_recv()</b>, since 
the QP's own receive queue will not be used. </p>
<p>If a WR is being posted to a UD QP, the Global Routing Header (GRH) of the 
incoming message will be placed in the first 40 bytes of the buffer(s) in the 
scatter list. If no GRH is present in the incoming message, then the first bytes 
will be undefined. This means that in all cases, the actual data of the incoming 
message will start at an offset of 40 bytes into the buffer(s) in the scatter 
list. </p>
<h4>SEE ALSO</h4>
<b><a href="#IBV_CREATE_QP">ibv_create_qp</a></b>, <b><a href="#IBV_POST_SEND">ibv_post_send</a></b>, <b>
<a href="#IBV_POST_SRQ_RECV">ibv_post_srq_recv</a></b>,
<b><a href="#IBV_POLL_CQ">ibv_poll_cq</a></b>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3><br>
<a name="IBV_POST_SEND">IBV_POST_SEND</a></h3>
<hr>
<h4>NAME</h4>
ibv_post_send - post a list of work requests (WRs) to a send queue
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_post_send(struct ibv_qp </b><i>*qp</i><b>, struct ibv_send_wr </b><i>*wr</i><b>,</b>
<b>                  struct ibv_send_wr </b><i>**bad_wr</i><b>);</b> </pre>
<h4>DESCRIPTION</h4>
<b>ibv_post_send()</b> posts the linked list of work requests (WRs) starting 
with <i>wr</i> to the send queue of the queue pair <i>qp</i>. It stops 
processing WRs from this list at the first failure (that can be detected 
immediately while requests are being posted), and returns this failing WR 
through <i>bad_wr</i>.

<p>The argument <i>wr</i> is an ibv_send_wr struct, as defined in &lt;infiniband/verbs.h&gt;.
</p>
<p></p>
<pre>struct ibv_send_wr {
uint64_t                wr_id;                  /* User defined WR ID */
struct ibv_send_wr     *next;                   /* Pointer to next WR in list, NULL if last WR */
struct ibv_sge         *sg_list;                /* Pointer to the s/g array */
int                     num_sge;                /* Size of the s/g array */
enum ibv_wr_opcode      opcode;                 /* Operation type */
int                     send_flags;             /* Flags of the WR properties */
uint32_t                imm_data;               /* Immediate data (in network byte order) */
union {
struct {
uint64_t        remote_addr;    /* Start address of remote memory buffer */
uint32_t        rkey;           /* Key of the remote Memory Region */
} rdma;
struct {
uint64_t        remote_addr;    /* Start address of remote memory buffer */ 
uint64_t        compare_add;    /* Compare operand */
uint64_t        swap;           /* Swap operand */
uint32_t        rkey;           /* Key of the remote Memory Region */
} atomic;
struct {
struct ibv_ah  *ah;             /* Address handle (AH) for the remote node address */
uint32_t        remote_qpn;     /* QP number of the destination QP */
uint32_t        remote_qkey;    /* Q_Key number of the destination QP */
} ud;
} wr;
uint32_t                xrc_remote_srq_num;     /* SRQ number of the destination XRC */
};

struct ibv_sge {
uint64_t                addr;                   /* Start address of the local memory buffer */
uint32_t                length;                 /* Length of the buffer */
uint32_t                lkey;                   /* Key of the local Memory Region */
};
</pre>
<p>Each QP Transport Service Type supports a specific set of opcodes, as shown 
in the following table: </p>
<p></p>
<pre>OPCODE                      | IBV_QPT_UD | IBV_QPT_UC | IBV_QPT_RC | IBV_QPT_XRC
----------------------------+------------+------------+------------+------------
IBV_WR_SEND                 |     X      |     X      |     X      |     X
IBV_WR_SEND_WITH_IMM        |     X      |     X      |     X      |     X
IBV_WR_RDMA_WRITE           |            |     X      |     X      |     X
IBV_WR_RDMA_WRITE_WITH_IMM  |            |     X      |     X      |     X
IBV_WR_RDMA_READ            |            |            |     X      |     X
IBV_WR_ATOMIC_CMP_AND_SWP   |            |            |     X      |     X
IBV_WR_ATOMIC_FETCH_AND_ADD |            |            |     X      |     X
</pre>
<p>The attribute send_flags describes the properties of the <font SIZE="-1">WR</font>. 
It is either 0 or the bitwise <font SIZE="-1">OR</font> of one or more of the 
following flags: </p>
<p></p>
<dl COMPACT>
	<dt><b>IBV_SEND_FENCE </b>Set the fence indicator. Valid only for QPs with 
	Transport Service Type <b>IBV_QPT_RC</b> </dt>
	<dd></dd>
	<dt><b>IBV_SEND_SIGNALED </b>Set the completion notification indicator. 
	Relevant only if QP was created with sq_sig_all=0 </dt>
	<dd></dd>
	<dt><b>IBV_SEND_SOLICITED </b>Set the solicited event indicator. Valid only 
	for Send and RDMA Write with immediate </dt>
	<dd></dd>
	<dt><b>IBV_SEND_INLINE </b>Send data in given gather list as inline data
	</dt>
	<dd>in a send WQE. Valid only for Send and RDMA Write. The L_Key will not be 
	checked.
	</dd>
</dl>
<h4>RETURN VALUE</h4>
<b>ibv_post_send()</b> returns 0 on success, or the value of errno on failure 
(which indicates the failure reason).
<h4>NOTES</h4>
The user should not alter or destroy AHs associated with WRs until request is 
fully executed and a work completion has been retrieved from the corresponding 
completion queue (CQ) to avoid unexpected behavior.
<p>The buffers used by a WR can only be safely reused after WR the request is 
fully executed and a work completion has been retrieved from the corresponding 
completion queue (CQ). However, if the IBV_SEND_INLINE flag was set, the buffer 
can be reused immediately after the call returns.</p>
<h4>SEE ALSO</h4>
<b><a href="#IBV_CREATE_QP">ibv_create_qp</a></b>, <b>
<a href="#IBV_CREATE_XRC_RCV_QP">ibv_create_xrc_rcv_qp</a></b>, <b>
<a href="#IBV_CREATE_AH">ibv_create_ah</a></b>,
<b><a href="#IBV_POST_RECV">ibv_post_recv</a></b>, <b>
<a href="#IBV_POST_SRQ_RECV">ibv_post_srq_recv</a></b>, <b>
<a href="#IBV_POLL_CQ">ibv_poll_cq</a></b><p>&nbsp;</p>
<p>&nbsp;</p>
<h3><br>
<a name="IBV_POST_SRQ_RECV">IBV_POST_SRQ_RECV</a></h3>
<hr>
<h4>NAME</h4>
ibv_post_srq_recv - post a list of work requests (WRs) to a shared receive queue 
(SRQ)<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_post_srq_recv(struct ibv_srq </b><i>*srq</i><b>, struct ibv_recv_wr </b><i>*wr</i><b>,</b>
<b>                      struct ibv_recv_wr </b><i>**bad_wr</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_post_srq_recv()</b> posts the linked list of work requests (WRs) starting 
with <i>wr</i> to the shared receive queue (SRQ) <i>srq</i>. It stops processing 
WRs from this list at the first failure (that can be detected immediately while 
requests are being posted), and returns this failing WR through <i>bad_wr</i>.

<p>The argument <i>wr</i> is an ibv_recv_wr struct, as defined in &lt;infiniband/verbs.h&gt;.
</p>
<p></p>
<pre>struct ibv_recv_wr {
uint64_t                wr_id;     /* User defined WR ID */
struct ibv_recv_wr     *next;      /* Pointer to next WR in list, NULL if last WR */
struct ibv_sge         *sg_list;   /* Pointer to the s/g array */
int                     num_sge;   /* Size of the s/g array */
};

struct ibv_sge {
uint64_t                addr;      /* Start address of the local memory buffer */
uint32_t                length;    /* Length of the buffer */
uint32_t                lkey;      /* Key of the local Memory Region */
};</pre>
<h4>RETURN VALUE</h4>
<b>ibv_post_srq_recv()</b> returns 0 on success, or the value of errno on 
failure (which indicates the failure reason).<h4>NOTES</h4>
The buffers used by a WR can only be safely reused after WR the request is fully 
executed and a work completion has been retrieved from the corresponding 
completion queue (CQ).
<p>If a WR is being posted to a UD QP, the Global Routing Header (GRH) of the 
incoming message will be placed in the first 40 bytes of the buffer(s) in the 
scatter list. If no GRH is present in the incoming message, then the first bytes 
will be undefined. This means that in all cases, the actual data of the incoming 
message will start at an offset of 40 bytes into the buffer(s) in the scatter 
list.</p>
<h4>SEE ALSO</h4>
<b><a href="#IBV_CREATE_QP">ibv_create_qp</a></b>, <b><a href="#IBV_POST_SEND">ibv_post_send</a></b>, <b>
<a href="#IBV_POST_RECV">ibv_post_recv</a></b>, <b>
<a href="#IBV_POLL_CQ">ibv_poll_cq</a></b>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3><br>
<a name="IBV_QUERY_QP">IBV_QUERY_QP</a></h3>
<hr>
<h4>NAME</h4>
ibv_query_qp - get the attributes of a queue pair (QP)<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_query_qp(struct ibv_qp </b><i>*qp</i><b>, struct ibv_qp_attr </b><i>*attr</i><b>,</b>
<b>                 int </b><i>attr_mask</i><b>,</b>
<b>                 struct ibv_qp_init_attr </b><i>*init_attr</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_query_qp()</b> gets the attributes specified in <i>attr_mask</i> for the 
QP <i>qp</i> and returns them through the pointers <i>attr</i> and <i>init_attr</i>. 
The argument <i>attr</i> is an ibv_qp_attr struct, as defined in &lt;infiniband/verbs.h&gt;.
<p></p>
<pre>struct ibv_qp_attr {
enum ibv_qp_state       qp_state;            /* Current QP state */
enum ibv_qp_state       cur_qp_state;        /* Current QP state - irrelevant for ibv_query_qp */
enum ibv_mtu            path_mtu;            /* Path MTU (valid only for RC/UC QPs) */
enum ibv_mig_state      path_mig_state;      /* Path migration state (valid if HCA supports APM) */
uint32_t                qkey;                /* Q_Key of the QP (valid only for UD QPs) */
uint32_t                rq_psn;              /* PSN for receive queue (valid only for RC/UC QPs) */
uint32_t                sq_psn;              /* PSN for send queue (valid only for RC/UC QPs) */
uint32_t                dest_qp_num;         /* Destination QP number (valid only for RC/UC QPs) */
int                     qp_access_flags;     /* Mask of enabled remote access operations (valid only for RC/UC QPs) */
struct ibv_qp_cap       cap;                 /* QP capabilities */
struct ibv_ah_attr      ah_attr;             /* Primary path address vector (valid only for RC/UC QPs) */
struct ibv_ah_attr      alt_ah_attr;         /* Alternate path address vector (valid only for RC/UC QPs) */
uint16_t                pkey_index;          /* Primary P_Key index */
uint16_t                alt_pkey_index;      /* Alternate P_Key index */
uint8_t                 en_sqd_async_notify; /* Enable SQD.drained async notification - irrelevant for ibv_query_qp */
uint8_t                 sq_draining;         /* Is the QP draining? (Valid only if qp_state is SQD) */
uint8_t                 max_rd_atomic;       /* Number of outstanding RDMA reads &amp; atomic operations on the destination QP (valid only for RC QPs) */
uint8_t                 max_dest_rd_atomic;  /* Number of responder resources for handling incoming RDMA reads &amp; atomic operations (valid only for RC QPs) */
uint8_t                 min_rnr_timer;       /* Minimum RNR NAK timer (valid only for RC QPs) */
uint8_t                 port_num;            /* Primary port number */
uint8_t                 timeout;             /* Local ack timeout for primary path (valid only for RC QPs) */
uint8_t                 retry_cnt;           /* Retry count (valid only for RC QPs) */
uint8_t                 rnr_retry;           /* RNR retry (valid only for RC QPs) */
uint8_t                 alt_port_num;        /* Alternate port number */
uint8_t                 alt_timeout;         /* Local ack timeout for alternate path (valid only for RC QPs) */
};
</pre>
<p>For details on struct ibv_qp_cap see the description of <b>ibv_create_qp()</b>. 
For details on struct ibv_ah_attr see the description of <b>ibv_create_ah()</b>.</p>
<h4>RETURN VALUE</h4>
<b>ibv_query_qp()</b> returns 0 on success, or the value of errno on failure 
(which indicates the failure reason).<h4>NOTES</h4>
The argument <i>attr_mask</i> is a hint that specifies the minimum list of 
attributes to retrieve. Some RDMA devices may return extra attributes not 
requested, for example if the value can be returned cheaply. This has the same 
form as in <b>ibv_modify_qp()</b>.

<p>Attribute values are valid if they have been set using <b>ibv_modify_qp()</b>. 
The exact list of valid attributes depends on the QP state. </p>
<p>Multiple calls to <b>ibv_query_qp()</b> may yield some differences in the 
values returned for the following attributes: qp_state, path_mig_state, 
sq_draining, ah_attr (if APM is enabled).</p>
<h4>SEE ALSO</h4>
<b><a href="#IBV_CREATE_QP">ibv_create_qp</a></b>, <b><a href="#IBV_DESTROY_QP">ibv_destroy_qp</a></b>, <b>
<a href="#IBV_MODIFY_QP">ibv_modify_qp</a></b>, <b>
<a href="#IBV_CREATE_AH">ibv_create_ah</a></b><p>&nbsp;</p>
<p align="left">&nbsp;</p>
<h3><br>
<a name="IBV_ATTACH_MCAST">IBV_ATTACH_MCAST</a></h3>
<h3><br>
<a name="IBV_DETACH_MCAST">IBV_DETACH_MCAST</a></h3>
<hr>
<h4>NAME</h4>
ibv_attach_mcast, ibv_detach_mcast - attach and detach a queue pair (QPs) 
to/from a multicast group<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_attach_mcast(struct ibv_qp </b><i>*qp</i><b>, const union ibv_gid </b><i>*gid</i><b>,</b> <b>uint16_t </b><i>lid</i><b>);</b>

<b>int ibv_detach_mcast(struct ibv_qp </b><i>*qp</i><b>, const union ibv_gid </b><i>*gid</i><b>,</b> <b>uint16_t </b><i>lid</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_attach_mcast()</b> attaches the QP <i>qp</i> to the multicast group 
having MGID <i>gid</i> and MLID <i>lid</i>.

<p><b>ibv_detach_mcast()</b> detaches the QP <i>qp</i> to the multicast group 
having MGID <i>gid</i> and MLID <i>lid</i>.</p>
<h4>RETURN VALUE</h4>
<b>ibv_attach_mcast()</b> and <b>ibv_detach_mcast()</b> returns 0 on success, or 
the value of errno on failure (which indicates the failure reason).<h4>NOTES</h4>
Only QPs of Transport Service Type <b>IBV_QPT_UD</b> may be attached to 
multicast groups.
<p>If a QP is attached to the same multicast group multiple times, the QP will 
still receive a single copy of a multicast message. </p>
<p>In order to receive multicast messages, a join request for the multicast 
group must be sent to the subnet administrator (SA), so that the fabric's 
multicast routing is configured to deliver messages to the local port.</p>
<h4>SEE ALSO</h4>
<b><a href="#IBV_CREATE_QP">ibv_create_qp</a></b><p>&nbsp;</p>
<h3><br>
<a name="IBV_RATE_TO_MULT">IBV_RATE_TO_MULT</a></h3>
<h3><br>
<a name="IBV_MULT_TO_RATE">IBV_MULT_TO_RATE</a></h3>
<hr>
<h4>NAME</h4>
<p>ibv_rate_to_mult - convert IB rate enumeration to multiplier of 2.5 Gbit/sec<br>
<br>
mult_to_ibv_rate - convert multiplier of 2.5 Gbit/sec to an IB rate enumeration</p>
<h4>SYNOPSIS</h4>
<pre><b>#include &lt;infiniband/verbs.h&gt;</b>

<b>int ibv_rate_to_mult(enum ibv_rate </b><i>rate</i><b>);</b>

<b>enum ibv_rate mult_to_ibv_rate(int </b><i>mult</i><b>);</b></pre>
<h4>DESCRIPTION</h4>
<b>ibv_rate_to_mult()</b> converts the IB transmission rate enumeration <i>rate</i> 
to a multiple of 2.5 Gbit/sec (the base rate). For example, if <i>rate</i> is <b>
IBV_RATE_5_GBPS</b>, the value 2 will be returned (5 Gbit/sec = 2 * 2.5 Gbit/sec).
<p><b>mult_to_ibv_rate()</b> converts the multiplier value (of 2.5 Gbit/sec) <i>
mult</i> to an IB transmission rate enumeration. For example, if <i>mult</i> is 
2, the rate enumeration <b>IBV_RATE_5_GBPS</b> will be returned.</p>
<h4>RETURN VALUE</h4>
<b>ibv_rate_to_mult()</b> returns the multiplier of the base rate 2.5 Gbit/sec.
<p><b>mult_to_ibv_rate()</b> returns the enumeration representing the IB 
transmission rate.</p>
<h4>SEE ALSO</h4>
<b><a href="#IBV_QUERY_PORT">ibv_query_port</a></b>
</span>
<span style="font-size: 12pt; font-family: Times New Roman">
<p align="left"><a href="#TOP"><font color="#000000">&lt;<b>return-to-top</b>&gt;</font></a></p>
<p align="left">&nbsp;</p>
<h2 align="left"><a name="RDMA_CM_-_Communications_Manager">RDMA CM - Communications Manager</a></h2>
<hr>
</span>
<span style="font-size: 12pt; ">
<div class="Section1">
	<h4>NAME</h4>
	<blockquote>
		<p>librdmacm.lib<span class="GramE"> - RDMA 
		communication manager.</span></p>
	</blockquote>
	<h4>SYNOPSIS</h4>
	<blockquote>
		<p>#include &lt;rdma/rdma_cma.h&gt;</p>
	</blockquote>
	<h4>DESCRIPTION</h4>
	<blockquote>
		<p><span class="GramE">Used to establish 
		communication endpoints over RDMA transports.</span></p>
	</blockquote>
	<h4>NOTES</h4>
	<blockquote>
		<p><span class="GramE">The&nbsp; RDMA</span>&nbsp;CM&nbsp;is&nbsp;a communication manager used to setup reliable, con<span class="GramE">nected</span> 
		and unreliable datagram data transfers. <span class="GramE">It&nbsp; 
		provides</span>&nbsp; an&nbsp; RDMA<span class="GramE"> transport&nbsp; 
		neutral</span>&nbsp; interface for establishing connections.&nbsp; The 
		API is <span class="GramE">based</span> on sockets, but adapted for 
		queue pair (QP) based semantics: com<span class="GramE">munication&nbsp;must</span> be over a specific RDMA device, and data transfers are
		<span class="GramE">message</span> based.</p>
		<p>The RDMA CM only <span class="GramE">provides 
		the</span> communication&nbsp;management&nbsp; (connection<span class="GramE"> 
		setup</span> / teardown) portion of an RDMA API.&nbsp; It works in 
		conjunction with<span class="GramE"> the</span> verbs API&nbsp; defined 
		by the libibverbs&nbsp; library.&nbsp;&nbsp; <span class="GramE">The&nbsp; 
		libibverbs</span> <span class="GramE">library</span> provides the 
		interfaces needed to send and receive data.</p>
	</blockquote>
	<h4>CLIENT OPERATION</h4>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This section 
	provides a general overview of the basic operation for the<span class="GramE"> 
	active</span>, or client, side of communication.&nbsp; <span class="GramE">A&nbsp; 
	general</span>&nbsp; connection&nbsp; flow<span class="GramE"> would</span> 
	be:</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#rdma_create_event_channel">rdma_create_event_channel</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">create</span> channel to receive events</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#RDMA_CREATE_ID">rdma_create_id</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">allocate</span> an rdma_cm_id, this is conceptually 
	similar to a socket</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#RDMA_RESOLVE_ADDR">rdma_resolve_addr</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">obtain</span> a local RDMA device to reach the remote 
	address</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">wait</span> for RDMA_CM_EVENT_ADDR_RESOLVED event</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<a href="#RDMA_ACK_CM_EVENT">rdma_ack_cm_event</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">ack</span> event</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#RDMA_CREATE_QP">rdma_create_qp</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">allocate</span> a QP for the communication</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#RDMA_RESOLVE_ROUTE">rdma_resolve_route</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">determine</span> the route to the remote address</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">wait</span> for RDMA_CM_EVENT_ROUTE_RESOLVED event</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#RDMA_ACK_CM_EVENT">rdma_ack_cm_event</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">ack</span> event</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#RDMA_CONNECT">rdma_connect</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">connect</span> to the remote server</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">wait</span> for RDMA_CM_EVENT_ESTABLISHED event</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#RDMA_ACK_CM_EVENT">rdma_ack_cm_event</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">ack</span> event</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Perform data 
	transfers over connection</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#RDMA_DISCONNECT">rdma_disconnect</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">tear-down</span> connection</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">wait</span> for RDMA_CM_EVENT_DISCONNECTED event</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#RDMA_ACK_CM_EVENT">rdma_ack_cm_event</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">ack</span> event</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#RDMA_DESTROY_QP">rdma_destroy_qp</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">destroy</span> the QP</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#RDMA_DESTROY_ID">rdma_destroy_id</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">release</span> the rdma_cm_id</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#rdma_destroy_event_channel_">rdma_destroy_event_channel</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">release</span> the event channel</div>
<blockquote>
	<p>An almost identical process is used to setup 
	unreliable <span class="GramE">datagram&nbsp; (</span>UD)
	<span class="GramE">communication&nbsp; between</span>&nbsp; nodes.&nbsp;<br>
	No actual connection is formed between QPs however, so disconnection is not 
	needed.<br>
	Although this <span class="GramE">example shows</span> the client 
	initiating the disconnect,<span class="GramE"> either</span> side of a 
	connection may initiate the disconnect.</p>
</blockquote>
<div class="Section1">
	<h4>SERVER OPERATION</h4>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This section 
	provides a general overview of the basic operation for the
	<span class="GramE">passive</span>, or server, side of communication.&nbsp; 
	A <span class="GramE">general&nbsp; connection</span>&nbsp; flow<span class="GramE"> 
	would</span> be:</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#rdma_create_event_channel">rdma_create_event_channel</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">create</span> channel to receive events</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#RDMA_CREATE_ID">rdma_create_id</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">allocate</span> an rdma_cm_id, this is conceptually 
	similar to a socket</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#RDMA_BIND_ADDR">rdma_bind_addr</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">set</span> the local port number to listen on</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#RDMA_LISTEN">rdma_listen</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">begin</span> listening for connection requests</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">wait&nbsp; for</span>&nbsp;&nbsp; 
	RDMA_CM_EVENT_CONNECT_REQUEST&nbsp;&nbsp;event with&nbsp;a&nbsp;new&nbsp; rdma_cm_id.</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#RDMA_CREATE_QP">rdma_create_qp</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">allocate</span> a QP for the communication on the new 
	rdma_cm_id</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#RDMA_ACCEPT">rdma_accept</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">accept</span> the connection request</p>
	<p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<a href="#RDMA_ACK_CM_EVENT">rdma_ack_cm_event</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">ack</span> event</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">wait</span> for RDMA_CM_EVENT_ESTABLISHED event</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#RDMA_ACK_CM_EVENT">rdma_ack_cm_event</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">ack</span> event</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Perform data 
	transfers over connection</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">wait</span> for RDMA_CM_EVENT_DISCONNECTED even</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#RDMA_ACK_CM_EVENT">rdma_ack_cm_event</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">ack</span> event</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#RDMA_DISCONNECT">rdma_disconnect</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">tear-down</span> connection</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#RDMA_DESTROY_QP">rdma_destroy_qp</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">destroy</span> the QP</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#RDMA_DESTROY_ID">rdma_destroy_id</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">release</span> the connected rdma_cm_id</p>
	<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<a href="#RDMA_DESTROY_ID">rdma_destroy_id</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">release</span> the listening rdma_cm_id</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<a href="#rdma_destroy_event_channel_">rdma_destroy_event_channel</a></p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">release</span> the event channel</p>
	<h4>RETURN CODES</h4>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span class="GramE">=&nbsp; 0</span>&nbsp;&nbsp; success</p>
	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = -1&nbsp;&nbsp; 
	error - see errno for more details</p>
	<blockquote>
		<p>Librdmacm functions return 0 to indicate 
		success, and a -1 return value <span class="GramE">to</span> indicate 
		failure.</p>
		<p>If a function operates asynchronously<span class="GramE">,&nbsp; 
		a</span>&nbsp; return<span class="GramE"> value&nbsp; of</span>&nbsp; 0&nbsp; 
		means&nbsp; that&nbsp; the operation was successfully started.&nbsp;<br>
		The
		<span class="GramE">operation</span> could still complete in error; 
		users should check the&nbsp; status <span class="GramE">of&nbsp; the</span> 
		related event. <br>
		<br>
		If the return value is -1, then errno will con<span class="GramE">tain</span> 
		additional information regarding the reason for the failure.<br>
		Prior 
		versions of the library would return -errno and not set errno for
		<span class="GramE">some cases</span> related to ENOMEM, ENODEV, ENODATA, 
		EINVAL, and EADDRNO<span class="GramE">TAVAIL codes.<br>
		</span>Applications that want to check these codes and have com<span class="GramE">patibility&nbsp; 
		with</span> prior library versions must manually set errno to the&nbsp;<span class="GramE">negative</span> 
		of the return code if it is &lt; -1.</p>
	</blockquote>
	<h4>SEE ALSO</h4>
	<blockquote>
		<p>&nbsp;<a href="#rdma_create_event_channel">rdma_create_event_<span class="GramE">channel</span></a>, 
		<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a>,&nbsp;<a href="#RDMA_CREATE_ID">rdma_create_id</a>, <br>
		<a href="#RDMA_RESOLVE_ADDR">rdma_resolve_<span class="GramE">addr</span></a>,&nbsp; 
		<a href="#RDMA_BIND_ADDR">rdma_bind_addr</a>, <a href="#RDMA_CREATE_QP">rdma_create_qp</a>,<br>
		<a href="#RDMA_RESOLVE_ROUTE">rdma_resolve_<span class="GramE">route</span></a>, 
		<a href="#RDMA_CONNECT">rdma_connect</a>, <a href="#RDMA_LISTEN">rdma_listen</a>, 
		<a href="#RDMA_ACCEPT">rdma_accept</a>,<br>
		<a href="#RDMA_REJECT">rdma_<span class="GramE">reject</span></a>, 
		<a href="#RDMA_JOIN_MULTICAST">rdma_join_multicast</a>,&nbsp;<a href="#RDMA_LEAVE_MULTICAST">rdma_leave_multicast</a>,<br>
		<a href="#RDMA_NOTIFY">rdma_<span class="GramE">notify</span></a>,&nbsp;&nbsp;<a href="#RDMA_ACK_CM_EVENT">rdma_ack_cm_event</a>,&nbsp;<a href="#RDMA_DISCONNECT">rdma_disconnect</a>,<br>
		<a href="#RDMA_DESTROY_QP">rdma_destroy_<span class="GramE">qp</span></a>,&nbsp; 
		<a href="#RDMA_DESTROY_ID">rdma_destroy_id</a>, <a href="#rdma_destroy_event_channel_">rdma_destroy_event_channel</a>,<br>
		<a href="#RDMA_GET_DEVICES">rdma_get_<span class="GramE">devices</span></a>,&nbsp;<a href="#RDMA_FREE_DEVICES">rdma_free_devices</a>,&nbsp;<a href="#RDMA_GET_PEER_ADDR">rdma_get_peer_addr</a>,<br>
		<a href="#RDMA_GET_LOCAL_ADDR">rdma_get_local_<span class="GramE">addr</span></a>,&nbsp;&nbsp;<a href="#RDMA_GET_DST_PORT">rdma_get_dst_port</a>,&nbsp;<a href="#RDMA_GET_SRC_PORT">rdma_get_src_port</a>,<br>
		<a href="#RDMA_SET_OPTION">rdma_set_<span class="GramE">option</span></a></p>
	</blockquote>
</div>
<p align="left"><a href="#TOP"><font color="#000000">&lt;<b>return-to-top</b>&gt;</font></a></p>
</span>
<span style="font-size: 12pt; font-family: Times New Roman">
<h3>&nbsp;</h3>
<h3><br>
<a name="RDMA_CREATE_ID">RDMA_CREATE_ID</a></h3>
<hr>
<h4>NAME<br>
<br>
RDMA_CREATE_ID - Allocate a communication identifier. <a NAME="lbAC">&nbsp;</a> </h4>
<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>int rdma_create_id</b> <b>(struct 
rdma_event_channel *</b><i>channel</i><b>,</b> <b>struct rdma_cm_id **</b><i>id</i><b>,</b>
<b>void *</b><i>context</i><b>,</b> <b>enum rdma_port_space </b><i>ps</i><b>);</b></p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>channel</dt>
	<dd>The communication channel that events associated with the allocated 
	rdma_cm_id will be reported on. </dd>
	<dt>id</dt>
	<dd>A reference where the allocated communication identifier will be 
	returned. </dd>
	<dt>context</dt>
	<dd>User specified context associated with the rdma_cm_id. </dd>
	<dt>ps</dt>
	<dd>RDMA port space. </dd>
</dl>
<h4>DESCRIPTION</h4>
Creates an identifier that is used to track communication information.
<a NAME="lbAF">&nbsp;</a>
<h4>NOTES</h4>
Rdma_cm_id's are conceptually equivalent to a socket for RDMA communication. The 
difference is that RDMA communication requires explicitly binding to a specified 
RDMA device before communication can occur, and most operations are asynchronous 
in nature. Communication events on an rdma_cm_id are reported through the 
associated event channel. Users must release the rdma_cm_id by calling 
rdma_destroy_id. <a NAME="lbAG">&nbsp;</a>
<h4>PORT SPACE</h4>
Details of the services provided by the different port spaces are outlined 
below.
<dl COMPACT>
	<dt>RDMA_PS_TCP</dt>
	<dd>Provides reliable, connection-oriented QP communication. Unlike TCP, the 
	RDMA port space provides message, not stream, based communication. </dd>
	<dt>RDMA_PS_UDP</dt>
	<dd>Provides unreliable, connectionless QP communication. Supports both 
	datagram and multicast communication. </dd>
</dl>
<h4>SEE ALSO</h4>
<a href="#RDMA_CM_-_Communications_Manager">rdma_cm</a>,
<a href="#RDMA_CREATE_EVENT_CHANNEL">rdma_create_event_channel</a>,
<a href="#RDMA_DESTROY_ID">rdma_destroy_id</a>, <a href="#RDMA_GET_DEVICES">rdma_get_devices</a>,
<a href="#RDMA_BIND_ADDR">rdma_bind_addr</a>, <a href="#RDMA_RESOLVE_ADDR">rdma_resolve_addr</a>,
<a href="#RDMA_CONNECT">rdma_connect</a>, <a href="#RDMA_LISTEN">rdma_listen</a>,
<a href="#RDMA_SET_OPTION">rdma_set_option</a><p align="left">&nbsp;</p>
<h3><br>
<a name="RDMA_DESTROY_ID">RDMA_DESTROY_ID</a></h3>
<hr>
<h4>NAME<br>
<br>
<span style="font-weight: 400">RDMA_DESTROY_ID - Release a communication 
identifier.</span></h4>
<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b> <b>int rdma_destroy_id</b> <b>(struct 
rdma_cm_id *</b><i>id</i><b>);</b><h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>The communication identifier to destroy.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Destroys the specified rdma_cm_id and cancels any outstanding asynchronous 
operation.<h4><font face="Arial" size="3">NOTES</font></h4>
Users must free any associated QP with the rdma_cm_id before calling this 
routine and ack an related events.<h4><font face="Arial" size="3">SEE ALSO</font></h4>
<a href="#RDMA_CREATE_ID">rdma_create_id</a>, <a href="#RDMA_DESTROY_QP">rdma_destroy_qp</a>,
<a href="#RDMA_ACK_CM_EVENT">rdma_ack_cm_event</a>
<h3>&nbsp;</h3>
<h3><br>
<a name="RDMA_CREATE_EVENT_CHANNEL">RDMA_CREATE_EVENT_CHANNEL</a></h3>
<hr>
<h4>NAME</h4>
rdma_create_event_channel - Open a channel used to report communication events.<h4>
SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>struct rdma_event_channel * 
rdma_create_event_channel</b> <b>(</b><i>void</i><b>);</b></p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>void</dt>
	<dd>no arguments
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Asynchronous events are reported to users through event channels. <a NAME="lbAF">
&nbsp;</a>
<h4>NOTES</h4>
Event channels are used to direct all events on an rdma_cm_id. For many clients, 
a single event channel may be sufficient, however, when managing a large number 
of connections or cm_id's, users may find it useful to direct events for 
different cm_id's to different channels for processing. All created event 
channels must be destroyed by calling rdma_destroy_event_channel. Users should 
call rdma_get_cm_event to retrieve events on an event channel. Each event 
channel is mapped to a file descriptor. The associated file descriptor can be 
used and manipulated like any other fd to change its behavior. Users may make 
the fd non-blocking, poll or select the fd, etc. <a NAME="lbAG">&nbsp;</a>
<h4>SEE ALSO</h4>
<a href="#RDMA_CM_-_Communications_Manager">rdma_cm</a>,
<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a>, <a href="#RDMA_DESTROY_EVENT_CHANNEL">rdma_destroy_event_channel</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_DESTROY_EVENT_CHANNEL">RDMA_DESTROY_EVENT_CHANNEL</a></h3>
<hr>
<h4>NAME</h4>
rdma_destroy_event_channel - Close an event communication channel.
<a NAME="lbAC">&nbsp;</a>
<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>void rdma_destroy_event_channel (struct 
rdma_event_channel *</b><i>channel</i><b>);</b> <a NAME="lbAD">&nbsp;</a> </p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>channel</dt>
	<dd>The communication channel to destroy.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Release all resources associated with an event channel and closes the associated 
file descriptor. <a NAME="lbAF">&nbsp;</a>
<h4>NOTES</h4>
All rdma_cm_id's associated with the event channel must be destroyed, and all 
returned events must be acked before calling this function. <a NAME="lbAG">&nbsp;</a>
<h4>SEE ALSO</h4>
<a href="#RDMA_CREATE_EVENT_CHANNEL">rdma_create_event_channel</a>,
<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a>, <a href="#RDMA_ACK_CM_EVENT">rdma_ack_cm_event</a>
<p align="left">&nbsp;</p>
<h3><br>
<a name="RDMA_RESOLVE_ADDR">RDMA_RESOLVE_ADDR</a></h3>
<hr>
<h4>NAME</h4>
rdma_resolve_addr - Resolve destination and optional source addresses.
<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>int rdma_resolve_addr</b> <b>(struct 
rdma_cm_id *</b><i>id</i><b>,</b> <b>struct sockaddr *</b><i>src_addr</i><b>,</b>
<b>struct sockaddr *</b><i>dst_addr</i><b>,</b> <b>int </b><i>timeout_ms</i><b>);</b></p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>RDMA identifier.
	</dd>
	<dt>src_addr</dt>
	<dd>Source address information. This parameter may be NULL.
	</dd>
	<dt>dst_addr</dt>
	<dd>Destination address information.
	</dd>
	<dt>timeout_ms</dt>
	<dd>Time to wait for resolution to complete.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Resolve destination and optional source addresses from IP addresses to an RDMA 
address. If successful, the specified rdma_cm_id will be bound to a local 
device. <a NAME="lbAF">&nbsp;</a>
<h4>NOTES</h4>
This call is used to map a given destination IP address to a usable RDMA 
address. The IP to RDMA address mapping is done using the local routing tables, 
or via ARP. If a source address is given, the rdma_cm_id is bound to that 
address, the same as if rdma_bind_addr were called. If no source address is 
given, and the rdma_cm_id has not yet been bound to a device, then the 
rdma_cm_id will be bound to a source address based on the local routing tables. 
After this call, the rdma_cm_id will be bound to an RDMA device. This call is 
typically made from the active side of a connection before calling 
rdma_resolve_route and rdma_connect. <a NAME="lbAG">&nbsp;</a>
<h4>INFINIBAND SPECIFIC</h4>
This call maps the destination and, if given, source IP addresses to GIDs. In 
order to perform the mapping, IPoIB must be running on both the local and remote 
nodes. <a NAME="lbAH">&nbsp;</a>
<h4>SEE ALSO</h4>
<a href="#RDMA_CREATE_ID">rdma_create_id</a>, <a href="#RDMA_RESOLVE_ROUTE">rdma_resolve_route</a>,
<a href="#RDMA_CONNECT">rdma_connect</a>, <a href="#RDMA_CREATE_QP">rdma_create_qp</a>,
<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a>, <a href="#RDMA_BIND_ADDR">rdma_bind_addr</a>,
<a href="#RDMA_GET_SRC_PORT">rdma_get_src_port</a>, <a href="#RDMA_GET_DST_PORT">rdma_get_dst_port</a>,
<a href="#RDMA_GET_LOCAL_ADDR">rdma_get_local_addr</a>,
<a href="#RDMA_GET_PEER_ADDR">rdma_get_peer_addr</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_GET_CM_EVENT">RDMA_GET_CM_EVENT</a></h3>
<hr>
<h4>NAME</h4>
rdma_get_cm_event - Retrieves the next pending communication event.
<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>int rdma_get_cm_event</b> <b>(struct 
rdma_event_channel *</b><i>channel</i><b>,</b> <b>struct rdma_cm_event **</b><i>event</i><b>);</b>
</p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>channel</dt>
	<dd>Event channel to check for events.
	</dd>
	<dt>event</dt>
	<dd>Allocated information about the next communication event.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Retrieves a communication event. If no events are pending, by default, the call 
will block until an event is received.
<h4>NOTES</h4>
The default synchronous behavior of this routine can be changed by modifying the 
file descriptor associated with the given channel. All events that are reported 
must be acknowledged by calling rdma_ack_cm_event. Destruction of an rdma_cm_id 
will block until related events have been acknowledged.<h4>EVENT DATA</h4>
Communication event details are returned in the rdma_cm_event structure. This 
structure is allocated by the rdma_cm and released by the rdma_ack_cm_event 
routine. Details of the rdma_cm_event structure are given below.
<dl COMPACT>
	<dt>id</dt>
	<dd>The rdma_cm identifier associated with the event. If the event type is 
	RDMA_CM_EVENT_CONNECT_REQUEST, then this references a new id for that 
	communication.
	</dd>
	<dt>listen_id</dt>
	<dd>For RDMA_CM_EVENT_CONNECT_REQUEST event types, this references the 
	corresponding listening request identifier.
	</dd>
	<dt>event</dt>
	<dd>Specifies the type of communication event which occurred. See EVENT 
	TYPES below.
	</dd>
	<dt>status</dt>
	<dd>Returns any asynchronous error information associated with an event. The 
	status is zero unless the corresponding operation failed.
	</dd>
	<dt>param</dt>
	<dd>Provides additional details based on the type of event. Users should 
	select the conn or ud subfields based on the rdma_port_space of the 
	rdma_cm_id associated with the event. See UD EVENT DATA and CONN EVENT DATA 
	below.
	</dd>
</dl>
<h4>UD EVENT DATA</h4>
Event parameters related to unreliable datagram (UD) services: RDMA_PS_UDP and 
RDMA_PS_IPOIB. The UD event data is valid for RDMA_CM_EVENT_ESTABLISHED and 
RDMA_CM_EVENT_MULTICAST_JOIN events, unless stated otherwise.
<dl COMPACT>
	<dt>private_data</dt>
	<dd>References any user-specified data associated with 
	RDMA_CM_EVENT_CONNECT_REQUEST or RDMA_CM_EVENT_ESTABLISHED events. The data 
	referenced by this field matches that specified by the remote side when 
	calling rdma_connect or rdma_accept. This field is NULL if the event does 
	not include private data. The buffer referenced by this pointer is 
	deallocated when calling rdma_ack_cm_event.
	</dd>
	<dt>private_data_len</dt>
	<dd>The size of the private data buffer. Users should note that the size of 
	the private data buffer may be larger than the amount of private data sent 
	by the remote side. Any additional space in the buffer will be zeroed out.
	</dd>
	<dt>ah_attr</dt>
	<dd>Address information needed to send data to the remote endpoint(s). Users 
	should use this structure when allocating their address handle.
	</dd>
	<dt>qp_num</dt>
	<dd>QP number of the remote endpoint or multicast group.
	</dd>
	<dt>qkey</dt>
	<dd>QKey needed to send data to the remote endpoint(s).<br>
&nbsp;</dd>
</dl>
<h4>CONN EVENT DATA</h4>
Event parameters related to connected QP services: RDMA_PS_TCP. The connection 
related event data is valid for RDMA_CM_EVENT_CONNECT_REQUEST and 
RDMA_CM_EVENT_ESTABLISHED events, unless stated otherwise.
<dl COMPACT>
	<dt>private_data</dt>
	<dd>References any user-specified data associated with the event. The data 
	referenced by this field matches that specified by the remote side when 
	calling rdma_connect or rdma_accept. This field is NULL if the event does 
	not include private data. The buffer referenced by this pointer is 
	deallocated when calling rdma_ack_cm_event.
	</dd>
	<dt>private_data_len</dt>
	<dd>The size of the private data buffer. Users should note that the size of 
	the private data buffer may be larger than the amount of private data sent 
	by the remote side. Any additional space in the buffer will be zeroed out.
	</dd>
	<dt>responder_resources</dt>
	<dd>The number of responder resources requested of the recipient. This field 
	matches the initiator depth specified by the remote node when calling 
	rdma_connect and rdma_accept.
	</dd>
	<dt>initiator_depth</dt>
	<dd>The maximum number of outstanding RDMA read/atomic operations that the 
	recipient may have outstanding. This field matches the responder resources 
	specified by the remote node when calling rdma_connect and rdma_accept.
	</dd>
	<dt>flow_control</dt>
	<dd>Indicates if hardware level flow control is provided by the sender.
	</dd>
	<dt>retry_count</dt>
	<dd>For RDMA_CM_EVENT_CONNECT_REQUEST events only, indicates the number of 
	times that the recipient should retry send operations.
	</dd>
	<dt>rnr_retry_count</dt>
	<dd>The number of times that the recipient should retry receiver not ready 
	(RNR) NACK errors.
	</dd>
	<dt>srq</dt>
	<dd>Specifies if the sender is using a shared-receive queue.
	</dd>
	<dt>qp_num</dt>
	<dd>Indicates the remote QP number for the connection.
	</dd>
</dl>
<h4>EVENT TYPES</h4>
The following types of communication events may be reported.
<dl COMPACT>
	<dt>RDMA_CM_EVENT_ADDR_RESOLVED</dt>
	<dd>Address resolution (rdma_resolve_addr) completed successfully.
	</dd>
	<dt>RDMA_CM_EVENT_ADDR_ERROR</dt>
	<dd>Address resolution (rdma_resolve_addr) failed.
	</dd>
	<dt>RDMA_CM_EVENT_ROUTE_RESOLVED</dt>
	<dd>Route resolution (rdma_resolve_route) completed successfully.
	</dd>
	<dt>RDMA_CM_EVENT_ROUTE_ERROR</dt>
	<dd>Route resolution (rdma_resolve_route) failed.
	</dd>
	<dt>RDMA_CM_EVENT_CONNECT_REQUEST</dt>
	<dd>Generated on the passive side to notify the user of a new connection 
	request.
	</dd>
	<dt>RDMA_CM_EVENT_CONNECT_RESPONSE</dt>
	<dd>Generated on the active side to notify the user of a successful response 
	to a connection request. It is only generated on rdma_cm_id's that do not 
	have a QP associated with them.
	</dd>
	<dt>RDMA_CM_EVENT_CONNECT_ERROR</dt>
	<dd>Indicates that an error has occurred trying to establish or a 
	connection. May be generated on the active or passive side of a connection.
	</dd>
	<dt>RDMA_CM_EVENT_UNREACHABLE</dt>
	<dd>Generated on the active side to notify the user that the remote server 
	is not reachable or unable to respond to a connection request.
	</dd>
	<dt>RDMA_CM_EVENT_REJECTED</dt>
	<dd>Indicates that a connection request or response was rejected by the 
	remote end point.
	</dd>
	<dt>RDMA_CM_EVENT_ESTABLISHED</dt>
	<dd>Indicates that a connection has been established with the remote end 
	point.
	</dd>
	<dt>RDMA_CM_EVENT_DISCONNECTED</dt>
	<dd>The connection has been disconnected.
	</dd>
	<dt>RDMA_CM_EVENT_DEVICE_REMOVAL</dt>
	<dd>The local RDMA device associated with the rdma_cm_id has been removed. 
	Upon receiving this event, the user must destroy the related rdma_cm_id.
	</dd>
	<dt>RDMA_CM_EVENT_MULTICAST_JOIN</dt>
	<dd>The multicast join operation (rdma_join_multicast) completed 
	successfully.
	</dd>
	<dt>RDMA_CM_EVENT_MULTICAST_ERROR</dt>
	<dd>An error either occurred joining a multicast group, or, if the group had 
	already been joined, on an existing group. The specified multicast group is 
	no longer accessible and should be rejoined, if desired.
	</dd>
	<dt>RDMA_CM_EVENT_ADDR_CHANGE</dt>
	<dd>The network device associated with this ID through address resolution 
	changed its HW address, eg following of bonding failover. This event can 
	serve as a hint for applications who want the links used for their RDMA 
	sessions to align with the network stack.
	</dd>
	<dt>RDMA_CM_EVENT_TIMEWAIT_EXIT</dt>
	<dd>The QP associated with a connection has exited its timewait state and is 
	now ready to be re-used. After a QP has been disconnected, it is maintained 
	in a timewait state to allow any in flight packets to exit the network. 
	After the timewait state has completed, the rdma_cm will report this event.
	</dd>
</dl>
<h4>SEE ALSO</h4>
<a href="#RDMA_ACK_CM_EVENT">rdma_ack_cm_event</a>,
<a href="#RDMA_CREATE_EVENT_CHANNEL">rdma_create_event_channel</a>,
<a href="#RDMA_RESOLVE_ADDR">rdma_resolve_addr</a>,
<a href="#RDMA_RESOLVE_ROUTE">rdma_resolve_route</a>, <a href="#RDMA_CONNECT">rdma_connect</a>,
<a href="#RDMA_LISTEN">rdma_listen</a>, <a href="#RDMA_JOIN_MULTICAST">rdma_join_multicast</a>,
<a href="#RDMA_DESTROY_ID">rdma_destroy_id</a>, <a href="#RDMA_EVENT_STR">rdma_event_str</a><p>&nbsp;</p>
<h3><br>
<a name="RDMA_ACK_CM_EVENT">RDMA_ACK_CM_EVENT</a></h3>
<hr>
<h4>NAME</h4>
</span>
<span style="font-size: 12pt; ">
rdma_ack_cm_event - Free a communication event.</span><span style="font-size: 12pt; font-family: Times New Roman"><h4>SYNOPSIS</h4>
</span>
<span style="font-size: 12pt; ">
<b>#include &lt;rdma/rdma_cma.h&gt;</b></span><span style="font-size: 12pt; font-family: Times New Roman"><p>&nbsp;</span><span style="font-size: 12pt; "><b>int rdma_ack_cm_event</b> <b>(struct 
rdma_cm_event *</b><i>event</i><b>);</b></span><span style="font-size: 12pt; font-family: Times New Roman"></p>
<h4>ARGUMENTS</h4>
</span>
<span style="font-size: 12pt; ">
<dl COMPACT>
	<dt>event</dt>
	<dd>Event to be released.
	</dd>
</dl>
</span>
<span style="font-size: 12pt; font-family: Times New Roman">
<h4>DESCRIPTION</h4>
</span>
<span style="font-size: 12pt; ">
All events which are allocated by rdma_get_cm_event must be released, there 
should be a one-to-one correspondence between successful gets and acks. This 
call frees the event structure and any memory that it references.</span><span style="font-size: 12pt; font-family: Times New Roman"><h4>SEE ALSO</h4>
</span>
<span style="font-size: 12pt; ">
<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a>, <a href="#RDMA_DESTROY_ID">rdma_destroy_id</a>
</span>
<span style="font-size: 12pt; font-family: Times New Roman">
<p>&nbsp;</p>
</span>
<span style="font-size: 12pt; ">
<h3><br>
<a name="RDMA_CREATE_QP">RDMA_CREATE_QP</a></h3>
<hr>
<h4>NAME</h4>
rdma_create_qp - Allocate a QP. <a NAME="lbAC">&nbsp;</a>
<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>int rdma_create_qp</b> <b>(struct 
rdma_cm_id *</b><i>id</i><b>,</b> <b>struct ibv_pd *</b><i>pd</i><b>,</b> <b>
struct ibv_qp_init_attr *</b><i>qp_init_attr</i><b>);</b> </p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>RDMA identifier.
	</dd>
	<dt>pd</dt>
	<dd>protection domain for the QP.
	</dd>
	<dt>qp_init_attr</dt>
	<dd>initial QP attributes.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Allocate a QP associated with the specified rdma_cm_id and transition it for 
sending and receiving.
<h4>NOTES</h4>
The rdma_cm_id must be bound to a local RDMA device before calling this 
function, and the protection domain must be for that same device. QPs allocated 
to an rdma_cm_id are automatically transitioned by the librdmacm through their 
states. After being allocated, the QP will be ready to handle posting of 
receives. If the QP is unconnected, it will be ready to post sends.<h4>SEE ALSO</h4>
<a href="#RDMA_BIND_ADDR">rdma_bind_addr</a>, <a href="#RDMA_RESOLVE_ADDR">
rdma_resolve_addr</a>, <a href="#RDMA_DESTROY_QP">rdma_destroy_qp</a>,
<a href="#IBV_CREATE_QP">ibv_create_qp</a>, <a href="#IBV_MODIFY_QP">
ibv_modify_qp</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_DESTROY_QP">RDMA_DESTROY_QP</a></h3>
<hr>
<h4>NAME</h4>
rdma_destroy_qp - Deallocate a QP.<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>void rdma_destroy_qp</b> <b>(struct 
rdma_cm_id *</b><i>id</i><b>);</b> </p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>RDMA identifier.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Destroy a QP allocated on the rdma_cm_id.<h4>NOTES</h4>
Users must destroy any QP associated with an rdma_cm_id before destroying the 
ID.<h4>SEE ALSO</h4>
<a href="#RDMA_CREATE_QP">rdma_create_qp</a>, <a href="#RDMA_DESTROY_ID">
rdma_destroy_id</a>, <a href="#IBV_DESTROY_QP">ibv_destroy_qp</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_ACCEPT">RDMA_ACCEPT</a></h3>
<hr>
<h4>NAME</h4>
rdma_accept - Called to accept a connection request. <a NAME="lbAC">&nbsp;</a>
<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>int rdma_accept</b> <b>(struct 
rdma_cm_id *</b><i>id</i><b>,</b> <b>struct rdma_conn_param *</b><i>conn_param</i><b>);</b>
<a NAME="lbAD">&nbsp;</a> </p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>Connection identifier associated with the request.
	</dd>
	<dt>conn_param</dt>
	<dd>Information needed to establish the connection. See CONNECTION 
	PROPERTIES below for details.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Called from the listening side to accept a connection or datagram service lookup 
request.
<h4>NOTES</h4>
Unlike the socket accept routine, rdma_accept is not called on a listening 
rdma_cm_id. Instead, after calling rdma_listen, the user waits for an 
RDMA_CM_EVENT_CONNECT_REQUEST event to occur. Connection request events give the 
user a newly created rdma_cm_id, similar to a new socket, but the rdma_cm_id is 
bound to a specific RDMA device. rdma_accept is called on the new rdma_cm_id.<h4>
CONNECTION PROPERTIES</h4>
The following properties are used to configure the communication and specified 
by the conn_param parameter when accepting a connection or datagram 
communication request. Users should use the rdma_conn_param values reported in 
the connection request event to determine appropriate values for these fields 
when accepting. Users may reference the rdma_conn_param structure in the 
connection event directly, or can reference their own structure. If the 
rdma_conn_param structure from an event is referenced, the event must not be 
acked until after this call returns.
<dl COMPACT>
	<dt>private_data</dt>
	<dd>References a user-controlled data buffer. The contents of the buffer are 
	copied and transparently passed to the remote side as part of the 
	communication request. May be NULL if private_data is not required.
	</dd>
	<dt>private_data_len</dt>
	<dd>Specifies the size of the user-controlled data buffer. Note that the 
	actual amount of data transferred to the remote side is transport dependent 
	and may be larger than that requested.
	</dd>
	<dt>responder_resources</dt>
	<dd>The maximum number of outstanding RDMA read and atomic operations that 
	the local side will accept from the remote side. Applies only to RDMA_PS_TCP. 
	This value must be less than or equal to the local RDMA device attribute 
	max_qp_rd_atom and the responder_resources value reported in the connect 
	request event.
	</dd>
	<dt>initiator_depth</dt>
	<dd>The maximum number of outstanding RDMA read and atomic operations that 
	the local side will have to the remote side. Applies only to RDMA_PS_TCP. 
	This value must be less than or equal to the local RDMA device attribute 
	max_qp_init_rd_atom and the initiator_depth value reported in the connect 
	request event.
	</dd>
	<dt>flow_control</dt>
	<dd>Specifies if hardware flow control is available. This value is exchanged 
	with the remote peer and is not used to configure the QP. Applies only to 
	RDMA_PS_TCP.
	</dd>
	<dt>retry_count</dt>
	<dd>This value is ignored.
	</dd>
	<dt>rnr_retry_count</dt>
	<dd>The maximum number of times that a send operation from the remote peer 
	should be retried on a connection after receiving a receiver not ready (RNR) 
	error. RNR errors are generated when a send request arrives before a buffer 
	has been posted to receive the incoming data. Applies only to RDMA_PS_TCP.
	</dd>
	<dt>srq</dt>
	<dd>Specifies if the QP associated with the connection is using a shared 
	receive queue. This field is ignored by the library if a QP has been created 
	on the rdma_cm_id. Applies only to RDMA_PS_TCP.
	</dd>
	<dt>qp_num</dt>
	<dd>Specifies the QP number associated with the connection. This field is 
	ignored by the library if a QP has been created on the rdma_cm_id.
	</dd>
</dl>
<h4>INFINIBAND SPECIFIC</h4>
In addition to the connection properties defined above, InfiniBand QPs are 
configured with minimum RNR NAK timer and local ACK timeout values. The minimum 
RNR NAK timer value is set to 0, for a delay of 655 ms. The local ACK timeout is 
calculated based on the packet lifetime and local HCA ACK delay. The packet 
lifetime is determined by the InfiniBand Subnet Administrator and is part of the 
route (path record) information obtained by the active side of the connection. 
The HCA ACK delay is a property of the locally used HCA. The RNR retry count is 
a 3-bit value.<h4>SEE ALSO</h4>
<a href="#RDMA_LISTEN">rdma_listen</a>, <a href="#RDMA_REJECT">rdma_reject</a>,
<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_CONNECT">RDMA_CONNECT</a></h3>
<hr>
<h4>NAME</h4>
rdma_connect - Initiate an active connection request.<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>int rdma_connect</b> <b>(struct 
rdma_cm_id *</b><i>id</i><b>,</b> <b>struct rdma_conn_param *</b><i>conn_param</i><b>);</b>
</p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>RDMA identifier.
	</dd>
	<dt>conn_param</dt>
	<dd>connection parameters. See CONNECTION PROPERTIES below for details.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
For an rdma_cm_id of type RDMA_PS_TCP, this call initiates a connection request 
to a remote destination. For an rdma_cm_id of type RDMA_PS_UDP, it initiates a 
lookup of the remote QP providing the datagram service.<h4>NOTES</h4>
Users must have resolved a route to the destination address by having called 
rdma_resolve_route before calling this routine.
<h4>CONNECTION PROPERTIES</h4>
The following properties are used to configure the communication and specified 
by the conn_param parameter when connecting or establishing datagram 
communication.
<dl COMPACT>
	<dt>private_data</dt>
	<dd>References a user-controlled data buffer. The contents of the buffer are 
	copied and transparently passed to the remote side as part of the 
	communication request. May be NULL if private_data is not required.
	</dd>
	<dt>private_data_len</dt>
	<dd>Specifies the size of the user-controlled data buffer. Note that the 
	actual amount of data transferred to the remote side is transport dependent 
	and may be larger than that requested.
	</dd>
	<dt>responder_resources</dt>
	<dd>The maximum number of outstanding RDMA read and atomic operations that 
	the local side will accept from the remote side. Applies only to RDMA_PS_TCP. 
	This value must be less than or equal to the local RDMA device attribute 
	max_qp_rd_atom and remote RDMA device attribute max_qp_init_rd_atom. The 
	remote endpoint can adjust this value when accepting the connection.
	</dd>
	<dt>initiator_depth</dt>
	<dd>The maximum number of outstanding RDMA read and atomic operations that 
	the local side will have to the remote side. Applies only to RDMA_PS_TCP. 
	This value must be less than or equal to the local RDMA device attribute 
	max_qp_init_rd_atom and remote RDMA device attribute max_qp_rd_atom. The 
	remote endpoint can adjust this value when accepting the connection.
	</dd>
	<dt>flow_control</dt>
	<dd>Specifies if hardware flow control is available. This value is exchanged 
	with the remote peer and is not used to configure the QP. Applies only to 
	RDMA_PS_TCP.
	</dd>
	<dt>retry_count</dt>
	<dd>The maximum number of times that a data transfer operation should be 
	retried on the connection when an error occurs. This setting controls the 
	number of times to retry send, RDMA, and atomic operations when timeouts 
	occur. Applies only to RDMA_PS_TCP.
	</dd>
	<dt>rnr_retry_count</dt>
	<dd>The maximum number of times that a send operation from the remote peer 
	should be retried on a connection after receiving a receiver not ready (RNR) 
	error. RNR errors are generated when a send request arrives before a buffer 
	has been posted to receive the incoming data. Applies only to RDMA_PS_TCP.
	</dd>
	<dt>srq</dt>
	<dd>Specifies if the QP associated with the connection is using a shared 
	receive queue. This field is ignored by the library if a QP has been created 
	on the rdma_cm_id. Applies only to RDMA_PS_TCP.
	</dd>
	<dt>qp_num</dt>
	<dd>Specifies the QP number associated with the connection. This field is 
	ignored by the library if a QP has been created on the rdma_cm_id. Applies 
	only to RDMA_PS_TCP.
	</dd>
</dl>
<h4>INFINIBAND SPECIFIC</h4>
In addition to the connection properties defined above, InfiniBand QPs are 
configured with minimum RNR NAK timer and local ACK timeout values. The minimum 
RNR NAK timer value is set to 0, for a delay of 655 ms. The local ACK timeout is 
calculated based on the packet lifetime and local HCA ACK delay. The packet 
lifetime is determined by the InfiniBand Subnet Administrator and is part of the 
resolved route (path record) information. The HCA ACK delay is a property of the 
locally used HCA. Retry count and RNR retry count values are 3-bit values.<h4>
IWARP SPECIFIC</h4>
Connections established over iWarp RDMA devices currently require that the 
active side of the connection send the first message.
<h4>SEE ALSO</h4>
<a href="#RDMA_CM_-_Communications_Manager">rdma_cm</a>,
<a href="#RDMA_CREATE_ID">rdma_create_id</a>, <a href="#RDMA_RESOLVE_ROUTE">
rdma_resolve_route</a>, <a href="#RDMA_DISCONNECT">rdma_disconnect</a>,
<a href="#RDMA_LISTEN">rdma_listen</a>, <a href="#RDMA_GET_CM_EVENT">
rdma_get_cm_event</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_DISCONNECT">RDMA_DISCONNECT</a></h3>
<hr>
<h4>NAME</h4>
rdma_disconnect - This function disconnects a connection. <a NAME="lbAC">&nbsp;</a>
<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>int rdma_disconnect</b> <b>(struct 
rdma_cm_id *</b><i>id</i><b>);</b></p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>RDMA identifier.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Disconnects a connection and transitions any associated QP to the error state, 
which will flush any posted work requests to the completion queue. This routine 
may be called by both the client and server side of a connection. After 
successfully disconnecting, an RDMA_CM_EVENT_DISCONNECTED event will be 
generated on both sides of the connection.<h4>SEE ALSO</h4>
<a href="#RDMA_CONNECT">rdma_connect</a>, <a href="#RDMA_LISTEN">rdma_listen</a>,
<a href="#RDMA_ACCEPT">rdma_accept</a>, <a href="#RDMA_GET_CM_EVENT">
rdma_get_cm_event</a><p>&nbsp;</p>
<h3><br>
<a name="RDMA_RESOLVE_ROUTE">RDMA_RESOLVE_ROUTE</a></h3>
<hr>
<h4>NAME</h4>
rdma_resolve_route - Resolve the route information needed to establish a 
connection.<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>int rdma_resolve_route</b> <b>(struct 
rdma_cm_id *</b><i>id</i><b>,</b> <b>int </b><i>timeout_ms</i><b>);</b></p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>RDMA identifier.
	</dd>
	<dt>timeout_ms</dt>
	<dd>Time to wait for resolution to complete.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Resolves an RDMA route to the destination address in order to establish a 
connection. The destination address must have already been resolved by calling 
rdma_resolve_addr.
<h4>NOTES</h4>
This is called on the client side of a connection after calling 
rdma_resolve_addr, but before calling rdma_connect.<h4>INFINIBAND SPECIFIC</h4>
This call obtains a path record that is used by the connection.
<h4>SEE ALSO</h4>
<a href="#RDMA_RESOLVE_ADDR">rdma_resolve_addr</a>, <a href="#RDMA_CONNECT">
rdma_connect</a>, <a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_BIND_ADDR">RDMA_BIND_ADDR</a></h3>
<hr>
<h4>NAME</h4>
rdma_bind_addr - Bind an RDMA identifier to a source address.<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>int rdma_bind_addr</b> <b>(struct 
rdma_cm_id *</b><i>id</i><b>,</b> <b>struct sockaddr *</b><i>addr</i><b>);</b>
</p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>RDMA identifier.
	</dd>
	<dt>addr</dt>
	<dd>Local address information. Wildcard values are permitted.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Associates a source address with an rdma_cm_id. The address may be wildcarded. 
If binding to a specific local address, the rdma_cm_id will also be bound to a 
local RDMA device.<h4>NOTES</h4>
Typically, this routine is called before calling rdma_listen to bind to a 
specific port number, but it may also be called on the active side of a 
connection before calling rdma_resolve_addr to bind to a specific address. If 
used to bind to port 0, the rdma_cm will select an available port, which can be 
retrieved with <a href="#RDMA_GET_SRC_PORT">rdma_get_src_port</a>.<h4>SEE ALSO</h4>
<a href="#RDMA_CREATE_ID">rdma_create_id</a>, <a href="#RDMA_LISTEN">rdma_listen</a>,
<a href="#RDMA_RESOLVE_ADDR">rdma_resolve_addr</a>, <a href="#RDMA_CREATE_QP">
rdma_create_qp</a>, <a href="#RDMA_GET_LOCAL_ADDR">rdma_get_local_addr</a>,
<a href="#RDMA_GET_SRC_PORT">rdma_get_src_port</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_LISTEN">RDMA_LISTEN</a></h3>
<hr>
<h4>NAME</h4>
rdma_listen - Listen for incoming connection requests.<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>int rdma_listen</b> <b>(struct 
rdma_cm_id *</b><i>id</i><b>,</b> <b>int </b><i>backlog</i><b>);</b></p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>RDMA identifier.
	</dd>
	<dt>backlog</dt>
	<dd>backlog of incoming connection requests.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Initiates a listen for incoming connection requests or datagram service lookup. 
The listen will be restricted to the locally bound source address.
<h4>NOTES</h4>
Users must have bound the rdma_cm_id to a local address by calling 
rdma_bind_addr before calling this routine. If the rdma_cm_id is bound to a 
specific IP address, the listen will be restricted to that address and the 
associated RDMA device. If the rdma_cm_id is bound to an RDMA port number only, 
the listen will occur across all RDMA devices.<h4>SEE ALSO</h4>
<a href="#RDMA_CM_-_Communications_Manager">rdma_cm</a>,
<a href="#RDMA_BIND_ADDR">rdma_bind_addr</a>, <a href="#RDMA_CONNECT">
rdma_connect</a>, <a href="#RDMA_ACCEPT">rdma_accept</a>, <a href="#RDMA_REJECT">
rdma_reject</a>, <a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_REJECT">RDMA_REJECT</a></h3>
<hr>
<h4>NAME</h4>
rdma_reject - Called to reject a connection request.<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>int rdma_reject</b> <b>(struct 
rdma_cm_id *</b><i>id</i><b>,</b> <b>const void *</b><i>private_data</i><b>,</b>
<b>uint8_t </b><i>private_data_len</i><b>);</b> </p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>Connection identifier associated with the request.
	</dd>
	<dt>private_data</dt>
	<dd>Optional private data to send with the reject message.
	</dd>
	<dt>private_data_len</dt>
	<dd>Specifies the size of the user-controlled data buffer. Note that the 
	actual amount of data transferred to the remote side is transport dependent 
	and may be larger than that requested.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Called from the listening side to reject a connection or datagram service lookup 
request.<h4>NOTES</h4>
After receiving a connection request event, a user may call rdma_reject to 
reject the request. If the underlying RDMA transport supports private data in 
the reject message, the specified data will be passed to the remote side.
<h4>SEE ALSO</h4>
<a href="#RDMA_LISTEN">rdma_listen</a>, <a href="#RDMA_ACCEPT">rdma_accept</a>,
<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_GET_SRC_PORT">RDMA_GET_SRC_PORT</a></h3>
<hr>
<h4>NAME</h4>
rdma_get_src_port - Returns the local port number of a bound rdma_cm_id.<h4>
SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>uint16_t rdma_get_src_port</b> <b>
(struct rdma_cm_id *</b><i>id</i><b>);</b> <a NAME="lbAD">&nbsp;</a> </p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>RDMA identifier.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Returns the local port number for an rdma_cm_id that has been bound to a local 
address.<h4>SEE ALSO</h4>
<a href="#RDMA_BIND_ADDR">rdma_bind_addr</a>, <a href="#RDMA_RESOLVE_ADDR">
rdma_resolve_addr</a>, <a href="#RDMA_GET_DST_PORT">rdma_get_dst_port</a>,
<a href="#RDMA_GET_LOCAL_ADDR">rdma_get_local_addr</a>,
<a href="#RDMA_GET_PEER_ADDR">rdma_get_peer_addr</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_GET_DST_PORT">RDMA_GET_DST_PORT</a></h3>
<hr>
<h4>NAME</h4>
rdma_get_dst_port - Returns the remote port number of a bound rdma_cm_id.<h4>
SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>uint16_t rdma_get_dst_port</b> <b>
(struct rdma_cm_id *</b><i>id</i><b>);</b> </p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>RDMA identifier.</dd>
</dl>
<h4>DESCRIPTION</h4>
Returns the remote port number for an rdma_cm_id that has been bound to a remote 
address.<h4>SEE ALSO</h4>
<a href="#RDMA_CONNECT">rdma_connect</a>, <a href="#RDMA_ACCEPT">rdma_accept</a>,
<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a>, <a href="#RDMA_GET_SRC_PORT">
rdma_get_src_port</a>, <a href="#RDMA_GET_LOCAL_ADDR">rdma_get_local_addr</a>,
<a href="#RDMA_GET_PEER_ADDR">rdma_get_peer_addr</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_GET_LOCAL_ADDR">RDMA_GET_LOCAL_ADDR</a></h3>
<hr>
<h4>NAME</h4>
rdma_get_local_addr - Returns the local IP address of a bound rdma_cm_id.
<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>struct sockaddr * rdma_get_local_addr</b>
<b>(struct rdma_cm_id *</b><i>id</i><b>);</b> </p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>RDMA identifier.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Returns the local IP address for an rdma_cm_id that has been bound to a local 
device.<h4>SEE ALSO</h4>
<a href="#RDMA_BIND_ADDR">rdma_bind_addr</a>, <a href="#RDMA_RESOLVE_ADDR">
rdma_resolve_addr</a>, <a href="#RDMA_GET_SRC_PORT">rdma_get_src_port</a>,
<a href="#RDMA_GET_DST_PORT">rdma_get_dst_port</a>,
<a href="#RDMA_GET_PEER_ADDR">rdma_get_peer_addr</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_GET_PEER_ADDR">RDMA_GET_PEER_ADDR</a></h3>
<hr>
<h4>NAME</h4>
rdma_get_peer_addr - Returns the remote IP address of a bound rdma_cm_id.<h4>
SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>struct sockaddr * rdma_get_peer_addr</b>
<b>(struct rdma_cm_id *</b><i>id</i><b>);</b> </p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>RDMA identifier.</dd>
</dl>
<h4>DESCRIPTION</h4>
Returns the remote IP address associated with an rdma_cm_id.<h4>SEE ALSO</h4>
<a href="#RDMA_RESOLVE_ADDR">rdma_resolve_addr</a>, <a href="#RDMA_GET_SRC_PORT">
rdma_get_src_port</a>, <a href="#RDMA_GET_DST_PORT">rdma_get_dst_port</a>,
<a href="#RDMA_GET_LOCAL_ADDR">rdma_get_local_addr</a><p>&nbsp;</p>
<h3><br>
<a name="RDMA_EVENT_STR">RDMA_EVENT_STR</a></h3>
<hr>
<h4>NAME</h4>
rdma_event_str - Returns a string representation of an rdma cm event.<h4>
SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>char * rdma_event_str</b> <b>(enum</b><i>rdma_cm_event_type</i><b> 
event );</b></p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>event</dt>
	<dd>Asynchronous event.</dd>
</dl>
<h4>DESCRIPTION</h4>
Returns a string representation of an asynchronous event.<h4>SEE ALSO</h4>
<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a><p>&nbsp;</p>
<h3><br>
<a name="RDMA_JOIN_MULTICAST">RDMA_JOIN_MULTICAST</a></h3>
<hr>
<h4>NAME</h4>
rdma_join_multicast - Joins a multicast group.<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>int rdma_join_multicast</b> <b>(struct 
rdma_cm_id *</b><i>id</i><b>,</b> <b>struct sockaddr *</b><i>addr</i><b>,</b> <b>
void *</b><i>context</i><b>);</b></p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>Communication identifier associated with the request.
	</dd>
	<dt>addr</dt>
	<dd>Multicast address identifying the group to join.
	</dd>
	<dt>context</dt>
	<dd>User-defined context associated with the join request.</dd>
</dl>
<h4>DESCRIPTION</h4>
Joins a multicast group and attaches an associated QP to the group.<h4>NOTES</h4>
Before joining a multicast group, the rdma_cm_id must be bound to an RDMA device 
by calling rdma_bind_addr or rdma_resolve_addr. Use of rdma_resolve_addr 
requires the local routing tables to resolve the multicast address to an RDMA 
device, unless a specific source address is provided. The user must call 
rdma_leave_multicast to leave the multicast group and release any multicast 
resources. After the join operation completes, any associated QP is 
automatically attached to the multicast group, and the join context is returned 
to the user through the private_data field in the rdma_cm_event.<h4>SEE ALSO</h4>
<a href="#RDMA_LEAVE_MULTICAST">rdma_leave_multicast</a>,
<a href="#RDMA_BIND_ADDR">rdma_bind_addr</a>, <a href="#RDMA_RESOLVE_ADDR">
rdma_resolve_addr</a>, <a href="#RDMA_CREATE_QP">rdma_create_qp</a>,
<a href="#RDMA_GET_CM_EVENT">rdma_get_cm_event</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_LEAVE_MULTICAST">RDMA_LEAVE_MULTICAST</a></h3>
<hr>
<h4>NAME</h4>
rdma_leave_multicast - Leaves a multicast group.
<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>int rdma_leave_multicast</b> <b>(struct 
rdma_cm_id *</b><i>id</i><b>,</b> <b>struct sockaddr *</b><i>addr</i><b>);</b></p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>Communication identifier associated with the request.
	</dd>
	<dt>addr</dt>
	<dd>Multicast address identifying the group to leave.</dd>
</dl>
<h4>DESCRIPTION</h4>
Leaves a multicast group and detaches an associated QP from the group.<h4>NOTES</h4>
Calling this function before a group has been fully joined results in canceling 
the join operation. Users should be aware that messages received from the 
multicast group may stilled be queued for completion processing immediately 
after leaving a multicast group. Destroying an rdma_cm_id will automatically 
leave all multicast groups.<h4>SEE ALSO</h4>
<a href="#RDMA_JOIN_MULTICAST">rdma_join_multicast</a>,
<a href="#RDMA_DESTROY_QP">rdma_destroy_qp</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_SET_OPTION">RDMA_SET_OPTION</a></h3>
<hr>
<h4>NAME</h4>
rdma_set_option - Set communication options for an rdma_cm_id.<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>int rdma_set_option</b> <b>(struct 
rdma_cm_id *</b><i>id</i><b>,</b> <b>int </b><i>level</i><b>,</b> <b>int </b><i>
optname</i><b>,</b> <b>void *</b><i>optval</i><b>,</b> <b>size_t </b><i>optlen</i><b>);</b>
</p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>RDMA identifier.
	</dd>
	<dt>level</dt>
	<dd>Protocol level of the option to set.
	</dd>
	<dt>optname</dt>
	<dd>Name of the option, relative to the level, to set.
	</dd>
	<dt>optval</dt>
	<dd>Reference to the option data. The data is dependent on the level and 
	optname.
	</dd>
	<dt>optlen</dt>
	<dd>The size of the %optval buffer.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Sets communication options for an rdma_cm_id. This call is used to override the 
default system settings.<h4>NOTES</h4>
Option details may be found in the relevent header files.<h4>SEE ALSO</h4>
<a href="#RDMA_CREATE_ID">rdma_create_id</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_GET_DEVICES">RDMA_GET_DEVICES</a></h3>
<hr>
<h4>NAME</h4>
rdma_get_devices - Get a list of RDMA devices currently available.<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>struct ibv_context ** rdma_get_devices</b>
<b>(int *</b><i>num_devices</i><b>);</b></p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>num_devices</dt>
	<dd>If non-NULL, set to the number of devices returned.
	</dd>
</dl>
<h4>DESCRIPTION</h4>
Return a NULL-terminated array of opened RDMA devices. Callers can use this 
routine to allocate resources on specific RDMA devices that will be shared 
across multiple rdma_cm_id's.<h4>NOTES</h4>
The returned array must be released by calling rdma_free_devices. Devices remain 
opened while the librdmacm is loaded
<h4>SEE ALSO</h4>
<a href="#RDMA_FREE_DEVICES">rdma_free_devices</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_FREE_DEVICES">RDMA_FREE_DEVICES</a></h3>
<hr>
<h4>NAME</h4>
rdma_free_devices - Frees the list of devices returned by rdma_get_devices.<h4>
SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>void rdma_free_devices</b> <b>(struct 
ibv_context **</b><i>list</i><b>);</b> </p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>list</dt>
	<dd>List of devices returned from rdma_get_devices.</dd>
</dl>
<h4>DESCRIPTION</h4>
Frees the device array returned by rdma_get_devices.<h4>SEE ALSO</h4>
<a href="#RDMA_GET_DEVICES">rdma_get_devices</a>
<p>&nbsp;</p>
<h3><br>
<a name="RDMA_NOTIFY">RDMA_NOTIFY</a></h3>
<hr>
<h4>NAME</h4>
rdma_notify - Notifies the librdmacm of an asynchronous event.<h4>SYNOPSIS</h4>
<b>#include &lt;rdma/rdma_cma.h&gt;</b><p>&nbsp;<b>int rdma_notify</b> <b>(struct 
rdma_cm_id *</b><i>id</i><b>,</b> <b>enum ibv_event_type </b><i>event</i><b>);</b></p>
<h4>ARGUMENTS</h4>
<dl COMPACT>
	<dt>id</dt>
	<dd>RDMA identifier.
	</dd>
	<dt>event</dt>
	<dd>Asynchronous event.</dd>
</dl>
<h4>DESCRIPTION</h4>
Used to notify the librdmacm of asynchronous events that have occurred on a QP 
associated with the rdma_cm_id.<h4>NOTES</h4>
Asynchronous events that occur on a QP are reported through the user's device 
event handler. This routine is used to notify the librdmacm of communication 
events. In most cases, use of this routine is not necessary, however if 
connection establishment is done out of band (such as done through Infiniband), 
it's possible to receive data on a QP that is not yet considered connected. This 
routine forces the connection into an established state in this case in order to 
handle the rare situation where the connection never forms on its own. Events 
that should be reported to the CM are: IB_EVENT_COMM_EST.<h4>SEE ALSO</h4>
<a href="#RDMA_CONNECT">rdma_connect</a>, <a href="#RDMA_ACCEPT">rdma_accept</a>,
<a href="#RDMA_LISTEN">rdma_listen</a>
<p>
<span style="font-size: 12pt; ">
<a href="#TOP"><font color="#000000">&lt;</font></a></span><a href="#TOP"><font color="#000000"><b>return-to-top</b><span style="font-size: 12pt; ">&gt;</span></font></a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="WinVerbs">WinVerbs</a></h2></span>
<span style="font-size: 12pt; font-family: Times New Roman">
<hr>
</span>
<span style="font-size: 12pt; ">
<p>WinVerbs is a userspace verbs and communication management interface optimized<br>for the Windows operating system. Its lower interface is designed to support<br>any RDMA based device, including Infiniband and 
future RDMA devices. Its upper interface is<br>capable of providing a low latency verbs interface, plus supports Microsoft's<br>NetworkDirect Interface, DAPL and OFED 
components: libibverbs, libibmad, rdma_cm interfaces and numerous OFED IB 
diagnostic tools.<br>
<br>The WinVerbs driver loads as an upper filter driver for Infiniband HCA 
devices.<br>(Open source iWarp drivers for Windows are not yet available.) A corresponding<br>userspace library installs as part of the Winverbs driver installation package.<br>Additionally, a Windows port of the OFED libibverbs library and several test<br>programs are also included.</p>
<p>As of the WinOF 2.1 release, Winverbs and Winmad are are fully integrated 
into the HCA driver stack load.<br>
That's to say, Winverbs and Winmad are now integral components of the OFED 
stack.<br>
<br>Available libibverbs test programs and their usage are listed<br>below. Note that not all listed options apply to all applications<br>
<br>ibv_rc_pingpong, ibv_uc_pingpong, ibv_ud_pingpong<br>no args start a server and wait for connection<br>-h &lt;host&gt;&nbsp;&nbsp;&nbsp;&nbsp; connect to server at &lt;host&gt;<br>-p &lt;port&gt;&nbsp;&nbsp;&nbsp;&nbsp; listen on/connect to port &lt;port&gt; (default 18515)<br>-d &lt;dev&gt;&nbsp;&nbsp;&nbsp;&nbsp; use IB device &lt;dev&gt; (default first device found)<br>-i &lt;port&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use port &lt;port&gt; of IB device (default 1)<br>-s &lt;size&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size of message to exchange (default 4096)<br>-m &lt;size&gt;&nbsp;&nbsp;&nbsp;&nbsp; path MTU (default 1024)<br>-r &lt;dep&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; number of receives to post at a time (default 500)<br>-n &lt;iters&gt;&nbsp;&nbsp;&nbsp;&nbsp; number of exchanges (default 1000)<br>-l &lt;sl&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; service level value<br>-e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sleep on CQ events (default poll)<br>
<br>ibv_send_bw, ibv_send_lat<br>ibv_read_bw, ibv_read_lat<br>ibv_write_bw, ibv_write_lat<br>no args start a server and wait for connection<br>-h &lt;host&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connect to server at &lt;host&gt;<br>-p &lt;port&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listen on/connect to port &lt;port&gt; (default 18515)<br>-d &lt;dev&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use IB device &lt;dev&gt; (default first device found)<br>-i &lt;port&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use port &lt;port&gt; of IB device (default 1)<br>-c &lt;RC/UC/UD&gt;&nbsp; connection type RC/UC/UD (default RC)<br>-m &lt;mtu&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mtu size (256 - 4096. default for hermon is 2048)<br>-s &lt;size&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size of message to exchange (default 65536)<br>-a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Run sizes from 2 till 2^23<br>-t &lt;dep&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size of tx queue (default 300)<br>-g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; send messages to multicast group (UD only)<br>-r &lt;dep&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; make rx queue bigger than tx (default 600)<br>-n &lt;iters&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; number of exchanges (at least 2, default 1000)<br>-I &lt;size&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max size of message to be sent in inline mode (default 400)<br>-b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; measure bidirectional bandwidth (default unidirectional)<br>-V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display version number<br>-e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sleep on CQ events (default poll)<br>-N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cancel peak-bw calculation (default with peak-bw)<br>
<br>To verify correct WinVerbs and libibverbs installation, run ibstat or ibv_devinfo. It<br>should report all RDMA devices in the system, along with limited port<br>attributes. Because of limitations in the 
OFED for Windows stack 
in comparision to the Linux OFED stack, it is normal for the programs to<br>list several values as unknown.</p>
<p><a href="#TOP"><font color="#000000">&lt;<b>return-to-top</b>&gt;</font></a></p>


</span>
<span style="font-size: 12pt; ">
<h2>&nbsp;</h2>
<h2><u><a name="RSockets">RSockets</a></u></h2></span>
<span style="font-size: 12pt; font-family: Times New Roman">
<hr>
</span>
</font>
<p><span style="font-family: Times New Roman">The RSockets protocol provides 
socket-based RDMA communication between Windows nodes as well as between Windows 
and Linux nodes.<br>
<br>
The RSockets functionality is contained within the librdmacm.dll, which now is 
capable to act as a Winsock base transport provider.<br>
<br>
For now the librdmacm.dll still exports the direct rsocket calls (rsocket, rbind, 
rrecv etc.) as well. So application developers can alternatively circumvent 
Winsock and call those functions directly (by including rsocket.h instead of 
rwinsock.h).<br>
Aside from a slight performance gain, this might be useful in case of quickly 
porting a Linux app to Windows(?).<br>
But beware of using both access methods concurrently in the same application!<br>
<br>
<br>
INSTALLATION<br>
============<br>
The winOFED installation supports the install feature 'Rsockets Service 
Enabled'. Choosing this feature will accomplish two tasks which ensure correct 
Rsockets operation.</span></p>
<ol>
	<li><span style="font-family: Times New Roman">Install librdmacm.dll as a 
	Winsock provider</span></li>
	<li><span style="font-family: Times New Roman">Enable the Rsockets Helper 
	service (Rsock) which enables rnetstat to collect and display Rsocket 
	connections.</span></li>
</ol>
<p><span style="font-family: Times New Roman">If the winOFED 'Rsockets Service 
Enabled' feature is not selected, then Rsockets can be started using the 
following manual install instructions.</span></p>
<p><span style="font-family: Times New Roman">Manual/cmd-line installation of 
Rsockets:</span></p>
<ol>
	<li><span style="font-family: Times New Roman">Install a Winsock provider (i.e. registration of the librdmacm.dll in 
the Windows Registry) can be done with the 'rsinstall -i' tool which works 
similar to wsdinstall for the WSD Winsock provider.<br>For a list of available options, invoke rsinstall.exe without parameters. (Note 
that rsinstall.exe requires administrative privileges to run properly!)</span></li>
</ol>
<p><span style="font-family: Times New Roman">The commandline tool rnetstat.exe can be used for displaying all currently 
active Rsocket connections (see ulp/librdmacm/tools/rnetstat).<br>'rnetstat.exe' tool requires the RSocket Helper Service rsocksvc.exe to be 
installed first by performing the following command: 'rsocksvc.exe -install'<br>
<br><br>USAGE<br>=====<br>Usage of the Rsocket provider at application level is quite simple, as 
demonstrated by the rstream tool (see ulp/librdmacm/examples/rstream) which is 
also a porting from Linux OFED.<br>
In contrast to a 'normal' Winsock application 
there are just two essential differences:<br><br>- The ulp\librdmacm\include\rdma\rwinsock.h header has to be included instead of 
winsock2.h. (Nonetheless it's still necessary to call WSAStartup() and 
WSACleanup() during initialization and shutdown of your application, 
respectivily).<br><br>- Instead of calling socket() for socket creation, a WSASocket() has to be 
performed with a WSAPROTOCOL_INFO structure selecting the appropriate<br>Winsock provider. For convenience there is a little helper function 'rsGetProtocolInfo()' 
implemented in rwinsock.h which provides this structure based on the provider's 
GUID (static variable 'rsProviderGuid' which is also contained in rwinsock.h).<br>
<br><br>RESTRICTIONS<br>============<br>Generally the same restrictions for socket applications as described 
in the Linux RSockets man page (e.g. no UDP / SOCK_DGRAM) apply to Windows 
Rsockets.<br>Additionally the following restrictions apply:<br><br>- The MSG_DONTWAIT flag is not supported when calling WSASocket().&nbsp; Instead 
to configure a socket for non-blocking operation, ioctlsocket(FIONBIO) can be 
used.<br><br>- Overlapped operation is currently not supported, i.e. a WSASocket() with the 
WSA_FLAG_OVERLAPPED flag set will be rejected with a WSAEINVAL error.<br><br>- The WSAPoll() function (in Windows Vista and later) is not supported, hence 
the select() function has to be used instead.<br><br>- IPv6 should work, but has not been tested yet.<br>&nbsp;</span></p>
<p><font face="Arial">
<span style="font-size: 12pt; ">
<span style="font-size: 12pt; ">
<a href="#TOP"><font color="#000000">&lt;</font></a></span><a href="#TOP"><font color="#000000"><b>return-to-top</b><span style="font-size: 12pt; ">&gt;</span></font></a></span></p>



