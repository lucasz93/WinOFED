/*
 * Copyright (c) 2005 SilverStorm Technologies.  All rights reserved.
 * Copyright (c) 2006 Mellanox Technologies.  All rights reserved.
 *
 * This software is available to you under the OpenIB.org BSD license
 * below:
 *
 *     Redistribution and use in source and binary forms, with or
 *     without modification, are permitted provided that the following
 *     conditions are met:
 *
 *      - Redistributions of source code must retain the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer.
 *
 *      - Redistributions in binary form must reproduce the above
 *        copyright notice, this list of conditions and the following
 *        disclaimer in the documentation and/or other materials
 *        provided with the distribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



/*
 * Implemenation of all PnP functionality for FDO (power policy owners).
 */

#include <precomp.h>

#include <initguid.h>
#include "rdma/verbs.h"
#include "iba/ib_ci_ifc.h"
#include "iba/ib_cm_ifc.h"
#include "iba\ibat_ifc.h"

/* Interface names are generated by IoRegisterDeviceInterface. */
static UNICODE_STRING	al_ifc_name;
static UNICODE_STRING	ci_ifc_name;
static UNICODE_STRING	cm_ifc_name;

KEVENT					g_ControlEvent;
ULONG					g_bfi_InstanceCount;
bus_filter_t			g_bus_filters[MAX_BUS_FILTERS];

extern PDEVICE_OBJECT	g_ControlDeviceObject;
extern UNICODE_STRING	g_CDO_dev_name, g_CDO_dos_name;
static UNICODE_STRING   g_IbatDosName;
ET_POST_EVENT 			g_post_event_func = NULL;


void
ioc_pnp_request_ioc_rescan(void);

static NTSTATUS
fdo_start(
	IN					DEVICE_OBJECT* const	p_dev_obj,
	IN					IRP* const				p_irp, 
		OUT				cl_irp_action_t* const	p_action );

static void
fdo_stop_device(
	IN					DEVICE_OBJECT* const	p_dev_obj );

NTSTATUS
fdo_remove_device(
	IN				DEVICE_OBJECT* const		p_dev_obj,
	IN				IRP* const					p_irp, 
		OUT			cl_irp_action_t* const		p_action );

static NTSTATUS
fdo_query_remove(
	IN					DEVICE_OBJECT* const	p_dev_obj,
	IN					IRP* const				p_irp, 
		OUT				cl_irp_action_t* const	p_action );

static NTSTATUS
fdo_query_capabilities(
	IN					DEVICE_OBJECT* const	p_dev_obj,
	IN					IRP* const				p_irp, 
		OUT				cl_irp_action_t* const	p_action );

static NTSTATUS
fdo_query_bus_relations(
	IN					DEVICE_OBJECT* const	p_dev_obj,
	IN					IRP* const				p_irp, 
		OUT				cl_irp_action_t* const	p_action );

static NTSTATUS
__query_al_ifc(
	IN				DEVICE_OBJECT* const		p_dev_obj,
	IN				IO_STACK_LOCATION* const	p_io_stack );

static NTSTATUS
__get_relations(
	IN		const	net64_t						ca_guid,
	IN				IRP* const					p_irp );

static NTSTATUS
__query_ci_ifc(
	IN				DEVICE_OBJECT* const		p_dev_obj,
	IN				IO_STACK_LOCATION* const	p_io_stack );

static NTSTATUS
__query_cm_ifc(
	IN				DEVICE_OBJECT* const		p_dev_obj,
	IN				IO_STACK_LOCATION* const	p_io_stack );

static NTSTATUS
fdo_query_pnp_state(
	IN				DEVICE_OBJECT* const		p_dev_obj,
	IN				IRP* const					p_irp, 
		OUT			cl_irp_action_t* const		p_action );


static NTSTATUS
fdo_query_interface(
	IN				DEVICE_OBJECT* const		p_dev_obj,
	IN				IRP* const					p_irp, 
		OUT			cl_irp_action_t* const		p_action );

static NTSTATUS
__fdo_query_power(
	IN				DEVICE_OBJECT* const		p_dev_obj,
	IN				IRP* const					p_irp,
		OUT			cl_irp_action_t* const		p_action );

static NTSTATUS
__fdo_set_power(
	IN				DEVICE_OBJECT* const		p_dev_obj,
	IN				IRP* const					p_irp,
		OUT			cl_irp_action_t* const		p_action );

static void
__set_ifc(
		OUT			ib_al_ifc_t* const			p_ifc );




/* Global virtual function pointer tables shared between all instances of FDO. */
static const cl_vfptr_pnp_po_t		vfptr_fdo_pnp = {
	"IB Bus",
	fdo_start,
	cl_irp_skip,
	cl_irp_skip,
	cl_do_sync_pnp,
	fdo_query_remove,
	fdo_stop_device,
	fdo_remove_device,
	cl_do_sync_pnp,
	cl_irp_skip,
	fdo_query_capabilities,
	fdo_query_pnp_state,
	cl_irp_skip,
	cl_do_sync_pnp,
	fdo_query_bus_relations,
	cl_irp_ignore,
	cl_irp_skip,
	cl_irp_ignore,
	cl_irp_ignore,
	cl_irp_ignore,
	cl_irp_ignore,
	cl_irp_ignore,
	fdo_query_interface,	/* QueryInterface */
	cl_irp_ignore,
	cl_irp_ignore,
	cl_irp_ignore,
	cl_irp_ignore,
	__fdo_query_power,		/* QueryPower */
	__fdo_set_power,		/* SetPower */
	cl_irp_ignore,			/* PowerSequence */
	cl_irp_ignore			/* WaitWake */
};


NTSTATUS
bus_add_device(
	IN				DRIVER_OBJECT				*p_driver_obj,
	IN				DEVICE_OBJECT				*p_pdo )
{
	NTSTATUS		status;
	DEVICE_OBJECT	*p_dev_obj, *p_next_do;
	bus_fdo_ext_t	*p_ext=NULL;
	bus_filter_t	*p_bfi;
	int				ic;

	BUS_ENTER( BUS_DBG_PNP );

	/* allocate a Bus Filter Instance */
	p_bfi = alloc_bfi( p_driver_obj, &ic );
	if ( !p_bfi )
	{
		BUS_TRACE_EXIT( BUS_DBG_PNP,
			("%s() Err - Exceeded MAX_BUS_FILTERS(%d)\n",MAX_BUS_FILTERS));
		return STATUS_UNSUCCESSFUL;
	}

	/* Create the FDO device object to attach to the stack. */
	status = IoCreateDevice( p_driver_obj, sizeof(bus_fdo_ext_t),
							 NULL, FILE_DEVICE_BUS_EXTENDER,
							 FILE_DEVICE_SECURE_OPEN, FALSE, &p_dev_obj );
	if( !NT_SUCCESS(status) )
	{
		BUS_PRINT( BUS_DBG_ERROR, 
			("Failed to create bus root FDO device.\n") );
		goto err1;
	}

	p_ext = p_dev_obj->DeviceExtension;
	cl_memclr( p_ext, sizeof(bus_fdo_ext_t) );
	p_ext->p_driver_obj = p_driver_obj;
	KeInitializeEvent(&p_ext->exit_event, SynchronizationEvent, FALSE);

	p_next_do = IoAttachDeviceToDeviceStack( p_dev_obj, p_pdo );
	if( !p_next_do )
	{
		BUS_PRINT( BUS_DBG_ERROR, ("IoAttachToDeviceStack failed.\n") );
		status = STATUS_NO_SUCH_DEVICE;
		goto err2;
	}

	cl_init_pnp_po_ext( p_dev_obj, p_next_do, p_pdo, bus_globals.dbg_lvl,
						&vfptr_fdo_pnp, NULL );

	p_bfi->p_bus_ext = p_ext;
	p_ext->bus_filter = p_bfi;

	/*
	 * if not 1st Bus Filter Instance, then finished...
	 */
	if ( ic > 1 )
		goto adxit;

	/* Register the upper interface (the one used by clients). */
	status = IoRegisterDeviceInterface( p_pdo, &GUID_IB_AL_INTERFACE, NULL,
										&al_ifc_name );
	if( !NT_SUCCESS( status ) )
	{
		BUS_PRINT( BUS_DBG_ERROR, 
			("IoRegisterDeviceInterface for upper interface returned %08x\n",
			status) );
		status = STATUS_NO_SUCH_DEVICE;
		goto err3;
	}

	/* Register the lower (CI) interface (the one used by HCA VPDs). */
	status = IoRegisterDeviceInterface( p_pdo, &GUID_IB_CI_INTERFACE, NULL,
										&ci_ifc_name );
	if( !NT_SUCCESS( status ) )
	{
		BUS_PRINT( BUS_DBG_ERROR, 
			("IoRegisterDeviceInterface for lower interface returned %08x\n",
			status) );
		status = STATUS_NO_SUCH_DEVICE;
		goto err3;
	}

	status = IoRegisterDeviceInterface( p_pdo, &GUID_INFINIBAND_INTERFACE_CM, NULL,
										&cm_ifc_name );
	if( !NT_SUCCESS( status ) )
	{
		BUS_PRINT( BUS_DBG_ERROR, 
			("IoRegisterDeviceInterface for cm interface returned %08x\n",
			status) );
		status = STATUS_NO_SUCH_DEVICE;
		goto err3;
	}

adxit:
	BUS_PRINT( BUS_DBG_PNP, ("%s exit status 0\n", p_bfi->whoami) );

	BUS_EXIT( BUS_DBG_PNP );
	return STATUS_SUCCESS;

err3:
	IoDetachDevice( p_ext->cl_ext.p_next_do );
err2:
	IoDeleteDevice( p_dev_obj );
err1:
	BUS_PRINT( BUS_DBG_PNP, ("%s exit status 0x%x\n", p_bfi->whoami,status) );
	ic = free_bfi(p_bfi);
	BUS_EXIT( BUS_DBG_PNP );
	return status;
}

NTSTATUS
fdo_remove_device(
	IN				DEVICE_OBJECT* const		p_dev_obj,
	IN				IRP* const					p_irp, 
		OUT			cl_irp_action_t* const		p_action )
{
	NTSTATUS			status;
	cl_pnp_po_ext_t	*p_cl_ext;
	bus_fdo_ext_t	*p_ext;
	int				ic;
	bus_filter_t	*p_bfi;

	BUS_ENTER( BUS_DBG_PNP );
	BUS_TRACE( BUS_DBG_ERROR, ("fdo_remove_device\n") );

	p_ext = p_dev_obj->DeviceExtension;
	p_cl_ext = &p_ext->cl_ext;
	ic = get_bfi_count();
	p_bfi = p_ext->bus_filter;
	CL_ASSERT( p_bfi );

	/* Wait for all I/O operations to complete. */
	IoReleaseRemoveLockAndWait( &p_cl_ext->remove_lock, p_irp );

	/* Release resources if it was not done yet. */
	if( p_cl_ext->last_pnp_state != SurpriseRemoved &&
		p_cl_ext->last_pnp_state != Stopped )
	{
		fdo_stop_device( p_dev_obj );
	}

	if ( ic == 1 )
	{
		/* Release the memory allocated for the interface symbolic names. */
		RtlFreeUnicodeString( &cm_ifc_name );
		RtlFreeUnicodeString( &ci_ifc_name );
		RtlFreeUnicodeString( &al_ifc_name );
	}

	/* Set the IRP status. */
	p_irp->IoStatus.Status = STATUS_SUCCESS;

	/* Pass the IRP down. */
	IoSkipCurrentIrpStackLocation( p_irp );
	status = IoCallDriver( p_cl_ext->p_next_do, p_irp );
	*p_action = IrpDoNothing;

	BUS_TRACE( BUS_DBG_PNP, ("Releasing BusFilter %s\n", p_bfi->whoami ));
	if (p_bfi) {
		free_bfi( p_bfi );
		p_ext->bus_filter = NULL;
		p_bfi->p_bus_ext = NULL;
	}

	/* Detach and destroy the device. */
	IoDetachDevice( p_cl_ext->p_next_do );
	IoDeleteDevice( p_dev_obj );

	BUS_EXIT( BUS_DBG_PNP );
	return status;
}

/* Forwards the request to the HCA's FDO. */
static NTSTATUS
__get_ifc(
	IN				DEVICE_OBJECT* const		pDevObj,
	IN		const	GUID* const					pGuid,
	IN				USHORT						size,
	IN				USHORT						Version,
	IN OUT			PVOID						InterfaceSpecificData,
		OUT			PINTERFACE					pHcaIfc )
{
	NTSTATUS			status;
	IRP					*pIrp;
	IO_STATUS_BLOCK		ioStatus;
	IO_STACK_LOCATION	*pIoStack;
	DEVICE_OBJECT		*pDev;
	KEVENT				event;

	BUS_ENTER( BUS_DBG_PNP );

	CL_ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

	pDev = IoGetAttachedDeviceReference( pDevObj );

	KeInitializeEvent( &event, NotificationEvent, FALSE );

	/* Build the IRP for the HCA. */
	pIrp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP, pDev,
		NULL, 0, NULL, &event, &ioStatus );
	if( !pIrp )
	{
		ObDereferenceObject( pDev );
		BUS_PRINT( BUS_DBG_PNP, 
			("IoBuildSynchronousFsdRequest failed.\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	/* Copy the request query parameters. */
	pIoStack = IoGetNextIrpStackLocation( pIrp );
	pIoStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
	pIoStack->Parameters.QueryInterface.Size = size;
	pIoStack->Parameters.QueryInterface.Version = Version;
	pIoStack->Parameters.QueryInterface.InterfaceType = pGuid;
	pIoStack->Parameters.QueryInterface.Interface = (INTERFACE*)pHcaIfc;
	pIoStack->Parameters.QueryInterface.InterfaceSpecificData = InterfaceSpecificData;

	pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

	/* Send the IRP. */
	status = IoCallDriver( pDev, pIrp );
	if( status == STATUS_PENDING )
	{
		KeWaitForSingleObject( &event, Executive, KernelMode,
			FALSE, NULL );

		status = ioStatus.Status;
	}
	ObDereferenceObject( pDev );
    
    if( NT_SUCCESS( status ) )
    {
        if( Version != pHcaIfc->Version )
        {
            BUS_TRACE_EXIT( BUS_DBG_ERROR, ("interface with guid 0x%I64x version mismatch: requested version=%d, returned version=%d.\n",
                *(uint64_t*)(PVOID)pGuid, Version, pHcaIfc->Version) );

            pHcaIfc->InterfaceDereference(pHcaIfc->Context);
            status = STATUS_NOT_SUPPORTED;
        }
    }

	BUS_EXIT( BUS_DBG_PNP );
	return status;
}


static NTSTATUS
__register_ca(
	IN					DEVICE_OBJECT* const	p_dev_obj
	)
{
	NTSTATUS		status;
	bus_fdo_ext_t	*p_ext;
	ib_api_status_t	ib_status;
	bus_filter_t	*p_bfi;

	BUS_ENTER( BUS_DBG_PNP );

	p_ext = p_dev_obj->DeviceExtension;
	p_bfi = p_ext->bus_filter;

	/* get HCA verbs interface */
	status = __get_ifc( p_dev_obj, &GUID_RDMA_INTERFACE_VERBS,
						sizeof(RDMA_INTERFACE_VERBS), 
						VerbsVersion(VERBS_MAJOR_VER, VERBS_MINOR_VER), 
						p_ext, (PINTERFACE)&p_ext->hca_ifc );
	if( !NT_SUCCESS( status ) ) 
	{
		BUS_TRACE_EXIT(BUS_DBG_PNP,
			("__register_ca: Getting GUID_RDMA_INTERFACE_VERBS interface failed: status=0x%x\n", status));
		return status;
	}
	else {
		BUS_TRACE(BUS_DBG_POWER,
			("__register_ca: Taken GUID_RDMA_INTERFACE_VERBS \n"));
	}
	p_ext->hca_ifc_taken = TRUE;
	g_post_event_func = p_ext->hca_ifc.post_event;
	g_post_event("Ibbus: fdo_start started \n");
    g_post_event("Ibbus: Taken GUID_RDMA_INTERFACE_VERBS\n");

	/* bind BFI to HCA by CA GUID. Have to be before ib_register_ca */
	p_bfi->ca_guid = p_ext->hca_ifc.Verbs.guid;

	/* register HCA */
	ib_status = ib_register_ca( &p_ext->hca_ifc.Verbs, p_ext->cl_ext.p_pdo, p_dev_obj );
	if( ib_status != IB_SUCCESS )
	{
		BUS_TRACE_EXIT( BUS_DBG_ERROR, ("ib_register_ca returned %s.\n",
			ib_get_err_str(ib_status)) );
		p_ext->hca_ifc.InterfaceHeader.InterfaceDereference(
			p_ext->hca_ifc.InterfaceHeader.Context);
		g_post_event("Ibbus: Released GUID_RDMA_INTERFACE_VERBS\n");
		p_ext->hca_ifc_taken = FALSE;
		
		return STATUS_UNSUCCESSFUL;
	}
	BUS_TRACE_EXIT(BUS_DBG_PNP, ("%s bound to CA guid %I64x\n",
		p_bfi->whoami,p_bfi->ca_guid));

	p_ext->ca_registered = TRUE;
	return status;
}

static NTSTATUS
fdo_start(
	IN					DEVICE_OBJECT* const	p_dev_obj,
	IN					IRP* const				p_irp, 
		OUT				cl_irp_action_t* const	p_action )
{
	NTSTATUS		status = STATUS_UNSUCCESSFUL;
	bus_fdo_ext_t	*p_ext;
	ib_api_status_t	ib_status;
	bus_filter_t	*p_bfi;
	boolean_t		AL_init_here = FALSE;
	int				ic;
	net64_t			guid;
#define IBSTR		ib_get_err_str(ib_status)	

	BUS_TRACE(BUS_DBG_ERROR, ("fdo_start\n"));

	BUS_ENTER( BUS_DBG_PNP );

	p_ext = p_dev_obj->DeviceExtension;
	p_bfi = p_ext->bus_filter;
	ASSERT( !p_ext->ca_registered );

	/* Handled on the way up. */
	status = cl_do_sync_pnp( p_dev_obj, p_irp, p_action );
	if( !NT_SUCCESS( status ) )
	{
		BUS_TRACE_EXIT( BUS_DBG_ERROR, 
			("Lower drivers failed IRP_MN_START_DEVICE.\n") );
		return status;
	}
	p_ext->device_power_state = PowerDeviceD0;

	p_ext->p_stat = bus_st_dev_add();
	if ( p_ext->p_stat ) 
		p_ext->p_stat->p_fdo = p_ext;
	
	ic = get_bfi_count();
	lock_control_event();
	if ( !gp_async_proc_mgr ) {
		/* Initialize AL */
		ib_status = al_initialize();
		if( ib_status != IB_SUCCESS )
		{
			BUS_TRACE_EXIT( BUS_DBG_ERROR, ("al_initialize returned %s.\n",IBSTR) );
			unlock_control_event();
			goto err;
		}
		AL_init_here = TRUE;
		BUS_TRACE( BUS_DBG_PNP, ("AL initialized\n"));
		/* for debug */
		g_stat.drv.gp_async_obj_mgr = gp_async_obj_mgr;
		g_stat.drv.gp_async_proc_mgr = gp_async_proc_mgr;
		g_stat.drv.gp_async_pnp_mgr = gp_async_pnp_mgr;
		g_stat.drv.gp_al_mgr = gp_al_mgr;
		g_stat.drv.gp_obj_mgr = gp_obj_mgr;
	}
	unlock_control_event();

	/* Initialize the port manager. */
	ib_status = create_port_mgr( p_ext->bus_filter );
	if( ib_status != IB_SUCCESS )
	{
		BUS_TRACE_EXIT( BUS_DBG_ERROR, ("create_port_mgr returned %s.\n",IBSTR) );
		goto err;
	}

	/* Initialize the IOU manager. */
	ib_status = create_iou_mgr( p_ext->bus_filter );
	if( ib_status != IB_SUCCESS )
	{
		BUS_TRACE_EXIT( BUS_DBG_ERROR, ("create_iou_mgr returned %s.\n",IBSTR) );
		goto err;
	}

	/* start IBAL */
	status = __register_ca( p_dev_obj );
	if ( status == STATUS_NOT_SUPPORTED ) {
		BUS_PRINT( BUS_DBG_ERROR, ("No IB ports - IBAL is started in non-operational mode\n") );
		goto exit;
	}
	if( !NT_SUCCESS( status ) )
		goto err;

	if ( AL_init_here ) {
		status = IoSetDeviceInterfaceState( &al_ifc_name, TRUE );
		ASSERT( NT_SUCCESS( status ) );

		status = IoSetDeviceInterfaceState( &ci_ifc_name, TRUE );
		ASSERT( NT_SUCCESS( status ) );

		status = IoSetDeviceInterfaceState( &cm_ifc_name, TRUE );
		ASSERT( NT_SUCCESS( status ) );
	}

	/* get mlx4_bus notification interface */
	status = __get_ifc( p_dev_obj, &MLX4_BUS_NOTIFY_GUID,
		sizeof(MLX4_BUS_NOTIFY_INTERFACE), 1, p_ext, (PINTERFACE)&p_ext->notify_ifc );
	if( !NT_SUCCESS( status ) ) 
	{
		BUS_TRACE_EXIT(BUS_DBG_PNP,
			("Getting MLX4_BUS_NOTIFY_GUID interface failed: status=0x%x\n", status));
		goto err;
	}
	else
	{
		BUS_TRACE(BUS_DBG_POWER, ("Taken MLX4_BUS_NOTIFY_GUID interface.\n") );;
	}
	p_ext->notify_ifc_taken = TRUE;
    g_post_event("Ibbus: Taken MLX4_BUS_NOTIFY_GUID\n");

	/* report the own arrival to mlx_bus */
	p_ext->notify_ifc.notify( p_ext->notify_ifc.i.Context, 
		0, p_dev_obj, "fdo_start: IBAL has started!\n" );

	/* Initialize mcast mgr */
	ib_status = mcast_mgr_add_ca_ports( p_ext->hca_ifc.Verbs.guid );
	if( ib_status != IB_SUCCESS )
	{
		BUS_PRINT( BUS_DBG_ERROR, ("mcast_mgr_add_ca_ports failed\n") );
		goto err;
	}
	p_ext->mcast_mgr_created = TRUE;
	guid = p_ext->hca_ifc.Verbs.guid;
	
	/* if 1st Bus Filter Instance, then create device names for user ioctl */
	lock_control_event();
	if ( ic == 1  && !g_ControlDeviceObject)
	{
		RtlInitUnicodeString( &g_CDO_dev_name, AL_DEVICE_NAME );
		RtlInitUnicodeString( &g_CDO_dos_name, L"\\DosDevices\\Global\\ibal" );
        RtlInitUnicodeString( &g_IbatDosName, IBAT_DOS_DEV_NAME );
	
		status = IoCreateDevice( p_ext->p_driver_obj, sizeof(bus_fdo_ext_t),
			&g_CDO_dev_name, FILE_DEVICE_BUS_EXTENDER,
			FILE_DEVICE_SECURE_OPEN, FALSE, &g_ControlDeviceObject );
		if( !NT_SUCCESS(status) )
		{
			g_ControlDeviceObject = NULL;
			BUS_PRINT( BUS_DBG_ERROR, 
				("Failed to create ControlDeviceObject, status %x.\n",status) );
			unlock_control_event();
			goto err;
		}
		else {
			RtlZeroMemory(g_ControlDeviceObject->DeviceExtension, sizeof *p_ext);
			cl_init_pnp_po_ext( g_ControlDeviceObject, NULL, 
								NULL, bus_globals.dbg_lvl, NULL, NULL );

			/* enable user-mode access to IB stack */
			BUS_PRINT( BUS_DBG_PNP, ("Remove-n-reCreate dos_name symlink\n") );
			IoDeleteSymbolicLink( &g_CDO_dos_name );
			status = IoCreateSymbolicLink( &g_CDO_dos_name, &g_CDO_dev_name );
			if( !NT_SUCCESS(status) )
			{
				BUS_PRINT( BUS_DBG_ERROR,
					("Failed to create symlink for dos name.\n") );
				IoDeleteDevice( g_ControlDeviceObject );
				g_ControlDeviceObject = NULL;
				unlock_control_event();
				goto err;
			}

            /* Route IBAT IOCTLs to the same device object as IBAL. */
            IoDeleteSymbolicLink( &g_IbatDosName );
            status = IoCreateSymbolicLink( &g_IbatDosName, &g_CDO_dev_name );
            if( !NT_SUCCESS(status) )
            {
                BUS_PRINT( BUS_DBG_ERROR,
                    ("Failed to create symlink for IBAT dos name.\n") );
                IoDeleteDevice( g_ControlDeviceObject );
                g_ControlDeviceObject = NULL;
                unlock_control_event();
                goto err;
            }
			BUS_TRACE( BUS_DBG_PNP, ("Created dos_name symlink\n") );
		}
	}
	unlock_control_event();

	status = fip_fdo_start(p_dev_obj, guid);
	if( !NT_SUCCESS(status) )
	{
		BUS_PRINT( BUS_DBG_ERROR, ("fip_fdo_start failed\n") );
		goto err;
	}
	p_ext->fip_started = TRUE;

exit:
	p_ext->fdo_started = TRUE;
	bus_globals.started++;
	g_post_event("Ibbus: fdo_start ended with status 0 \n");

	// temporary
	BUS_TRACE( BUS_DBG_ERROR, ("IBBUS started \n") );
	CL_PRINT_TO_EVENT_LOG( p_dev_obj, EVENT_IBBUS_ANY_INFO, ("IBBUS started \n" ));
	return STATUS_SUCCESS;
	
err:
	g_post_event("Ibbus: fdo_start ended with status %#x\n", status);
	CL_ASSERT(p_ext->fdo_started == FALSE);
	bus_globals.started++;
	p_ext->fdo_started = TRUE;
	fdo_stop_device(p_dev_obj);
	CL_ASSERT(p_ext->fdo_started == FALSE);
	BUS_TRACE( BUS_DBG_DRV, ("IBBUS failed \n") );
	CL_PRINT_TO_EVENT_LOG( p_dev_obj, EVENT_IBBUS_ANY_INFO, ("IBBUS failed \n" ));
	return status;
}


static NTSTATUS
fdo_query_remove(
	IN					DEVICE_OBJECT* const	p_dev_obj,
	IN					IRP* const				p_irp, 
		OUT				cl_irp_action_t* const	p_action )
{
	bus_fdo_ext_t	*p_ext;

	BUS_ENTER( BUS_DBG_PNP );

	p_ext = p_dev_obj->DeviceExtension;

	CL_ASSERT(p_ext->bus_filter);
	BUS_PRINT( BUS_DBG_PNP,
		("IRP_MN_QUERY_REMOVE_DEVICE %s @ FDO %p refs(CI %d AL %d)\n"
		"   %s CA %I64x\n", 
		p_ext->cl_ext.vfptr_pnp_po->identity, p_ext, p_ext->n_ci_ifc_ref,
		p_ext->n_al_ifc_ref,
		p_ext->bus_filter->whoami, p_ext->bus_filter->ca_guid) );

	if( p_ext->n_ci_ifc_ref )
	{
		/*
		 * Our interface is still being held by someone.
		 * Rollback the PnP state that was changed in the cl_ext handler.
		 */
		cl_rollback_pnp_state( &p_ext->cl_ext );

		/* Fail the query. */
		*p_action = IrpComplete;
		BUS_TRACE_EXIT( BUS_DBG_PNP, 
			("Failing IRP_MN_QUERY_REMOVE_DEVICE:\n"
			"\tLowerInterface has %d references\n", 
			p_ext->n_ci_ifc_ref ) );
		return STATUS_UNSUCCESSFUL;
	}

	/* remove port & iou managers */	
	CL_ASSERT( p_ext->bus_filter );

	//TODO: Fail outstanding I/O operations.

	*p_action = IrpSkip;
	/* The FDO driver must set the status even when passing down. */
	p_irp->IoStatus.Status = STATUS_SUCCESS;

	BUS_EXIT( BUS_DBG_PNP );
	return STATUS_SUCCESS;
}


static void
__deregister_ca(
	IN					DEVICE_OBJECT* const	p_dev_obj )
{
	bus_fdo_ext_t	*p_ext;
	bus_filter_t	*p_bfi;
	ib_api_status_t	ib_status;

	BUS_ENTER( BUS_DBG_PNP );

	p_ext = p_dev_obj->DeviceExtension;
	p_bfi = p_ext->bus_filter;

	if ( !p_ext->ca_registered )
		return;
	p_ext->ca_registered = FALSE;

	//TODO: Fail outstanding I/O operations.

	ib_status = ib_deregister_ca( p_ext->hca_ifc.Verbs.guid );
	if( ib_status != IB_SUCCESS ) {
		BUS_PRINT( BUS_DBG_ERROR, ("ib_deregister_ca returned %s.\n",
			ib_get_err_str(ib_status)) );
	}

	if ( p_ext->hca_ifc_taken ) {
		p_ext->hca_ifc.InterfaceHeader.InterfaceDereference(
			p_ext->hca_ifc.InterfaceHeader.Context);
		g_post_event("Ibbus: Released GUID_RDMA_INTERFACE_VERBS\n");
		p_ext->hca_ifc_taken = FALSE;
		BUS_TRACE(BUS_DBG_POWER,
			("__deregister_ca: Released GUID_RDMA_INTERFACE_VERBS interface \n"));
	}

	BUS_EXIT( BUS_DBG_PNP );
}

static void 
__wait_for_clients_to_exit(bus_fdo_ext_t *p_ext)
{
	LARGE_INTEGER  *p_timemout = NULL;
	NTSTATUS status;

#if defined(_DEBUG_)
	int i=0;
	LARGE_INTEGER  timeout;
	
	timeout.QuadPart = -10000000;	/* 1 sec */
	p_timemout = &timeout;
#endif

	BUS_PRINT(BUS_DBG_POWER, ("ibbus: Waiting for clients to exit: n_al_ifc_ref %d, n_ci_ifc_ref %d, n_cm_ifc_ref %d \n", 
			p_ext->n_al_ifc_ref, p_ext->n_ci_ifc_ref, p_ext->n_cm_ifc_ref));

	while ( p_ext->n_ifc_ref > 0 )
	{
		status = KeWaitForSingleObject(&p_ext->exit_event, Executive, KernelMode, FALSE, p_timemout);
		if ( status == STATUS_SUCCESS ) {
			if ( p_ext->n_ifc_ref <= 0 )
				break;
			else {
				BUS_PRINT(BUS_DBG_POWER, ("Unexpected end of wait: n_ifc_ref %d \n", p_ext->n_ifc_ref));
				continue;
			}
		}
		if ( status != STATUS_TIMEOUT )
			continue;
		BUS_PRINT(BUS_DBG_POWER, ("Waiting for clients to exit (%d sec): n_al_ifc_ref %d, n_ci_ifc_ref %d, n_cm_ifc_ref %d \n", 
				++i, p_ext->n_al_ifc_ref, p_ext->n_ci_ifc_ref, p_ext->n_cm_ifc_ref));
	}
	ASSERT(p_ext->n_al_ifc_ref <= 0 && p_ext->n_ci_ifc_ref <= 0 && p_ext->n_cm_ifc_ref <= 0);
	#if DBG
	if (i > 100)
		ASSERT(0);
	#endif
}


/*
 * This function gets called after releasing the remove lock and waiting
 * for all other threads to release the lock.  No more modifications will
 * occur to the PDO pointer vectors.
 */
static void
fdo_stop_device(
	IN					DEVICE_OBJECT* const	p_dev_obj )
{
	bus_fdo_ext_t	*p_ext;
	bus_filter_t	*p_bfi;
	int				ic;
	PBUS_ST_DEVICE 	p_stat;
	NTSTATUS		status;
	ib_api_status_t	ib_status;

	BUS_ENTER( BUS_DBG_PNP );
	BUS_TRACE(BUS_DBG_ERROR,("fdo_stop_device\n"));
	g_post_event("Ibbus: fdo_stop_device started\n");

	// fdo_start failed with error "Lower drivers failed IRP_MN_START_DEVICE"
	// TODO: review error flow of fdo_start

	p_ext = p_dev_obj->DeviceExtension;
	if( p_ext->fdo_started == FALSE)
	{
		return;
	}

	bus_globals.started--;
	p_ext->fdo_started = FALSE;

	if(p_ext->fip_started) {
		fip_fdo_stop_device(p_dev_obj, p_ext->hca_ifc.Verbs.guid);
		p_ext->fip_started = FALSE;
	}

	ic = get_bfi_count();
	p_stat = p_ext->p_stat;

	p_bfi = p_ext->bus_filter;
	CL_ASSERT( p_bfi );

	/* Close mcast mgr */
	if (p_ext->mcast_mgr_created)
		ib_status = mcast_mgr_remove_ca_ports( p_ext->hca_ifc.Verbs.guid );
	
	/* the last instance - remove IBAL device  */
	lock_control_event();
 	if ( ic == 1 && g_ControlDeviceObject )
	{
		IoDeleteSymbolicLink( &g_CDO_dos_name );
		IoDeleteSymbolicLink( &g_IbatDosName );
		IoDeleteDevice(g_ControlDeviceObject);
		g_ControlDeviceObject = NULL; 
	}

	/* remove notify interface */
	if ( p_ext->notify_ifc_taken ) {
		p_ext->notify_ifc.i.InterfaceDereference(
			p_ext->notify_ifc.i.Context);
		g_post_event("Ibbus: Released MLX4_BUS_NOTIFY_GUID\n");
		p_ext->notify_ifc_taken = FALSE;
		BUS_TRACE(BUS_DBG_POWER, ("Released MLX4_BUS_NOTIFY_GUID interface.\n") );
	}

	__wait_for_clients_to_exit(p_ext);

	if ( ic == 1 )
	{
		/* Disable any exported interfaces. */
		status = IoSetDeviceInterfaceState( &al_ifc_name, FALSE );
		ASSERT( NT_SUCCESS( status ) );
		status = IoSetDeviceInterfaceState( &ci_ifc_name, FALSE );
		ASSERT( NT_SUCCESS( status ) );
		status = IoSetDeviceInterfaceState( &cm_ifc_name, FALSE );
		ASSERT( NT_SUCCESS( status ) );
	}
	unlock_control_event();

	/* close HCA */
	__deregister_ca( p_dev_obj );

	/* remove children managers */
	if ( p_bfi->p_port_mgr )
		cl_obj_destroy( p_bfi->p_port_mgr_obj );

	if ( p_bfi->p_iou_mgr )
	 	cl_obj_destroy( p_bfi->p_iou_mgr_obj );

	/* the last time - de-init IBAL   */
	lock_control_event();
	if ( ic == 1 ) 
	{
		al_cleanup();
		cl_thread_suspend(50);	/* allow time for AL's async procs to run to exit */
		
		CL_ASSERT( !gp_async_proc_mgr && !gp_async_pnp_mgr && !gp_al_mgr );
	}
	else
		BUS_TRACE( BUS_DBG_PNP, ("%d remaining BusFilters\n", ic ));
	unlock_control_event();

	bus_st_dev_rmv( p_stat );
	BUS_TRACE_EXIT( BUS_DBG_PNP, 
		("=====> IBBUS: fdo_stop_device exited \n") );
	g_post_event("Ibbus: fdo_stop_device ended\n");
}


static NTSTATUS
fdo_query_capabilities(
	IN					DEVICE_OBJECT* const	p_dev_obj,
	IN					IRP* const				p_irp, 
		OUT				cl_irp_action_t* const	p_action )
{
	NTSTATUS			status;
	bus_fdo_ext_t		*p_ext;
	IO_STACK_LOCATION	*p_io_stack;

	BUS_ENTER( BUS_DBG_PNP );

	p_ext = p_dev_obj->DeviceExtension;

	/* Process on the way up. */
	status = cl_do_sync_pnp( p_dev_obj, p_irp, p_action );

	if( !NT_SUCCESS( status ) )
	{
		BUS_TRACE_EXIT( BUS_DBG_ERROR, 
			("cl_do_sync_pnp returned %08x.\n", status) );
		return status;
	}

	p_io_stack = IoGetCurrentIrpStackLocation( p_irp );

	/*
	 * Store the device power maping into our extension since we're
	 * the power policy owner.  The mapping is used when handling
	 * IRP_MN_SET_POWER IRPs.
	 */
	cl_memcpy( p_ext->po_state, 
		p_io_stack->Parameters.DeviceCapabilities.Capabilities->DeviceState,
		sizeof( p_ext->po_state ) );

	BUS_EXIT( BUS_DBG_PNP );
	return status;
}


static NTSTATUS
fdo_query_bus_relations(
	IN					DEVICE_OBJECT* const	p_dev_obj,
	IN					IRP* const				p_irp, 
		OUT				cl_irp_action_t* const	p_action )
{
	NTSTATUS			status = STATUS_SUCCESS; /*default to success*/
	bus_fdo_ext_t		*p_ext;
	bus_filter_t		*p_bfi;
	int					waitLoop = 0;

	BUS_ENTER( BUS_DBG_PNP );

	p_ext = p_dev_obj->DeviceExtension;

	if ( !p_ext->bus_filter )
	{
		/* BFI has already been released */
		*p_action = IrpComplete;
		BUS_TRACE_EXIT( BUS_DBG_PNP, ("NULL BFI\n") );
		return STATUS_SUCCESS;
	}

	p_bfi = p_ext->bus_filter;
	CL_ASSERT( p_bfi->magic == BFI_MAGIC );

	while ( p_bfi->ca_guid == 0ULL )
	{
		/* HCA not yet bound to a BFI slot (no PNP ADD event seen), no bus
		 * relations yet.
		 */
		BUS_PRINT(BUS_DBG_PNP, ("%s ca_guid %I64x\n",p_bfi->whoami,
								p_bfi->ca_guid));
		cl_thread_suspend( 100 );	/* suspend for 100 ms */
		waitLoop++;
		if(waitLoop>50) break;
	}
	if ( p_bfi->ca_guid != 0ULL )
	{
		if ( g_ioc_poll_interval == 1 && p_bfi->p_port_mgr->active_ports &&
			p_bfi->p_bus_ext && p_bfi->p_bus_ext->cl_ext.vfptr_pnp_po->identity &&
			strcmp(p_bfi->p_bus_ext->cl_ext.vfptr_pnp_po->identity, "IB Bus") == 0 )
		{
			BUS_PRINT(BUS_DBG_PNP, ("**** device '%s' requesting IOC rescan\n",
					p_bfi->p_bus_ext->cl_ext.vfptr_pnp_po->identity) );
			ioc_pnp_request_ioc_rescan();
		}

		status = port_mgr_get_bus_relations( p_bfi, p_irp );

		if( status == STATUS_SUCCESS || 
			status == STATUS_NO_SUCH_DEVICE )
		{
			status = iou_mgr_get_bus_relations( p_bfi, p_irp );
		}
		if( status == STATUS_NO_SUCH_DEVICE )
			status = STATUS_SUCCESS;
	}

	switch( status )
	{
	case STATUS_NO_SUCH_DEVICE:
		*p_action = IrpSkip;
		status = STATUS_SUCCESS;
		break;

	case STATUS_SUCCESS:
		*p_action = IrpPassDown;
		break;

	default:
		*p_action = IrpComplete;
		break;
	}

	BUS_EXIT( BUS_DBG_PNP );
	return status;
}


void
al_ref_ifc(
	IN				DEVICE_OBJECT*				p_dev_obj )
{
	bus_fdo_ext_t	*p_ext;

	BUS_ENTER( BUS_DBG_PNP );

	p_ext = p_dev_obj->DeviceExtension;

	CL_ASSERT( p_ext->n_al_ifc_ref >= 0 );

	cl_atomic_inc( &p_ext->n_al_ifc_ref );
	cl_atomic_inc( &p_ext->n_ifc_ref );
	ObReferenceObject( p_dev_obj );

	BUS_TRACE(BUS_DBG_POWER,
		("IBBUS: Acquired interface 'GUID_IB_AL_INTERFACE', n_al_ifc_ref %d\n",
		p_ext->n_al_ifc_ref) );

	BUS_EXIT( BUS_DBG_PNP );
}


void
al_deref_ifc(
	IN				DEVICE_OBJECT*				p_dev_obj )
{
	bus_fdo_ext_t	*p_ext;
	int ref_cnt;

	BUS_ENTER( BUS_DBG_PNP );

	p_ext = p_dev_obj->DeviceExtension;

	CL_ASSERT( p_ext->n_al_ifc_ref > 0 );
	cl_atomic_dec( &p_ext->n_al_ifc_ref );
	BUS_TRACE(BUS_DBG_POWER,
		("IBBUS: Released interface 'GUID_IB_AL_INTERFACE', n_al_ifc_ref %d\n",
		p_ext->n_al_ifc_ref) );

	ref_cnt = cl_atomic_dec( &p_ext->n_ifc_ref );
	ObDereferenceObject( p_dev_obj );
	if ( ref_cnt <= 0 )
		KeSetEvent(&p_ext->exit_event, 0, FALSE);

	BUS_EXIT( BUS_DBG_PNP );
}


void
al_ref_ci_ifc(
	IN				DEVICE_OBJECT*				p_dev_obj )
{
	bus_fdo_ext_t	*p_ext;

	BUS_ENTER( BUS_DBG_PNP );

	p_ext = p_dev_obj->DeviceExtension;

	CL_ASSERT( p_ext->n_ci_ifc_ref >= 0 );
	cl_atomic_inc( &p_ext->n_ci_ifc_ref );
	cl_atomic_inc( &p_ext->n_ifc_ref );
	ObReferenceObject( p_dev_obj );

	BUS_TRACE(BUS_DBG_POWER,
		("IBBUS: Acquired interface 'GUID_IB_CI_INTERFACE', n_ci_ifc_ref %d\n",
		p_ext->n_ci_ifc_ref) );

	BUS_EXIT( BUS_DBG_PNP );
}


void
al_deref_ci_ifc(
	IN				DEVICE_OBJECT*				p_dev_obj )
{
	bus_fdo_ext_t	*p_ext;
	int ref_cnt;

	BUS_ENTER( BUS_DBG_PNP );

	p_ext = p_dev_obj->DeviceExtension;

	CL_ASSERT( p_ext->n_ci_ifc_ref > 0 );

	cl_atomic_dec( &p_ext->n_ci_ifc_ref );
	BUS_TRACE(BUS_DBG_POWER,
		("IBBUS: Released interface 'GUID_IB_CI_INTERFACE', n_ci_ifc_ref %d\n",
		p_ext->n_ci_ifc_ref) );

	ref_cnt = cl_atomic_dec( &p_ext->n_ifc_ref );
	ObDereferenceObject( p_dev_obj );
	if ( ref_cnt <= 0 )
		KeSetEvent(&p_ext->exit_event, 0, FALSE);

	BUS_EXIT( BUS_DBG_PNP );
}


void
al_ref_cm_ifc(
	IN				DEVICE_OBJECT*				p_dev_obj )
{
	bus_fdo_ext_t	*p_ext;

	BUS_ENTER( BUS_DBG_PNP );

	p_ext = p_dev_obj->DeviceExtension;

	CL_ASSERT( p_ext->n_cm_ifc_ref >= 0 );
	cl_atomic_inc( &p_ext->n_cm_ifc_ref );
	cl_atomic_inc( &p_ext->n_ifc_ref );
	ObReferenceObject( p_dev_obj );

	BUS_TRACE(BUS_DBG_POWER,
		("IBBUS: Acquired interface 'GUID_INFINIBAND_INTERFACE_CM', n_cm_ifc_ref %d\n",
		p_ext->n_cm_ifc_ref) );

	BUS_EXIT( BUS_DBG_PNP );
}


void
al_deref_cm_ifc(
	IN				DEVICE_OBJECT*				p_dev_obj )
{
	bus_fdo_ext_t	*p_ext;
	int ref_cnt;

	BUS_ENTER( BUS_DBG_PNP );

	p_ext = p_dev_obj->DeviceExtension;

	CL_ASSERT( p_ext->n_cm_ifc_ref > 0 );

	cl_atomic_dec( &p_ext->n_cm_ifc_ref );
	BUS_TRACE(BUS_DBG_POWER,
		("IBBUS: Released interface 'GUID_INFINIBAND_INTERFACE_CM', n_cm_ifc_ref %d\n",
		p_ext->n_cm_ifc_ref) );

	ref_cnt = cl_atomic_dec( &p_ext->n_ifc_ref );
	ObDereferenceObject( p_dev_obj );
	if ( ref_cnt <= 0 )
		KeSetEvent(&p_ext->exit_event, 0, FALSE);

	BUS_EXIT( BUS_DBG_PNP );
}


static NTSTATUS
__query_al_ifc(
	IN					DEVICE_OBJECT* const		p_dev_obj,
	IN					IO_STACK_LOCATION* const	p_io_stack )
{
	ib_al_ifc_t		*p_ifc;
	bus_fdo_ext_t	*p_ext= p_dev_obj->DeviceExtension;

	BUS_ENTER( BUS_DBG_PNP );

	if( p_io_stack->Parameters.QueryInterface.Version != 
		AL_INTERFACE_VERSION )
	{
		BUS_TRACE_EXIT( BUS_DBG_PNP, ("Incorrect interface version (%d)\n",
			p_io_stack->Parameters.QueryInterface.Version ) );
		return STATUS_NOT_SUPPORTED;
	}

	if( p_io_stack->Parameters.QueryInterface.Size < sizeof(ib_al_ifc_t) )
	{
		BUS_TRACE_EXIT( BUS_DBG_PNP, 
			("Buffer too small (%d given, %d required).\n",
			p_io_stack->Parameters.QueryInterface.Size, sizeof(ib_al_ifc_t)) );
		return STATUS_BUFFER_TOO_SMALL;
	}

	// Copy the interface.
	p_ifc = (ib_al_ifc_t*)p_io_stack->Parameters.QueryInterface.Interface;

	p_ifc->wdm.Size = sizeof(ib_al_ifc_t);
	p_ifc->wdm.Version = AL_INTERFACE_VERSION;
	p_ifc->wdm.Context = p_dev_obj;
	p_ifc->wdm.InterfaceReference = al_ref_ifc;
	p_ifc->wdm.InterfaceDereference = al_deref_ifc;

	__set_ifc( p_ifc );
	p_ifc->ca_guid = p_ext->hca_ifc.Verbs.guid;

	// take the reference before returning.
	al_ref_ifc( p_dev_obj );
	BUS_EXIT( BUS_DBG_PNP );
	return STATUS_SUCCESS;
}

void
ib_ref_al_obj(
	IN				void * const			p_obj )
{
	ref_al_obj((al_obj_t*)p_obj);
}

void
ib_deref_al_obj(
	IN				void * const			p_obj )
{
	deref_al_obj((al_obj_t*)p_obj);
}


static void
__set_ifc(
		OUT			ib_al_ifc_t* const			p_ifc )
{
	BUS_ENTER( BUS_DBG_PNP );

	p_ifc->wdm.Size = sizeof(ib_al_ifc_t);
	p_ifc->wdm.InterfaceReference = al_ref_ifc;
	p_ifc->wdm.InterfaceDereference = al_deref_ifc;

	p_ifc->sync_destroy = ib_sync_destroy;
	p_ifc->open_ca = ib_open_ca;
	p_ifc->query_ca = ib_query_ca;
	p_ifc->modify_ca = ib_modify_ca;
	p_ifc->get_dev = get_ca_dev;
	p_ifc->close_ca = ib_close_ca;
	p_ifc->alloc_pd = ib_alloc_pd;
	p_ifc->dealloc_pd = ib_dealloc_pd;
	p_ifc->create_av = ib_create_av;
	p_ifc->query_av = ib_query_av;
	p_ifc->modify_av = ib_modify_av;
	p_ifc->destroy_av = ib_destroy_av;
	p_ifc->create_qp = ib_create_qp;
	p_ifc->get_spl_qp = ib_get_spl_qp;
	p_ifc->query_qp = ib_query_qp;
	p_ifc->modify_qp = ib_modify_qp;
	p_ifc->destroy_qp = ib_destroy_qp;
	p_ifc->create_cq = ib_create_cq;
	p_ifc->modify_cq = ib_modify_cq;
	p_ifc->query_cq = ib_query_cq;
	p_ifc->destroy_cq = ib_destroy_cq;
	p_ifc->reg_mem = ib_reg_mem;
	p_ifc->reg_phys = ib_reg_phys;
	p_ifc->query_mr = ib_query_mr;
	p_ifc->rereg_mem = ib_rereg_mem;
	p_ifc->reg_shmid = ib_reg_shmid;
	p_ifc->dereg_mr = ib_dereg_mr;
	p_ifc->create_mw = ib_create_mw;
	p_ifc->query_mw = ib_query_mw;
	p_ifc->bind_mw = ib_bind_mw;
	p_ifc->destroy_mw = ib_destroy_mw;
	p_ifc->post_send = ib_post_send;
	p_ifc->post_recv = ib_post_recv;
	p_ifc->send_mad = ib_send_mad;
	p_ifc->cancel_mad = ib_cancel_mad;
	p_ifc->poll_cq = ib_poll_cq;
	p_ifc->rearm_cq = ib_rearm_cq;
	p_ifc->join_mcast = ib_join_mcast;
	p_ifc->join_mcast_no_qp	= al_join_mcast_no_qp;
	p_ifc->leave_mcast = ib_leave_mcast;
	p_ifc->local_mad = ib_local_mad;
	p_ifc->cm_listen = ib_cm_listen;
	p_ifc->cm_cancel = ib_cm_cancel;
	p_ifc->cm_req = ib_cm_req;
	p_ifc->cm_rep = ib_cm_rep;
	p_ifc->cm_rtu = ib_cm_rtu;
	p_ifc->cm_rej = ib_cm_rej;
	p_ifc->cm_mra = ib_cm_mra;
	p_ifc->cm_lap = ib_cm_lap;
	p_ifc->cm_apr = ib_cm_apr;
	p_ifc->force_apm = ib_force_apm;
	p_ifc->cm_dreq = ib_cm_dreq;
	p_ifc->cm_drep = ib_cm_drep;
	p_ifc->cm_handoff = ib_cm_handoff;
	p_ifc->create_ioc = ib_create_ioc;
	p_ifc->destroy_ioc = ib_destroy_ioc;
	p_ifc->reg_ioc = ib_reg_ioc;
	p_ifc->add_svc_entry = ib_add_svc_entry;
	p_ifc->remove_svc_entry = ib_remove_svc_entry;
	p_ifc->get_ca_guids = ib_get_ca_guids;
	p_ifc->get_ca_by_gid = ib_get_ca_by_gid;
	p_ifc->get_port_by_gid = ib_get_port_by_gid;
	p_ifc->create_mad_pool = ib_create_mad_pool;
	p_ifc->destroy_mad_pool = ib_destroy_mad_pool;
	p_ifc->reg_mad_pool = ib_reg_mad_pool;
	p_ifc->dereg_mad_pool = ib_dereg_mad_pool;
	p_ifc->get_mad = ib_get_mad_insert;
	p_ifc->put_mad = ib_put_mad_insert;
	p_ifc->init_dgrm_svc = ib_init_dgrm_svc;
	p_ifc->reg_mad_svc = ib_reg_mad_svc;
	p_ifc->reg_svc = ib_reg_svc;
	p_ifc->dereg_svc = ib_dereg_svc;
	p_ifc->query = ib_query;
	p_ifc->cancel_query = ib_cancel_query;
	p_ifc->reg_pnp = ib_reg_pnp;
	p_ifc->dereg_pnp = ib_dereg_pnp;
	p_ifc->subscribe = ib_subscribe;
	p_ifc->unsubscribe = ib_unsubscribe;
	p_ifc->reject_ioc = ib_reject_ioc;
	p_ifc->ci_call = ib_ci_call;
	p_ifc->open_al = ib_open_al;
	p_ifc->close_al = ib_close_al;
	p_ifc->get_err_str = ib_get_err_str;
	p_ifc->get_wc_status_str = ib_get_wc_status_str;
	p_ifc->create_mlnx_fmr = mlnx_create_fmr;
	p_ifc->map_phys_mlnx_fmr = mlnx_map_phys_fmr;
	p_ifc->unmap_mlnx_fmr = mlnx_unmap_fmr;
	p_ifc->destroy_mlnx_fmr = mlnx_destroy_fmr;
	p_ifc->create_mlnx_fmr_pool = mlnx_create_fmr_pool;
	p_ifc->destroy_mlnx_fmr_pool = mlnx_destroy_fmr_pool;
	p_ifc->map_phys_mlnx_fmr_pool = mlnx_map_phys_fmr_pool;
	p_ifc->unmap_mlnx_fmr_pool = mlnx_unmap_fmr_pool;
	p_ifc->flush_mlnx_fmr_pool = mlnx_flush_fmr_pool;
	p_ifc->create_srq = ib_create_srq;
	p_ifc->modify_srq = ib_modify_srq;
	p_ifc->query_srq = ib_query_srq;
	p_ifc->destroy_srq = ib_destroy_srq;
	p_ifc->post_srq_recv = ib_post_srq_recv;

	p_ifc->to_ntstatus = ib_to_ntstatus;

	p_ifc->ib_ref_al_obj = ib_ref_al_obj;
	p_ifc->ib_deref_al_obj = ib_deref_al_obj;

	p_ifc->mcast_mgr_join_mcast = mcast_mgr_join_mcast;
	p_ifc->mcast_mgr_leave_mcast = mcast_mgr_leave_mcast;
	p_ifc->mcast_mgr_cancel_join = mcast_mgr_cancel_join;
	p_ifc->mcast_mgr_request_add_ref = mcast_mgr_request_add_ref;
	p_ifc->mcast_mgr_request_release = mcast_mgr_request_release;
	
	p_ifc->open_al_trk = ib_open_al_trk;

    p_ifc->ibat_register = IbatRegister;
    p_ifc->ibat_deregister = IbatDeregister;
    p_ifc->ibat_update_reg = IbatUpdateRegistration;
    p_ifc->ibat_update_route = IbatUpdateRoute;
    p_ifc->ibat_clear_all_routes = IbatClearAllRoutes;
    p_ifc->ibat_query_path = IbatQueryPath;
    p_ifc->ibat_cancel_query = IbatCancelQuery;

	BUS_EXIT( BUS_DBG_PNP );
}


static NTSTATUS
__get_relations(
	IN		const	net64_t						ca_guid,
	IN				IRP* const					p_irp )
{
	UNUSED_PARAM( ca_guid );
	UNUSED_PARAM( p_irp );

	BUS_ENTER( BUS_DBG_PNP );

	/*
	 * Now that ibbus is in the same device stack as the HCA driver, skip
	 * returning relations here as ibbus has already done the deed.
	 * This interface remains to minimize changes to HCA drivers for now.
	 */

	BUS_EXIT( BUS_DBG_PNP );
	return STATUS_SUCCESS;
}


static NTSTATUS
__query_ci_ifc(
	IN					DEVICE_OBJECT* const		p_dev_obj,
	IN					IO_STACK_LOCATION* const	p_io_stack )
{
	ib_ci_ifc_t		*p_ifc;

	BUS_ENTER( BUS_DBG_PNP );

	if( p_io_stack->Parameters.QueryInterface.Version != 
		IB_CI_INTERFACE_VERSION )
	{
		BUS_TRACE_EXIT( BUS_DBG_PNP, ("Incorrect interface version (%d)\n",
			p_io_stack->Parameters.QueryInterface.Version ) );
		return STATUS_NOT_SUPPORTED;
	}

	if( p_io_stack->Parameters.QueryInterface.Size < sizeof(ib_ci_ifc_t) )
	{
		BUS_TRACE_EXIT( BUS_DBG_PNP, 
			("Buffer too small (%d given, %d required).\n",
			p_io_stack->Parameters.QueryInterface.Size, sizeof(ib_ci_ifc_t)) );
		return STATUS_BUFFER_TOO_SMALL;
	}

	/* Copy the interface. */
	p_ifc = (ib_ci_ifc_t*)p_io_stack->Parameters.QueryInterface.Interface;

	p_ifc->wdm.Size = sizeof(ib_ci_ifc_t);
	p_ifc->wdm.Version = IB_CI_INTERFACE_VERSION;
	p_ifc->wdm.Context = p_dev_obj;
	p_ifc->wdm.InterfaceReference = al_ref_ci_ifc;
	p_ifc->wdm.InterfaceDereference = al_deref_ci_ifc;

	/* Set the entry points. */
	p_ifc->register_ca = ib_register_ca;
	p_ifc->deregister_ca = ib_deregister_ca;
	p_ifc->get_relations = __get_relations;
	p_ifc->get_err_str = ib_get_err_str;

	/* take the reference before returning. */
	al_ref_ci_ifc( p_dev_obj );
	BUS_EXIT( BUS_DBG_PNP );
	return STATUS_SUCCESS;
}


static NTSTATUS
__query_cm_ifc(
	IN					DEVICE_OBJECT* const		p_dev_obj,
	IN					IO_STACK_LOCATION* const	p_io_stack )
{
	INFINIBAND_INTERFACE_CM	*p_ifc;

	BUS_ENTER( BUS_DBG_PNP );

	if( p_io_stack->Parameters.QueryInterface.Version != INFINIBAND_INTERFACE_CM_VERSION )
	{
		BUS_TRACE_EXIT( BUS_DBG_PNP, ("Incorrect interface version (%d)\n",
			p_io_stack->Parameters.QueryInterface.Version ) );
		return STATUS_NOT_SUPPORTED;
	}

	if( p_io_stack->Parameters.QueryInterface.Size < sizeof(INFINIBAND_INTERFACE_CM) )
	{
		BUS_TRACE_EXIT( BUS_DBG_PNP, 
			("Buffer too small (%d given, %d required).\n",
			p_io_stack->Parameters.QueryInterface.Size, sizeof(INFINIBAND_INTERFACE_CM)) );
		return STATUS_BUFFER_TOO_SMALL;
	}

	/* Copy the interface. */
	p_ifc = (INFINIBAND_INTERFACE_CM*)p_io_stack->Parameters.QueryInterface.Interface;

	p_ifc->InterfaceHeader.Size = sizeof(INFINIBAND_INTERFACE_CM);
	p_ifc->InterfaceHeader.Version = INFINIBAND_INTERFACE_CM_VERSION;
	p_ifc->InterfaceHeader.Context = p_dev_obj;
	p_ifc->InterfaceHeader.InterfaceReference = al_ref_cm_ifc;
	p_ifc->InterfaceHeader.InterfaceDereference = al_deref_cm_ifc;
	cm_get_interface(&p_ifc->CM);

	/* take the reference before returning. */
	al_ref_cm_ifc( p_dev_obj );
	BUS_EXIT( BUS_DBG_PNP );
	return STATUS_SUCCESS;
}


static NTSTATUS
__query_ibat_ifc(
    IN              DEVICE_OBJECT* const        p_dev_obj,
    IN              IO_STACK_LOCATION* const    p_io_stack )
{
    IBAT_IFC* p_ifc;

    BUS_ENTER( BUS_DBG_PNP );

    if( p_io_stack->Parameters.QueryInterface.Version != IBAT_INTERFACE_VERSION )
    {
        BUS_TRACE_EXIT( BUS_DBG_PNP, ("Incorrect interface version (%d)\n",
            p_io_stack->Parameters.QueryInterface.Version ) );
        return STATUS_NOT_SUPPORTED;
    }

    if( p_io_stack->Parameters.QueryInterface.Size < sizeof(IBAT_IFC) )
    {
        BUS_TRACE_EXIT( BUS_DBG_PNP, 
            ("Buffer too small (%d given, %d required).\n",
            p_io_stack->Parameters.QueryInterface.Size, sizeof(IBAT_IFC)) );
        return STATUS_BUFFER_TOO_SMALL;
    }

    /* Copy the interface. */
    p_ifc = (IBAT_IFC*)p_io_stack->Parameters.QueryInterface.Interface;

    p_ifc->InterfaceHeader.Size = sizeof(IBAT_IFC);
    p_ifc->InterfaceHeader.Version = IBAT_INTERFACE_VERSION;
    p_ifc->InterfaceHeader.Context = p_dev_obj;
    p_ifc->InterfaceHeader.InterfaceReference = al_ref_ifc;
    p_ifc->InterfaceHeader.InterfaceDereference = al_deref_ifc;
    IbatGetInterface(p_ifc);

    /* take the reference before returning. */
    al_ref_ifc( p_dev_obj );
    BUS_EXIT( BUS_DBG_PNP );
    return STATUS_SUCCESS;
}


static NTSTATUS
fdo_query_pnp_state(
	IN				DEVICE_OBJECT* const		p_dev_obj,
	IN				IRP* const					p_irp, 
		OUT			cl_irp_action_t* const		p_action )
{
	bus_fdo_ext_t		*p_ext;

	BUS_ENTER( BUS_DBG_PNP );

	p_ext = (bus_fdo_ext_t*)p_dev_obj->DeviceExtension;

	p_irp->IoStatus.Information |= p_ext->pnp_state;

	*p_action = IrpSkip;

	BUS_EXIT( BUS_DBG_PNP );
	return STATUS_SUCCESS;
}

#pragma alloc_text( PAGED , fdo_query_interface )
static NTSTATUS
fdo_query_interface(
	IN					DEVICE_OBJECT* const	p_dev_obj,
	IN					IRP* const				p_irp, 
		OUT				cl_irp_action_t* const	p_action )
{
	NTSTATUS			status;
	IO_STACK_LOCATION	*p_io_stack;

	BUS_ENTER( BUS_DBG_PNP );

	PAGED_CODE();

	p_io_stack = IoGetCurrentIrpStackLocation( p_irp );
	
	/* Compare requested GUID with our supported interface GUIDs. */
	if( IsEqualGUID( p_io_stack->Parameters.QueryInterface.InterfaceType,
		&GUID_IB_AL_INTERFACE ) )
	{
		status = __query_al_ifc( p_dev_obj, p_io_stack );
	}
	else if( IsEqualGUID( p_io_stack->Parameters.QueryInterface.InterfaceType,
		&GUID_IB_CI_INTERFACE ) )
	{
		status = __query_ci_ifc( p_dev_obj, p_io_stack );
	}
	else if( IsEqualGUID( p_io_stack->Parameters.QueryInterface.InterfaceType,
		&GUID_INFINIBAND_INTERFACE_CM ) )
	{
		status = __query_cm_ifc( p_dev_obj, p_io_stack );
	}
	else if( IsEqualGUID( p_io_stack->Parameters.QueryInterface.InterfaceType,
		&GUID_IBAT_INTERFACE ) )
	{
		status = __query_ibat_ifc( p_dev_obj, p_io_stack );
	}
	else
	{
		status = p_irp->IoStatus.Status;
	}

	if( NT_SUCCESS( status ) )
		*p_action = IrpSkip;
	else if( status == STATUS_BUFFER_TOO_SMALL )
		*p_action = IrpComplete;
	else
		*p_action = IrpIgnore;

	BUS_EXIT( BUS_DBG_PNP );
	return status;
}


static NTSTATUS
__fdo_query_power(
	IN				DEVICE_OBJECT* const		p_dev_obj,
	IN				IRP* const					p_irp,
		OUT			cl_irp_action_t* const		p_action )
{
	NTSTATUS			status = STATUS_SUCCESS;
	IO_STACK_LOCATION	*p_io_stack;

	BUS_ENTER( BUS_DBG_POWER );

	UNUSED_PARAM( p_dev_obj );

	p_io_stack = IoGetCurrentIrpStackLocation( p_irp );

	switch( p_io_stack->Parameters.Power.Type )
	{
	case SystemPowerState:
		/* Fail any requests to hibernate or sleep the system. */
		switch( p_io_stack->Parameters.Power.State.SystemState )
		{
			case PowerSystemHibernate:
			case PowerSystemSleeping1:	// STANDBY support
			case PowerSystemSleeping2:	// STANDBY support
			case PowerSystemSleeping3:	// STANDBY support
			case PowerSystemWorking:
			case PowerSystemShutdown:
 				break;

  			default:
				status = STATUS_NOT_SUPPORTED;
		}
		break;

	case DevicePowerState:
		/* Fail any query for low power states. */
		switch( p_io_stack->Parameters.Power.State.DeviceState )
		{
		case PowerDeviceD0:
		case PowerDeviceD3:
			/* We only support fully powered or off power states. */
			break;

		default:
			status = STATUS_NOT_SUPPORTED;
		}
		break;
	}

	if( status == STATUS_NOT_SUPPORTED )
		*p_action = IrpComplete;
	else
		*p_action = IrpSkip;

	BUS_EXIT( BUS_DBG_POWER );
	return status;
}



/* Work item callback to handle DevicePowerD0 IRPs at passive level. */
static IO_WORKITEM_ROUTINE __device_power_up_completion_workItem;
static void
__device_power_up_completion_workItem(
	IN				DEVICE_OBJECT*				p_dev_obj,
	IN				void*						context )
{
	NTSTATUS			status;
	IO_STACK_LOCATION	*p_io_stack;
	bus_fdo_ext_t		*p_ext;
	IRP					*p_irp;
	POWER_STATE			power_state;

	BUS_ENTER( BUS_DBG_POWER );

    g_post_event("Ibbus: Power Up\n");

	p_ext = (bus_fdo_ext_t*)p_dev_obj->DeviceExtension;
	p_irp = (IRP*)context;
	p_io_stack = IoGetCurrentIrpStackLocation( p_irp );

	IoFreeWorkItem( p_ext->p_po_work_item );
	p_ext->p_po_work_item = NULL;

	/* re-register CA */
	BUS_PRINT( BUS_DBG_POWER, 
		("***** re-register CA, IRQL %d\n", KeGetCurrentIrql()));

	// stat
	if ( p_ext->p_stat ) {
		p_ext->p_stat->thread[BUS_ST_THREAD_POWER_UP].p_thread = KeGetCurrentThread();
		memcpy( p_ext->p_stat->thread[BUS_ST_THREAD_POWER_UP].thread_name, "PowerUp", 8 );
	}
	
	status = __register_ca( p_dev_obj );
	if( !NT_SUCCESS( status ) ) {
		BUS_PRINT( BUS_DBG_POWER, 
			("!!! __register_ca failed (%#x) \n", status));
		goto err_fdo_start;
	}

	/* get mlx4_bus notification interface */
	status = __get_ifc( p_dev_obj, &MLX4_BUS_NOTIFY_GUID,
		sizeof(MLX4_BUS_NOTIFY_INTERFACE), 1, p_ext, (PINTERFACE)&p_ext->notify_ifc );
	if( !NT_SUCCESS( status ) ) 
	{
		BUS_TRACE_EXIT(BUS_DBG_PNP,
			("Getting MLX4_BUS_NOTIFY_GUID interface failed: status=0x%x\n", status));
	}
	else
		p_ext->notify_ifc_taken = TRUE;
    g_post_event("Ibbus: Taken MLX4_BUS_NOTIFY_GUID\n");

	p_ext->device_power_state = p_io_stack->Parameters.Power.State.DeviceState;
	power_state = PoSetPowerState( p_dev_obj, DevicePowerState,
		p_io_stack->Parameters.Power.State );

	BUS_PRINT( BUS_DBG_POWER, 
		("PoSetPowerState: old state %d, new state to %d\n", 
		power_state.DeviceState, p_ext->device_power_state ));

	CL_PRINT_TO_EVENT_LOG( p_dev_obj, EVENT_IBBUS_ANY_WARN,
		("Power increased to: device %d, system %d.\n",
		(int)p_ext->device_power_state, (int)p_ext->system_power_state));

	if ( p_ext->p_stat ) {
		p_ext->p_stat->thread[BUS_ST_THREAD_POWER_UP].p_thread = NULL;
		*p_ext->p_stat->thread[BUS_ST_THREAD_POWER_UP].thread_name = '\0';
	}
	
	goto exit;

err_fdo_start:
	/* Flag device as having failed. */
	p_ext->pnp_state |= PNP_DEVICE_FAILED;
	IoInvalidateDeviceState( p_ext->cl_ext.p_pdo );
exit:
	PoStartNextPowerIrp( p_irp );
	IoCompleteRequest( p_irp, IO_NO_INCREMENT );
	IoReleaseRemoveLock( &p_ext->cl_ext.remove_lock, p_irp );
	BUS_EXIT( BUS_DBG_POWER );
}


/*NOTE: Completion routines must NEVER be pageable. */
static IO_COMPLETION_ROUTINE __device_power_up_completion;
static NTSTATUS
__device_power_up_completion(
	IN				DEVICE_OBJECT				*p_dev_obj,
	IN				IRP							*p_irp,
	IN				void						*context )
{
	NTSTATUS			status = STATUS_SUCCESS;
	bus_fdo_ext_t		*p_ext;
	IO_STACK_LOCATION	*p_io_stack;

	BUS_ENTER( BUS_DBG_POWER );

	UNUSED_PARAM( context );

	p_ext = (bus_fdo_ext_t*)p_dev_obj->DeviceExtension;
	p_io_stack = IoGetCurrentIrpStackLocation( p_irp );

	if( !NT_SUCCESS( p_irp->IoStatus.Status ) ) {
		BUS_PRINT( BUS_DBG_POWER, 
			("IRP_MN_SET_POWER for device failed by lower driver with %08x.\n",
			p_irp->IoStatus.Status));
		status =  STATUS_SUCCESS;
		PoStartNextPowerIrp( p_irp );
		goto release;
	}

	/* Process in a work item to allow blocking. */
	ASSERT( !p_ext->p_po_work_item );
	p_ext->p_po_work_item = IoAllocateWorkItem( p_dev_obj );
	if( !p_ext->p_po_work_item ) {
		BUS_PRINT( BUS_DBG_POWER, 
			("Failed to allocate work item.\n" ));
		status = STATUS_SUCCESS;
		p_ext->pnp_state |= PNP_DEVICE_FAILED;
		IoInvalidateDeviceState( p_ext->cl_ext.p_pdo );
		PoStartNextPowerIrp( p_irp );
		goto release;
	}

	/* Process in work item callback. */
	IoMarkIrpPending( p_irp );
	IoQueueWorkItem( p_ext->p_po_work_item, 
		__device_power_up_completion_workItem, DelayedWorkQueue, p_irp );
	status = STATUS_MORE_PROCESSING_REQUIRED;
	goto exit;

release:	
	IoReleaseRemoveLock( &p_ext->cl_ext.remove_lock, p_irp );
exit:	
	BUS_EXIT( BUS_DBG_POWER );
	return status;
}

static IO_COMPLETION_ROUTINE __device_power_down_workItem_completion;
static NTSTATUS __device_power_down_workItem_completion(
	IN				DEVICE_OBJECT	*p_dev_obj,
	IN				IRP				*p_irp,
	IN				void				*context )
{
	bus_fdo_ext_t		*p_ext = (bus_fdo_ext_t*)p_dev_obj->DeviceExtension;
	UNUSED_PARAM( context );

	BUS_ENTER( BUS_DBG_POWER );

	PoStartNextPowerIrp( p_irp );
	IoReleaseRemoveLock( &p_ext->cl_ext.remove_lock, p_irp );

	// stat
	if ( p_ext->p_stat ) {
		p_ext->p_stat->thread[BUS_ST_THREAD_POWER_DOWN].p_thread = NULL;
		*p_ext->p_stat->thread[BUS_ST_THREAD_POWER_DOWN].thread_name = '\0';
	}

	BUS_EXIT( BUS_DBG_POWER );
	return STATUS_SUCCESS;
}

/* Work item callback to handle DevicePowerD3 IRPs at passive level. */
static IO_WORKITEM_ROUTINE __device_power_down_workItem;
static void
__device_power_down_workItem(
	IN				DEVICE_OBJECT*				p_dev_obj,
	IN				void*						context )
{
	IO_STACK_LOCATION	*p_io_stack;
	bus_fdo_ext_t		*p_ext;
	IRP					*p_irp;
	POWER_STATE			power_state;

	BUS_ENTER( BUS_DBG_POWER );
    g_post_event("Ibbus: Power Down\n");
	
	p_ext = (bus_fdo_ext_t*)p_dev_obj->DeviceExtension;
	p_irp = (IRP*)context;
	p_io_stack = IoGetCurrentIrpStackLocation( p_irp );

	IoFreeWorkItem( p_ext->p_po_work_item );
	p_ext->p_po_work_item = NULL;

	p_ext->device_power_state = p_io_stack->Parameters.Power.State.DeviceState;
	power_state = PoSetPowerState( p_dev_obj, DevicePowerState,
		p_io_stack->Parameters.Power.State );

	BUS_PRINT( BUS_DBG_POWER, 
		("PoSetPowerState: old state %d, new state to %d, IRQL %d\n", 
		power_state.DeviceState, p_ext->device_power_state, KeGetCurrentIrql() ));

	CL_PRINT_TO_EVENT_LOG( p_dev_obj, EVENT_IBBUS_ANY_WARN,
		("Power decreased to: device %d, system %d.\n",
		(int)p_ext->device_power_state, (int)p_ext->system_power_state));

	/* stat */
	if ( p_ext->p_stat ) {
		p_ext->p_stat->thread[BUS_ST_THREAD_POWER_DOWN].p_thread = KeGetCurrentThread();
		memcpy( p_ext->p_stat->thread[BUS_ST_THREAD_POWER_DOWN].thread_name, "PowerDown", 10 );
	}

	/* If it's just shutdown, just pass down. */
	if( p_ext->device_power_state == PowerDeviceD3 && p_io_stack->Parameters.Power.ShutdownType > PowerActionHibernate )
	{
		BUS_PRINT(BUS_DBG_POWER, ("Power off - doing nothing: n_al_ifc_ref %d, n_ci_ifc_ref %d, n_cm_ifc_ref %d, PowerAction %d\n", 
			p_ext->n_al_ifc_ref, p_ext->n_ci_ifc_ref, p_ext->n_cm_ifc_ref, p_io_stack->Parameters.Power.ShutdownType ));
		goto send_irp_down;
	}

	/* Hibernation or Sleep - wait for clients to exit */
	__wait_for_clients_to_exit(p_ext);
	
	/* remove notify interface */
	if ( p_ext->notify_ifc_taken ) {
		p_ext->notify_ifc.i.InterfaceDereference(
			p_ext->notify_ifc.i.Context);
		g_post_event("Ibbus: Released MLX4_BUS_NOTIFY_GUID\n");
		p_ext->notify_ifc_taken = FALSE;
	}
	
	BUS_PRINT( BUS_DBG_POWER, 
		("***** deregister CA \n"));
	__deregister_ca( p_dev_obj );

send_irp_down:
	IoCopyCurrentIrpStackLocationToNext( p_irp );
#pragma warning( push, 3 )
	IoSetCompletionRoutine( p_irp, __device_power_down_workItem_completion,
		NULL, TRUE, TRUE, TRUE );
#pragma warning( pop )
	PoCallDriver( p_ext->cl_ext.p_next_do, p_irp );

	BUS_EXIT( BUS_DBG_POWER );
}



static NTSTATUS
__fdo_set_power(
	IN				DEVICE_OBJECT* const		p_dev_obj,
	IN				IRP* const					p_irp,
		OUT			cl_irp_action_t* const		p_action )
{
	NTSTATUS			status;
	IO_STACK_LOCATION	*p_io_stack;
	bus_fdo_ext_t		*p_ext;

	BUS_ENTER( BUS_DBG_POWER );

	p_ext = p_dev_obj->DeviceExtension;
	p_io_stack = IoGetCurrentIrpStackLocation( p_irp );

	BUS_TRACE( BUS_DBG_POWER, 
		("SET_POWER for FDO %p (ext %p): type %s, state %d, action %d, IRQL %d  \n",
		p_dev_obj, p_ext,
		(p_io_stack->Parameters.Power.Type)
			? "DevicePowerState" : "SystemPowerState",
		p_io_stack->Parameters.Power.State.DeviceState, 
		p_io_stack->Parameters.Power.ShutdownType, KeGetCurrentIrql() ));

	switch( p_io_stack->Parameters.Power.Type )
	{
	case SystemPowerState:
		/* Pass down and let the PDO driver handle it. */
		p_ext->system_power_state = p_io_stack->Parameters.Power.State.SystemState;
		*p_action = IrpIgnore;
		status = STATUS_SUCCESS;
		break;

	case DevicePowerState:
		IoMarkIrpPending( p_irp );
		if( p_io_stack->Parameters.Power.State.DeviceState == PowerDeviceD0 && 
			p_ext->system_power_state == PowerSystemWorking)
		{ /* power up */
			/* If we're already powered up, just pass down. */
			if( p_ext->device_power_state == PowerDeviceD0 )
			{
				status = STATUS_SUCCESS;
				*p_action = IrpIgnore;
				break;
			}

			/* Process in I/O completion callback. */
			IoCopyCurrentIrpStackLocationToNext( p_irp );
#pragma warning( push, 3 )
			IoSetCompletionRoutine( p_irp, __device_power_up_completion, NULL, 
				TRUE, TRUE, TRUE );
#pragma warning( pop )
			PoCallDriver( p_ext->cl_ext.p_next_do, p_irp );
		}
		else
		{ /* power down */

			/* Process in a work item - deregister_ca and HcaDeinit block. */
			ASSERT( !p_ext->p_po_work_item );
			p_ext->p_po_work_item = IoAllocateWorkItem( p_dev_obj );
			if( !p_ext->p_po_work_item )
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			/* Process in work item callback. */
			IoQueueWorkItem(
				p_ext->p_po_work_item, __device_power_down_workItem, DelayedWorkQueue, p_irp );
		}
		*p_action = IrpDoNothing;
		status = STATUS_PENDING;
		break;

	default:
		/* Pass down and let the PDO driver handle it. */
		*p_action = IrpIgnore;
		status = STATUS_SUCCESS;
		break;
	}

	if( !NT_SUCCESS( status ) )
		*p_action = IrpComplete;

	BUS_EXIT( BUS_DBG_POWER );
	return status;
}


/*
 * A CA GUID of zero means that all devices should be reported.
 */
NTSTATUS
bus_get_relations(
	IN				cl_qlist_t*	const			p_pdo_list,
	IN		const	net64_t						ca_guid,
	IN				IRP* const					p_irp )
{
	NTSTATUS			status;
	DEVICE_RELATIONS	*p_rel;
	cl_list_item_t		*p_list_item;
	bus_pdo_ext_t		*p_pdo_ext;
	size_t				n_devs = 0;

	BUS_ENTER( BUS_DBG_PNP );

	/* Count the number of child devices. */
	for( p_list_item = cl_qlist_head( p_pdo_list );
		p_list_item != cl_qlist_end( p_pdo_list );
		p_list_item = cl_qlist_next( p_list_item ) )
	{
		p_pdo_ext = PARENT_STRUCT( p_list_item, bus_pdo_ext_t, list_item );

		if( !p_pdo_ext->b_present )
		{
			// mark it missing to be removed in port_remove
			p_pdo_ext->b_reported_missing = TRUE;
			/*
			 * We don't report a PDO that is no longer present.  This is how
			 * the PDO will get cleaned up.
			 */
			BUS_TRACE( BUS_DBG_PNP, ("Don't report PDO! %s: PDO %p, ext %p, "
				"present %d, missing %d .\n",
				p_pdo_ext->cl_ext.vfptr_pnp_po->identity,
				p_pdo_ext->cl_ext.p_self_do, p_pdo_ext, p_pdo_ext->b_present,
				p_pdo_ext->b_reported_missing ) );
			continue;
		}
		
		if( ca_guid && p_pdo_ext->ca_guid != ca_guid )
			continue;

		n_devs++;
	}

	if( !n_devs )
	{
		BUS_TRACE_EXIT( BUS_DBG_PNP, ("Found 0 PDOs ca_guid %I64x\n", ca_guid));
		return STATUS_NO_SUCH_DEVICE;
	}

	BUS_TRACE( BUS_DBG_PNP, ("Found %d PDOs ca_guid %I64x\n", n_devs, ca_guid));

	/* Add space for our child IOUs. */
	status = cl_alloc_relations( p_irp, n_devs );
	if( !NT_SUCCESS( status ) )
	{
		BUS_TRACE_EXIT( BUS_DBG_ERROR,
			("cl_alloc_relations returned %08x.\n", status) );
		return status;
	}

	p_rel = (DEVICE_RELATIONS*)p_irp->IoStatus.Information;

	for( p_list_item = cl_qlist_head( p_pdo_list );
		p_list_item != cl_qlist_end( p_pdo_list );
		p_list_item = cl_qlist_next( p_list_item ) )
	{
		p_pdo_ext = PARENT_STRUCT( p_list_item, bus_pdo_ext_t, list_item );

		if( !p_pdo_ext->b_present )
			continue;

		if( ca_guid && p_pdo_ext->ca_guid != ca_guid )
			continue;

		BUS_TRACE( BUS_DBG_PNP, ("Reported PDO %p(=%p), ext %p\n", 
			p_pdo_ext->cl_ext.p_self_do, p_pdo_ext->cl_ext.p_pdo, p_pdo_ext ));
		
		p_rel->Objects[p_rel->Count] = p_pdo_ext->cl_ext.p_pdo;
		ObReferenceObject( p_rel->Objects[p_rel->Count++] );
	}

	BUS_EXIT( BUS_DBG_PNP );
	return STATUS_SUCCESS;
}


/*
 * find a bus filter instance (p_bfi) given an *cl_obj: port_mgr or iou_mgr. 
 */

bus_filter_t *
get_bfi_by_obj(IN int obj_type, IN cl_obj_t *p_obj )
{
	bus_filter_t	*p_bfi;
	bus_filter_t	*matched=NULL;

	CL_ASSERT((obj_type == BFI_PORT_MGR_OBJ) || (obj_type == BFI_IOU_MGR_OBJ));

	lock_control_event();

	for(p_bfi=g_bus_filters; p_bfi < &g_bus_filters[MAX_BUS_FILTERS]; p_bfi++) {

		if ( !p_bfi->p_bus_ext )
			continue;

		if ( obj_type == BFI_PORT_MGR_OBJ ) {
			if ( p_obj == p_bfi->p_port_mgr_obj ) {
				matched = p_bfi;
				break;
			}
		}
		else {
			if ( p_obj == p_bfi->p_iou_mgr_obj ) {
				matched = p_bfi;
				break;
			}
		}
	}
	unlock_control_event();

	BUS_TRACE( BUS_DBG_PNP,
				("cl_obj %p type %s_MGR_OBJ --> bfi[%d] %p\n", p_obj,
				(obj_type == BFI_PORT_MGR_OBJ ? "PORT": "IOU"),
				(matched ? (matched - g_bus_filters) : (-1)), matched ) );

	return matched;
}

/*
 * find a bus filter instance given an HCA guid.
 * BFIs are bound to GUIDs in fdo_start().
 */

bus_filter_t *
get_bfi_by_ca_guid( IN net64_t ca_guid )
{
	bus_filter_t	*p_bfi;
	bus_filter_t	*matched=NULL;

	if ( ca_guid == 0ULL )
	{
		matched = g_bus_filters;
		BUS_TRACE( BUS_DBG_PNP, ("ERR guid %I64x -> bfi[0] %p\n",
								ca_guid, matched) );
		CL_ASSERT( ca_guid );
		return matched;
	}

	lock_control_event();

	for(p_bfi=g_bus_filters; p_bfi < &g_bus_filters[MAX_BUS_FILTERS]; p_bfi++)
	{
		if ( !p_bfi->p_bus_ext )
			continue;

		if ( ca_guid == p_bfi->ca_guid )
		{
			matched = p_bfi;
			break;
		}
	}
	unlock_control_event();

#if DBG
	if ( !matched )
	{
		BUS_PRINT( BUS_DBG_PNP, ("No Match ca_guid 0x%I64x -> bfi[%d] %p\n",
									ca_guid, -1, matched ) );
	}
#endif
	return matched;
}


bus_filter_t *
alloc_bfi( IN DRIVER_OBJECT  *p_driver_obj, OUT int *p_instance_count )
{
	bus_filter_t	*p_bfi;
	bus_filter_t	*matched=NULL;

    /* Using unsafe function so that the IRQL remains at PASSIVE_LEVEL.
     * IoCreateDeviceSecure & IoCreateSymbolicLink must be called at
     * PASSIVE_LEVEL.
	 */
	lock_control_event();

	// find 1st unused bfi slot.
	for(p_bfi=g_bus_filters; p_bfi < &g_bus_filters[MAX_BUS_FILTERS]; p_bfi++)
	{
		if ( !p_bfi->p_bus_ext )
		{
			/* temp setting until 'real' p_bus_ext is alloc; see bus_add_device.
			 * If p_bus_ext is ! 0, then bfi slot is allocated, although it
			 * may not yet have a bound CA guid; set set_get_
			 */
			p_bfi->p_bus_ext = (bus_fdo_ext_t*)p_driver_obj;
			matched = p_bfi;
			*p_instance_count = ++g_bfi_InstanceCount; // record in-use
			break;
		}
	}
	unlock_control_event();

#if DBG
	RtlStringCbPrintfA ( p_bfi->whoami,
						 sizeof(p_bfi->whoami),
						 "bfi-%d",
						 (g_bfi_InstanceCount - 1) );

	p_bfi->magic = BFI_MAGIC;
#endif

	BUS_TRACE( BUS_DBG_PNP, ("%s %p\n",
				(matched ? matched->whoami:"Nobody"), matched) );

	return matched;
}


int
free_bfi( IN  bus_filter_t  *p_bfi )
{
	int	remaining;

	lock_control_event();
	p_bfi->p_bus_ext = NULL;
	p_bfi->ca_guid = 0ULL;
	remaining = --g_bfi_InstanceCount; // one less bfi in-use
	unlock_control_event();
	
	return remaining;
}

int
get_bfi_count( void )
{
	int	ic;

	lock_control_event();
	ic = g_bfi_InstanceCount;
	unlock_control_event();
	
	return ic;
}

#if DBG
char *get_obj_state_str(cl_state_t state)
{
	switch( state ) {
	  case CL_UNINITIALIZED:
		return "UNINITIALIZED";
	  case CL_INITIALIZED:
		return "INITIALIZED";
	  case CL_DESTROYING:
		return "DESTROYING";
	  case CL_DESTROYED:
		return "DESTROYED";
	  default:
		break;
	}
	return "Err - Bad obj state";
}
#endif

